/* harmony default export */

/* harmony export (binding) */

/* harmony import */

/*#__PURE__*/

/**
	* If provided a value, the accumulator function returns an updated mean. If not provided a value, the accumulator function returns the current mean.
	*
	* @private
	* @param {number} [x] - input value
	* @returns {(number|null)} mean or null
	*/

/**
	* If provided a value, the accumulator function returns an updated range. If not provided a value, the accumulator function returns the current range.
	*
	* @private
	* @param {number} [x] - input value
	* @returns {(number|null)} range or null
	*/

/**
 * Iterates through children that are "valid elements".
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child with the index reflecting the position relative to "valid components".
 */

/**
 * Iterates through children that are typically specified as `props.children`,
 * but only maps over children that are "valid elements".
 *
 * The mapFunction provided index will be normalised to the components mapped,
 * so an invalid component would not increase the index.
 *
 */

/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/**
* An ISLE component that displays an engagement meter with which the students can indicate how well they are following the class.
*/

/**
* Compute a moving arithmetic mean incrementally.
*
* @module @stdlib/stats/incr/mmean
*
* @example
* var incrmmean = require( '@stdlib/stats/incr/mmean' );
*
* var accumulator = incrmmean( 3 );
*
* var mu = accumulator();
* // returns null
*
* mu = accumulator( 2.0 );
* // returns 2.0
*
* mu = accumulator( -5.0 );
* // returns -1.5
*
* mu = accumulator( 3.0 );
* // returns 0.0
*
* mu = accumulator( 5.0 );
* // returns 1.0
*
* mu = accumulator();
* // returns 1.0
*/

/**
* Compute a moving range incrementally.
*
* @module @stdlib/stats/incr/mrange
*
* @example
* var incrmrange = require( '@stdlib/stats/incr/mrange' );
*
* var accumulator = incrmrange( 3 );
*
* var r = accumulator();
* // returns null
*
* r = accumulator( 2.0 );
* // returns 0.0
*
* r = accumulator( -5.0 );
* // returns 7.0
*
* r = accumulator( 3.0 );
* // returns 8.0
*
* r = accumulator( 5.0 );
* // returns 10.0
*
* r = accumulator();
* // returns 10.0
*/

/**
* Returns an accumulator function which incrementally computes a moving arithmetic mean.
*
* @param {PositiveInteger} W - window size
* @throws {TypeError} must provide a positive integer
* @returns {Function} accumulator function
*
* @example
* var accumulator = incrmmean( 3 );
*
* var mu = accumulator();
* // returns null
*
* mu = accumulator( 2.0 );
* // returns 2.0
*
* mu = accumulator( -5.0 );
* // returns -1.5
*
* mu = accumulator( 3.0 );
* // returns 0.0
*
* mu = accumulator( 5.0 );
* // returns 1.0
*
* mu = accumulator();
* // returns 1.0
*/

/**
* Returns an accumulator function which incrementally computes a moving range.
*
* @param {PositiveInteger} W - window size
* @throws {TypeError} must provide a positive integer
* @returns {Function} accumulator function
*
* @example
* var accumulator = incrmrange( 3 );
*
* var r = accumulator();
* // returns null
*
* r = accumulator( 2.0 );
* // returns 0.0
*
* r = accumulator( -5.0 );
* // returns 7.0
*
* r = accumulator( 3.0 );
* // returns 8.0
*
* r = accumulator( 5.0 );
* // returns 10.0
*
* r = accumulator();
* // returns 10.0
*/

/***/

// Case: incoming value is NaN, the sliding mean is automatically NaN...

// Case: incoming value is NaN...

// Case: the current mean is NaN, so nothing to do until the buffer no longer contains NaN values...

// Case: updating existing window; however, the minimum and maximum values do not change so nothing to do but update our buffer...

// EXPORTS //

// Exports

// MAIN //

// MODULES //

// Module

// PROPERTIES //

// Update the index for managing the circular buffer:

// VARIABLES //

// explicitly set to avoid `N < W` branch

// mean is automatically NaN, so no need to continue

// no need to continue searching
