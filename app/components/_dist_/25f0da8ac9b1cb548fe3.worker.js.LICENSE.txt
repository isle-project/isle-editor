/*
		* In the original C implementation (see `init_by_array()`),
		*
		* ```c
		* mt[i] = (mt[i]^((mt[i-1]^(mt[i-1]>>30))*1566083941UL)) - i;
		* ```
		*
		* In order to replicate this in JavaScript, we must emulate C-like multiplication of unsigned 32-bit integers.
		*/

/*
		* In the original C implementation (see `init_by_array()`),
		*
		* ```c
		* mt[i] = (mt[i]^((mt[i-1]^(mt[i-1]>>30))*1664525UL)) + seed[j] + j;
		* ```
		*
		* In order to replicate this in JavaScript, we must emulate C-like multiplication of unsigned 32-bit integers.
		*/

/*
		* In the original C implementation (see `init_genrand()`),
		*
		* ```c
		* mt[i] = (KNUTH_MULTIPLIER * (mt[i-1] ^ (mt[i-1] >> 30)) + i)
		* ```
		*
		* In order to replicate this in JavaScript, we must emulate C-like multiplication of unsigned 32-bit integers.
		*/

/*
	* Create the index input arguments along with the value to set...
	* > function set( i0, i1, ..., v ) {
	*/

/*
	* Create the index input arguments...
	* > function get( i0, i1, ...) {
	*/

/*
	* Create the index input arguments...
	* > function set( i0, i1,..., v ) {
	*/

/*
	* Index into the array according to the offset and strides...
	* > data[offset+strides[0]*i0+strides[1]*i1+...] = v;
	*/

/*
	* Index into the array according to the offset and strides...
	* > return data[offset+strides[0]*i0+strides[1]*i1+...];
	*/

/*
	* Resolve indices based on the index mode.
	* > i0 = getIndex( i0, shape[0]-1, mode );
	*/

/*
	* Set the uint16 view to a value having distinguishable lower and higher order words.
	*
	* 4660 => 0x1234 => 0x12 0x34 => '00010010 00110100' => (0x12,0x34) == (18,52)
	*/

/*
	* Type check each index.
	* > if ( !isInteger( i0 ) ) { throw new TypeError( ... ) }
	*/

/*
	* e.g.,
	*
	*   function flattenArray( x ) {
	*       var o = [];
	*       var i0, i1;
	*       for ( i0 = 0; i0 < 2; i0++ ) {
	*           for ( i1 = 0; i1 < 2; i1++ ) {
	*               o.push( x[i0][i1] );
	*           }
	*       }
	*       return o;
	*   }
	*/

/*
	* e.g.,
	*     function get( i0, i1, i2 ) {
	*         if ( !isInteger( i0 ) ) {
	*             throw new TypeError( 'invalid argument. Indices must be integer valued. Argument: 0. Value: `'+i0+'`.' );
	*         }
	*         if ( !isInteger( i1 ) ) {
	*             throw new TypeError( 'invalid argument. Indices must be integer valued. Argument: 1. Value: `'+i1+'`.' );
	*         }
	*         if ( !isInteger( i2 ) ) {
	*             throw new TypeError( 'invalid argument. Indices must be integer valued. Argument: 2. Value: `'+i2+'`.' );
	*         }
	*         i0 = getIndex( i0, this._shape[0]-1, 'throw' );
	*         i1 = getIndex( i1, this._shape[1]-1, 'throw' );
	*         i2 = getIndex( i2, this._shape[2]-1, 'throw' );
	*         return this._buffer[ this._offset + this._strides[0]*i0 + this._strides[1]*i1 + this._strides[2]*i2 ];
	*     }
	*/

/*
	* e.g.,
	*     function get( i0, i1, i2 ) {
	*         return this._buffer[ this._offset + this._strides[0]*i0 + this._strides[1]*i1 + this._strides[2]*i2 ];
	*     }
	*/

/*
	* e.g.,
	*     function set( i0, i1, i2, v ) {
	*         if ( !isInteger( i0 ) ) {
	*             throw new TypeError( 'invalid argument. Indices must be integer valued. Argument: 0. Value: `'+i0+'`.' );
	*         }
	*         if ( !isInteger( i1 ) ) {
	*             throw new TypeError( 'invalid argument. Indices must be integer valued. Argument: 1. Value: `'+i1+'`.' );
	*         }
	*         if ( !isInteger( i2 ) ) {
	*             throw new TypeError( 'invalid argument. Indices must be integer valued. Argument: 2. Value: `'+i2+'`.' );
	*         }
	*         i0 = getIndex( i0, this._shape[0]-1, 'throw' );
	*         i1 = getIndex( i1, this._shape[1]-1, 'throw' );
	*         i2 = getIndex( i2, this._shape[2]-1, 'throw' );
	*         this._buffer[ this._offset + this._strides[0]*i0 + this._strides[1]*i1 + this._strides[2]*i2 ] = v;
	*         return this;
	*     }
	*/

/*
	* e.g.,
	*     function set( i0, i1, i2, v ) {
	*         this._buffer[ this._offset + this._strides[0]*i0 + this._strides[1]*i1 + this._strides[2]*i2 ] = v;
	*         return this;
	*     }
	*/

/*
 * Export kMaxLength after typed array support is determined.
 */

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */

/*
* Built-in `typeof` operator behavior:
*
* ```text
* typeof null => 'object'
* typeof undefined => 'undefined'
* typeof 'a' => 'string'
* typeof 5 => 'number'
* typeof NaN => 'number'
* typeof true => 'boolean'
* typeof false => 'boolean'
* typeof {} => 'object'
* typeof [] => 'object'
* typeof function foo(){} => 'function'
* typeof function* foo(){} => 'object'
* typeof Symbol() => 'symbol'
* ```
*
*/

/* 0 */

/* 1 */

/* 10 */

/* 100 */

/* 101 */

/* 102 */

/* 103 */

/* 104 */

/* 105 */

/* 106 */

/* 107 */

/* 108 */

/* 109 */

/* 11 */

/* 110 */

/* 111 */

/* 112 */

/* 113 */

/* 114 */

/* 115 */

/* 116 */

/* 117 */

/* 118 */

/* 119 */

/* 12 */

/* 120 */

/* 121 */

/* 122 */

/* 123 */

/* 124 */

/* 125 */

/* 126 */

/* 127 */

/* 128 */

/* 129 */

/* 13 */

/* 130 */

/* 131 */

/* 132 */

/* 133 */

/* 134 */

/* 135 */

/* 136 */

/* 137 */

/* 138 */

/* 139 */

/* 14 */

/* 140 */

/* 141 */

/* 142 */

/* 143 */

/* 144 */

/* 145 */

/* 146 */

/* 147 */

/* 148 */

/* 149 */

/* 15 */

/* 150 */

/* 151 */

/* 152 */

/* 153 */

/* 154 */

/* 155 */

/* 156 */

/* 157 */

/* 158 */

/* 159 */

/* 16 */

/* 160 */

/* 161 */

/* 162 */

/* 163 */

/* 164 */

/* 165 */

/* 166 */

/* 167 */

/* 168 */

/* 169 */

/* 17 */

/* 170 */

/* 171 */

/* 172 */

/* 173 */

/* 174 */

/* 175 */

/* 176 */

/* 177 */

/* 178 */

/* 179 */

/* 18 */

/* 180 */

/* 181 */

/* 182 */

/* 183 */

/* 184 */

/* 185 */

/* 186 */

/* 187 */

/* 188 */

/* 189 */

/* 19 */

/* 190 */

/* 191 */

/* 192 */

/* 193 */

/* 194 */

/* 195 */

/* 196 */

/* 197 */

/* 198 */

/* 199 */

/* 2 */

/* 20 */

/* 200 */

/* 201 */

/* 202 */

/* 203 */

/* 204 */

/* 205 */

/* 206 */

/* 207 */

/* 208 */

/* 209 */

/* 21 */

/* 210 */

/* 211 */

/* 212 */

/* 213 */

/* 214 */

/* 215 */

/* 216 */

/* 217 */

/* 218 */

/* 219 */

/* 22 */

/* 220 */

/* 221 */

/* 222 */

/* 223 */

/* 224 */

/* 225 */

/* 226 */

/* 227 */

/* 228 */

/* 229 */

/* 23 */

/* 230 */

/* 231 */

/* 232 */

/* 233 */

/* 234 */

/* 235 */

/* 236 */

/* 237 */

/* 238 */

/* 239 */

/* 24 */

/* 240 */

/* 241 */

/* 242 */

/* 243 */

/* 244 */

/* 245 */

/* 246 */

/* 247 */

/* 248 */

/* 249 */

/* 25 */

/* 250 */

/* 251 */

/* 252 */

/* 253 */

/* 254 */

/* 255 */

/* 256 */

/* 257 */

/* 258 */

/* 259 */

/* 26 */

/* 260 */

/* 261 */

/* 262 */

/* 263 */

/* 264 */

/* 265 */

/* 266 */

/* 267 */

/* 268 */

/* 269 */

/* 27 */

/* 270 */

/* 271 */

/* 272 */

/* 273 */

/* 274 */

/* 275 */

/* 276 */

/* 277 */

/* 278 */

/* 279 */

/* 28 */

/* 280 */

/* 281 */

/* 282 */

/* 283 */

/* 284 */

/* 285 */

/* 286 */

/* 287 */

/* 288 */

/* 289 */

/* 29 */

/* 290 */

/* 291 */

/* 292 */

/* 293 */

/* 294 */

/* 295 */

/* 296 */

/* 297 */

/* 298 */

/* 299 */

/* 3 */

/* 30 */

/* 300 */

/* 301 */

/* 302 */

/* 303 */

/* 304 */

/* 305 */

/* 306 */

/* 307 */

/* 308 */

/* 309 */

/* 31 */

/* 310 */

/* 311 */

/* 312 */

/* 313 */

/* 314 */

/* 315 */

/* 316 */

/* 317 */

/* 318 */

/* 319 */

/* 32 */

/* 320 */

/* 321 */

/* 322 */

/* 323 */

/* 324 */

/* 325 */

/* 326 */

/* 327 */

/* 328 */

/* 329 */

/* 33 */

/* 330 */

/* 331 */

/* 332 */

/* 333 */

/* 334 */

/* 335 */

/* 336 */

/* 337 */

/* 338 */

/* 339 */

/* 34 */

/* 340 */

/* 341 */

/* 342 */

/* 343 */

/* 344 */

/* 345 */

/* 346 */

/* 347 */

/* 348 */

/* 349 */

/* 35 */

/* 350 */

/* 351 */

/* 352 */

/* 353 */

/* 354 */

/* 355 */

/* 356 */

/* 357 */

/* 358 */

/* 359 */

/* 36 */

/* 360 */

/* 361 */

/* 362 */

/* 363 */

/* 364 */

/* 365 */

/* 366 */

/* 367 */

/* 368 */

/* 369 */

/* 37 */

/* 370 */

/* 371 */

/* 372 */

/* 373 */

/* 374 */

/* 375 */

/* 376 */

/* 377 */

/* 378 */

/* 379 */

/* 38 */

/* 380 */

/* 381 */

/* 382 */

/* 383 */

/* 384 */

/* 385 */

/* 386 */

/* 387 */

/* 388 */

/* 389 */

/* 39 */

/* 390 */

/* 391 */

/* 392 */

/* 393 */

/* 394 */

/* 395 */

/* 396 */

/* 397 */

/* 398 */

/* 399 */

/* 4 */

/* 40 */

/* 400 */

/* 401 */

/* 402 */

/* 403 */

/* 404 */

/* 405 */

/* 406 */

/* 407 */

/* 408 */

/* 409 */

/* 41 */

/* 410 */

/* 411 */

/* 412 */

/* 413 */

/* 414 */

/* 415 */

/* 416 */

/* 417 */

/* 418 */

/* 419 */

/* 42 */

/* 420 */

/* 421 */

/* 422 */

/* 423 */

/* 424 */

/* 425 */

/* 426 */

/* 427 */

/* 428 */

/* 429 */

/* 43 */

/* 430 */

/* 431 */

/* 432 */

/* 433 */

/* 434 */

/* 435 */

/* 436 */

/* 437 */

/* 438 */

/* 439 */

/* 44 */

/* 440 */

/* 441 */

/* 442 */

/* 443 */

/* 444 */

/* 445 */

/* 446 */

/* 447 */

/* 448 */

/* 449 */

/* 45 */

/* 450 */

/* 451 */

/* 452 */

/* 453 */

/* 454 */

/* 455 */

/* 456 */

/* 457 */

/* 458 */

/* 459 */

/* 46 */

/* 460 */

/* 461 */

/* 462 */

/* 463 */

/* 464 */

/* 465 */

/* 466 */

/* 467 */

/* 468 */

/* 469 */

/* 47 */

/* 470 */

/* 471 */

/* 472 */

/* 473 */

/* 474 */

/* 475 */

/* 476 */

/* 477 */

/* 478 */

/* 479 */

/* 48 */

/* 480 */

/* 481 */

/* 482 */

/* 483 */

/* 484 */

/* 485 */

/* 486 */

/* 487 */

/* 488 */

/* 489 */

/* 49 */

/* 490 */

/* 491 */

/* 492 */

/* 493 */

/* 494 */

/* 495 */

/* 496 */

/* 497 */

/* 498 */

/* 499 */

/* 5 */

/* 50 */

/* 500 */

/* 501 */

/* 502 */

/* 503 */

/* 504 */

/* 505 */

/* 506 */

/* 507 */

/* 508 */

/* 509 */

/* 51 */

/* 510 */

/* 511 */

/* 512 */

/* 513 */

/* 514 */

/* 515 */

/* 516 */

/* 517 */

/* 518 */

/* 519 */

/* 52 */

/* 520 */

/* 521 */

/* 522 */

/* 523 */

/* 524 */

/* 525 */

/* 526 */

/* 527 */

/* 528 */

/* 529 */

/* 53 */

/* 530 */

/* 531 */

/* 532 */

/* 533 */

/* 534 */

/* 535 */

/* 536 */

/* 537 */

/* 538 */

/* 539 */

/* 54 */

/* 540 */

/* 541 */

/* 542 */

/* 543 */

/* 544 */

/* 545 */

/* 546 */

/* 547 */

/* 548 */

/* 549 */

/* 55 */

/* 550 */

/* 551 */

/* 552 */

/* 553 */

/* 554 */

/* 555 */

/* 556 */

/* 557 */

/* 558 */

/* 559 */

/* 56 */

/* 560 */

/* 561 */

/* 562 */

/* 563 */

/* 564 */

/* 565 */

/* 566 */

/* 567 */

/* 568 */

/* 569 */

/* 57 */

/* 570 */

/* 571 */

/* 572 */

/* 573 */

/* 574 */

/* 575 */

/* 576 */

/* 577 */

/* 578 */

/* 579 */

/* 58 */

/* 580 */

/* 581 */

/* 582 */

/* 583 */

/* 584 */

/* 585 */

/* 586 */

/* 587 */

/* 588 */

/* 589 */

/* 59 */

/* 590 */

/* 591 */

/* 592 */

/* 593 */

/* 594 */

/* 595 */

/* 596 */

/* 597 */

/* 6 */

/* 60 */

/* 61 */

/* 62 */

/* 63 */

/* 64 */

/* 65 */

/* 66 */

/* 67 */

/* 68 */

/* 69 */

/* 7 */

/* 70 */

/* 71 */

/* 72 */

/* 73 */

/* 74 */

/* 75 */

/* 76 */

/* 77 */

/* 78 */

/* 79 */

/* 8 */

/* 80 */

/* 81 */

/* 82 */

/* 83 */

/* 84 */

/* 85 */

/* 86 */

/* 87 */

/* 88 */

/* 89 */

/* 9 */

/* 90 */

/* 91 */

/* 92 */

/* 93 */

/* 94 */

/* 95 */

/* 96 */

/* 97 */

/* 98 */

/* 99 */

/* This is a generated file. Do not edit directly. */

/* WEBPACK VAR INJECTION */

/* eslint-disable max-len */

/* eslint-disable max-lines, max-len */

/* eslint-disable no-invalid-this */

/* eslint-disable no-proto */

/* eslint-disable no-restricted-syntax */

/* eslint-disable no-underscore-dangle, no-proto */

/* eslint-enable no-invalid-this */

/* eslint-env browser */

/* harmony default export */

/* harmony export (binding) */

/* harmony import */

/* non-linear */

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */

/*#__PURE__*/

/**
	* Active `debug` instances.
	*/

/**
	* Array order.
	*
	* ## Notes
	*
	* -   The array order is either row-major (C-style) or column-major (Fortran-style).
	*
	*
	* @private
	* @name order
	* @memberof ndarray.prototype
	* @type {string}
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var order = x.order;
	* // returns 'row-major'
	*/

/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/

/**
	* Computes data point distances to centroids and returns centroid assignment predictions.
	*
	* @private
	* @param {ndarray} [out] - output vector for storing centroid assignment predictions
	* @param {ndarray} X - matrix containing data points (`n x d`, where `n` is the number of data points and `d` is the number of dimensions)
	* @throws {TypeError} output argument must be a vector
	* @throws {TypeError} must provide a matrix
	* @throws {Error} vector length must match number of data points
	* @throws {Error} number of matrix columns must match centroid dimensions
	* @returns {(ndarray|null)} vector containing centroid (index) predictions or null
	*/

/**
	* Computes initial centroids and associated cluster statistics.
	*
	* @private
	* @param {ndarray} v - data vector
	* @returns {boolean} boolean indicating whether an accumulator has finished computing initial centroids
	*/

/**
	* Constant function.
	*
	* @private
	* @returns {*} constant value
	*/

/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/

/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/

/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/

/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/

/**
	* Flattens an array and deep copies array elements.
	*
	* @private
	* @param {Array} arr - array to flatten
	* @throws {TypeError} must provide an array
	* @returns {Array} flattened array
	*/

/**
	* Flattens an array.
	*
	* @private
	* @param {Array} arr - array to flatten
	* @throws {TypeError} must provide an array
	* @returns {Array} flattened array
	*/

/**
	* Generates a pseudorandom integer on the interval \\( [1,2^{31}-1) \\).
	*
	* @private
	* @returns {integer32} pseudorandom integer
	*
	* @example
	* var v = minstd();
	* // returns <number>
	*/

/**
	* Generates a pseudorandom integer on the interval \\( [1,2^{31}-1) \\).
	*
	* @private
	* @returns {integer32} pseudorandom integer
	*/

/**
	* Generates a pseudorandom integer on the interval \\( [1,2^{32}-1) \\).
	*
	* @private
	* @returns {uinteger32} pseudorandom integer
	*
	* @example
	* var r = mt19937();
	* // returns <number>
	*/

/**
	* Generates a pseudorandom number on the interval \\( [0,1) \\).
	*
	* ## Notes
	*
	* -   The original C implementation credits Isaku Wada for this algorithm (2002/01/09).
	*
	* @private
	* @returns {number} pseudorandom number
	*
	* @example
	* var r = normalized();
	* // returns <number>
	*/

/**
	* Generates a pseudorandom number on the interval \\( [0,1) \\).
	*
	* @private
	* @returns {number} pseudorandom number
	*
	* @example
	* var v = normalized();
	* // returns <number>
	*/

/**
	* If provided a data point vector, the accumulator function returns updated cluster results. If not provided a data point vector, the accumulator function returns the current cluster results.
	*
	* @private
	* @param {ndarray} [vec] - data vector
	* @throws {TypeError} must provide a 1-dimensional ndarray
	* @throws {Error} vector length must match centroid dimensions
	* @returns {(Object|null)} cluster results or null
	*/

/**
	* If provided a data point vector, updates the mean vector and associated standard deviation along each dimension. If not provided a data point vector, returns the current mean vector and associated standard deviation along each dimension.
	*
	* @private
	* @param {ndarray} [vec] - data point vector
	* @returns {Float64Array} current mean vector and associated standard deviation along each dimension
	*/

/**
	* If provided a value, the accumulator function returns an updated mean. If not provided a value, the accumulator function returns the current mean.
	*
	* @private
	* @param {number} [x] - new value
	* @returns {(number|null)} mean value or null
	*/

/**
	* If provided a value, the accumulator function returns updated results. If not provided a value, the accumulator function returns the current results.
	*
	* @private
	* @param {number} [x] - input value
	* @returns {(ArrayLikeObject|null)} output array or null
	*/

/**
	* Index offset which specifies the buffer index at which to start iterating over array elements.
	*
	* @private
	* @name offset
	* @memberof ndarray.prototype
	* @type {NonNegativeInteger}
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var o = x.offset;
	* // returns 0
	*/

/**
	* Index strides which specify how to access data along corresponding array dimensions.
	*
	* @private
	* @name strides
	* @memberof ndarray.prototype
	* @type {IntegerArray}
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var s = x.strides;
	* // returns [ 2, 1 ]
	*/

/**
	* Information about the memory layout of the array.
	*
	* @private
	* @name flags
	* @memberof ndarray.prototype
	* @type {Object}
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var flgs = x.flags;
	* // returns <Object>
	*/

/**
	* Length of the array.
	*
	* @private
	* @name length
	* @memberof ndarray.prototype
	* @type {NonNegativeInteger}
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var len = x.length;
	* // returns 6
	*/

/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/

/**
	* Number of dimensions.
	*
	* @private
	* @name ndims
	* @memberof ndarray
	* @type {PositiveInteger}
	*
	* @example
	* var ndims = ndarray.ndims;
	* // returns <number>
	*/

/**
	* Number of dimensions.
	*
	* @private
	* @name ndims
	* @memberof ndarray.prototype
	* @type {PositiveInteger}
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var ndims = x.ndims;
	* // returns <number>
	*/

/**
	* Pointer to the underlying data buffer.
	*
	* @private
	* @name data
	* @memberof ndarray.prototype
	* @type {(Array|TypedArray|Buffer)}
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var data = x.data;
	* // returns [ 1, 2, 3, 4, 5, 6 ]
	*/

/**
	* Returns a pseudorandom number drawn from a discrete uniform distribution with minimum support `a` and maximum support `b`.
	*
	* @private
	* @param {integer} a - minimum support
	* @param {integer} b - maximum support
	* @returns {integer} pseudorandom number
	*
	* @example
	* var v = discreteUniform2( 1, 10 );
	* // returns <number>
	*
	* @example
	* var v = discreteUniform2( 1, 0 );
	* // returns NaN
	*/

/**
	* Returns a pseudorandom number drawn from a discrete uniform distribution with minimum support `a` and maximum support `b`.
	*
	* @private
	* @returns {integer} pseudorandom number
	*
	* @example
	* var v = discreteUniform1();
	* // returns <number>
	*/

/**
	* Returns an array element located at a specified linear index.
	*
	* @private
	* @name iget
	* @memberof ndarray.prototype
	* @type {Function}
	* @param {integer} idx - linear index
	* @returns {*} array element
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var v = x.iget( 3 );
	* // returns 4
	*/

/**
	* Returns an array element located at a specified linear index.
	*
	* @private
	* @param {integer} idx - linear view index
	* @throws {TypeError} index must be an integer value
	* @throws {RangeError} index exceeds array dimensions
	* @returns {*} array element
	*/

/**
	* Returns an array element.
	*
	* @private
	* @name get
	* @memberof ndarray.prototype
	* @type {Function}
	* @param {...integer} idx - indices
	* @returns {*} array element
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var v = x.get( 1, 1 );
	* // returns 4
	*/

/**
	* Returns an array element.
	*
	* @private
	* @param {...integer} idx - indices
	* @throws {TypeError} provided indices must be integer valued
	* @throws {RangeError} index exceeds array dimensions
	* @returns {*} array element
	*/

/**
	* Returns an array element.
	*
	* @private
	* @param {integer} i - index
	* @throws {TypeError} index must be an integer value
	* @throws {RangeError} index exceeds array dimensions
	* @returns {*} array element
	*/

/**
	* Returns an array element.
	*
	* @private
	* @param {integer} i - index for first dimension
	* @param {integer} j - index for second dimension
	* @param {integer} k - index for third dimension
	* @param {integer} l - index for fourth dimension
	* @throws {TypeError} index for first dimension must be an integer value
	* @throws {TypeError} index for second dimension must be an integer value
	* @throws {TypeError} index for third dimension must be an integer value
	* @throws {TypeError} index for fourth dimension must be an integer value
	* @throws {RangeError} index exceeds array dimensions
	* @returns {*} array element
	*/

/**
	* Returns an array element.
	*
	* @private
	* @param {integer} i - index for first dimension
	* @param {integer} j - index for second dimension
	* @param {integer} k - index for third dimension
	* @throws {TypeError} index for first dimension must be an integer value
	* @throws {TypeError} index for second dimension must be an integer value
	* @throws {TypeError} index for third dimension must be an integer value
	* @throws {RangeError} index exceeds array dimensions
	* @returns {*} array element
	*/

/**
	* Returns an array element.
	*
	* @private
	* @param {integer} i - index for first dimension
	* @param {integer} j - index for second dimension
	* @throws {TypeError} index for first dimension must be an integer value
	* @throws {TypeError} index for second dimension must be an integer value
	* @throws {RangeError} index exceeds array dimensions
	* @returns {*} array element
	*/

/**
	* Returns the PRNG seed length.
	*
	* @private
	* @returns {PositiveInteger} seed length
	*/

/**
	* Returns the PRNG seed.
	*
	* @private
	* @returns {PRNGSeedMINSTD} seed
	*/

/**
	* Returns the PRNG seed.
	*
	* @private
	* @returns {PRNGSeedMT19937} seed
	*/

/**
	* Returns the PRNG state length.
	*
	* @private
	* @returns {PositiveInteger} state length
	*/

/**
	* Returns the PRNG state size (in bytes).
	*
	* @private
	* @returns {PositiveInteger} state size (in bytes)
	*/

/**
	* Returns the current PRNG state.
	*
	* ## Notes
	*
	* -   The PRNG state array is comprised of a preamble followed by `3` sections:
	*
	*     0.  preamble (version + number of sections)
	*     1.  internal PRNG state
	*     2.  auxiliary state information
	*     3.  PRNG seed
	*
	* -   The first element of the PRNG state array preamble is the state array schema version.
	*
	* -   The second element of the PRNG state array preamble is the number of state array sections (i.e., `3`).
	*
	* -   The first element of each section following the preamble specifies the section length. The remaining section elements comprise the section contents.
	*
	* @private
	* @returns {PRNGStateMT19937} current state
	*/

/**
	* Returns the current PRNG state.
	*
	* ## Notes
	*
	* -   The PRNG state array is comprised of a preamble followed by `3` sections:
	*
	*     0.  preamble (version + number of sections)
	*     1.  shuffle table
	*     2.  internal PRNG state
	*     3.  PRNG seed
	*
	* -   The first element of the PRNG state array preamble is the state array schema version.
	*
	* -   The second element of the PRNG state array preamble is the number of state array sections (i.e., `3`).
	*
	* -   The first element of each section following the preamble specifies the section length. The remaining section elements comprise the section contents.
	*
	* @private
	* @returns {PRNGStateMINSTD} current state
	*/

/**
	* Returns the current pseudorandom number generator state.
	*
	* @private
	* @returns {PRNGStateMT19937} current state
	*/

/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/

/**
	* Samples elements from a population.
	*
	* @private
	* @param {Options} [options] - function options
	* @param {NonNegativeInteger} [options.size] - sample size
	* @param {boolean} [options.replace=true] - boolean indicating whether to sample with replacement
	* @param {boolean} [options.mutate=false] - boolean indicating whether to mutate the `pool` when sampling without replacement
	* @throws {TypeError} options argument must be an object
	* @throws {TypeError} must provide valid options
	* @throws {RangeError} `size` option must be less than or equal to the population when the `replace` option is `false`
	* @returns {Array} sample
	*/

/**
	* Samples elements from an array-like object.
	*
	* @private
	* @param {ArrayLike} x - array-like object from which to sample elements
	* @param {Options} [options] - function options
	* @param {NonNegativeInteger} [options.size] - sample size
	* @param {ProbabilityArray} [options.probs] - element probabilities
	* @param {boolean} [options.replace=true] - boolean indicating whether to sample with replacement
	* @throws {TypeError} first argument must be array-like
	* @throws {TypeError} options argument must be an object
	* @throws {TypeError} must provide valid options
	* @throws {RangeError} `size` option must be less than or equal to the length of `x` when the `replace` option is `false`
	* @returns {Array} sample
	*/

/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/

/**
	* Serializes an ndarray as a JSON object.
	*
	* ## Notes
	*
	* -   `JSON.stringify()` implicitly calls this method when stringifying an `ndarray` instance.
	* -   The method does **not** serialize data outside of the buffer region defined by the array configuration.
	*
	*
	* @private
	* @name toJSON
	* @memberof ndarray.prototype
	* @type {Function}
	* @returns {Object} serialized ndarray
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6, 7, 8 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 2;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var o = x.toJSON();
	* // e.g., returns { 'type': 'ndarray', 'dtype': '<dtype>', 'flags': {...}, 'offset': 0, 'order': 'row-major', 'shape': [ 3, 2 ], 'strides': [ 2, 1 ], 'data': [ 3, 4, 5, 6, 7, 8 ] }
	*/

/**
	* Serializes an ndarray as a string.
	*
	* ## Notes
	*
	* -   The method does **not** serialize data outside of the buffer region defined by the array configuration.
	*
	*
	* @private
	* @name toString
	* @memberof ndarray.prototype
	* @type {Function}
	* @returns {string} serialized ndarray
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6, 7, 8 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 2;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var str = x.toString();
	* // e.g., returns 'ndarray( [ 3, 4, 5, 6, 7, 8 ], [ 3, 2 ], [ 2, 1 ], 0, "row-major" )'
	*/

/**
	* Serializes the pseudorandom number generator as a JSON object.
	*
	* ## Notes
	*
	* -   `JSON.stringify()` implicitly calls this method when stringifying a PRNG.
	*
	* @private
	* @returns {Object} JSON representation
	*/

/**
	* Sets an array element located at a specified linear index.
	*
	* @private
	* @name iset
	* @memberof ndarray.prototype
	* @type {Function}
	* @param {integer} idx - linear index
	* @param {*} v - value to set
	* @returns {ndarray} ndarray instance
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var v = x.iget( 3 );
	* // returns 4
	*
	* x.iset( 3, 10 );
	*
	* var b = x.data;
	* // returns [ 1, 2, 3, 10, 5, 6 ]
	*
	* v = x.iget( 3 );
	* // returns 10
	*/

/**
	* Sets an array element located at a specified linear index.
	*
	* @private
	* @param {integer} idx - linear view index
	* @param {*} v - value to set
	* @throws {TypeError} index must be an integer value
	* @throws {RangeError} index exceeds array dimensions
	* @returns {ndarray} ndarray instance
	*/

/**
	* Sets an array element.
	*
	* @private
	* @name set
	* @memberof ndarray.prototype
	* @type {Function}
	* @param {...integer} idx - indices
	* @param {*} v - value to set
	* @returns {ndarray} ndarray instance
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var v = x.get( 1, 1 );
	* // returns 4
	*
	* x.set( 1, 1, 10 );
	*
	* var b = x.data;
	* // returns [ 1, 2, 3, 10, 5, 6 ]
	*
	* v = x.get( 1, 1 );
	* // returns 10
	*/

/**
	* Sets an array element.
	*
	* @private
	* @param {...integer} idx - indices
	* @param {*} v - value to set
	* @throws {TypeError} provided indices must be integer valued
	* @throws {RangeError} index exceeds array dimensions
	* @returns {ndarray} ndarray instance
	*/

/**
	* Sets an array element.
	*
	* @private
	* @param {integer} i - index
	* @param {*} v - value to set
	* @throws {TypeError} index must be an integer value
	* @throws {RangeError} index exceeds array dimensions
	* @returns {ndarray} ndarray instance
	*/

/**
	* Sets an array element.
	*
	* @private
	* @param {integer} i - index for first dimension
	* @param {integer} j - index for second dimension
	* @param {*} v - value to set
	* @throws {TypeError} index for first dimension must be an integer value
	* @throws {TypeError} index for second dimension must be an integer value
	* @throws {RangeError} index exceeds array dimensions
	* @returns {ndarray} ndarray instance
	*/

/**
	* Sets an array element.
	*
	* @private
	* @param {integer} i - index for first dimension
	* @param {integer} j - index for second dimension
	* @param {integer} k - index for third dimension
	* @param {*} v - value to set
	* @throws {TypeError} index for first dimension must be an integer value
	* @throws {TypeError} index for second dimension must be an integer value
	* @throws {TypeError} index for third dimension must be an integer value
	* @throws {RangeError} index exceeds array dimensions
	* @returns {ndarray} ndarray instance
	*/

/**
	* Sets an array element.
	*
	* @private
	* @param {integer} i - index for first dimension
	* @param {integer} j - index for second dimension
	* @param {integer} k - index for third dimension
	* @param {integer} l - index for fourth dimension
	* @param {*} v - value to set
	* @throws {TypeError} index for first dimension must be an integer value
	* @throws {TypeError} index for second dimension must be an integer value
	* @throws {TypeError} index for third dimension must be an integer value
	* @throws {TypeError} index for fourth dimension must be an integer value
	* @throws {RangeError} index exceeds array dimensions
	* @returns {ndarray} ndarray instance
	*/

/**
	* Sets the PRNG state.
	*
	* ## Notes
	*
	* -   If PRNG state is "shared" (meaning a state array was provided during PRNG creation and **not** copied) and one sets the generator state to a state array having a different length, the PRNG does **not** update the existing shared state and, instead, points to the newly provided state array. In order to synchronize PRNG output according to the new shared state array, the state array for **each** relevant PRNG must be **explicitly** set.
	* -   If PRNG state is "shared" and one sets the generator state to a state array of the same length, the PRNG state is updated (along with the state of all other PRNGs sharing the PRNG's state array).
	*
	* @private
	* @param {PRNGStateMINSTD} s - generator state
	* @throws {TypeError} must provide an `Int32Array`
	* @throws {Error} must provide a valid state
	*/

/**
	* Sets the PRNG state.
	*
	* ## Notes
	*
	* -   If PRNG state is "shared" (meaning a state array was provided during PRNG creation and **not** copied) and one sets the generator state to a state array having a different length, the PRNG does **not** update the existing shared state and, instead, points to the newly provided state array. In order to synchronize PRNG output according to the new shared state array, the state array for **each** relevant PRNG must be **explicitly** set.
	* -   If PRNG state is "shared" and one sets the generator state to a state array of the same length, the PRNG state is updated (along with the state of all other PRNGs sharing the PRNG's state array).
	*
	* @private
	* @param {PRNGStateMT19937} s - generator state
	* @throws {TypeError} must provide a `Uint32Array`
	* @throws {Error} must provide a valid state
	*/

/**
	* Sets the pseudorandom number generator state.
	*
	* @private
	* @param {PRNGStateMT19937} s - generator state
	* @throws {Error} must provide a valid state
	*/

/**
	* Shape of the array.
	*
	* @private
	* @name shape
	* @memberof ndarray.prototype
	* @type {NonNegativeIntegerArray}
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var s = x.shape;
	* // returns [ 3, 2 ]
	*/

/**
	* Size (in bytes) of each array element (if known).
	*
	* @private
	* @name BYTES_PER_ELEMENT
	* @memberof ndarray
	* @type {(PositiveInteger|null)}
	*
	* @example
	* var nbytes = ndarray.BYTES_PER_ELEMENT;
	* // returns <number>
	*/

/**
	* Size (in bytes) of each array element (if known).
	*
	* @private
	* @name BYTES_PER_ELEMENT
	* @memberof ndarray.prototype
	* @type {(PositiveInteger|null)}
	*
	* @example
	* var Float64Array = require( '@stdlib/array/float64' );
	*
	* var buffer = new Float64Array( [ 1, 2, 3, 4, 5, 6 ] );
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var nbytes = x.BYTES_PER_ELEMENT;
	* // returns 8
	*/

/**
	* Size (in bytes) of the array (if known).
	*
	* @private
	* @name byteLength
	* @memberof ndarray.prototype
	* @type {(NonNegativeInteger|null)}
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var byteLength = x.byteLength;
	* // returns <number>
	*/

/**
	* Tests if every element in an array passes a test condition.
	*
	* @private
	* @param {*} value - value to test
	* @returns {boolean} boolean indicating whether a value is an array for which all elements pass a test condition
	*/

/**
	* Tests if every element in an array-like object passes a test condition.
	*
	* @private
	* @param {*} value - value to test
	* @returns {boolean} boolean indicating whether a value is an array-like object for which all elements pass a test condition
	*/

/**
	* The currently active debug mode names, and names to skip.
	*/

/**
	* Underlying data type.
	*
	* @private
	* @name dtype
	* @memberof ndarray
	* @type {string}
	*
	* @example
	* var dtype = ndarray.dtype;
	* // returns <string>
	*/

/**
	* Underlying data type.
	*
	* @private
	* @name dtype
	* @memberof ndarray.prototype
	* @type {string}
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var dtype = x.dtype;
	* // returns <string>
	*/

/**
	* Updates cluster statistics.
	*
	* @private
	* @param {NonNegativeInteger} c - cluster index to which a data point belongs
	* @param {number} dist - a data point's squared distance to its respective centroid
	* @returns {ndarray} matrix containing cluster statistics
	*/

/**
	* ndarray constructor.
	*
	* @private
	* @constructor
	* @param {(ArrayLikeObject|TypedArray|Buffer)} buffer - data buffer
	* @param {NonNegativeIntegerArray} shape - array shape
	* @param {IntegerArray} strides - array strides
	* @param {NonNegativeInteger} offset - index offset
	* @param {string} order - specifies whether an array is row-major (C-style) or column-major (Fortran-style)
	* @returns {ndarray} ndarray instance
	*/

/**
	* ndarray constructor.
	*
	* @private
	* @constructor
	* @param {(ArrayLikeObject|TypedArray|Buffer)} buffer - data buffer
	* @param {NonNegativeIntegerArray} shape - array shape
	* @param {IntegerArray} strides - array strides
	* @param {NonNegativeInteger} offset - index offset
	* @param {string} order - specifies whether an array is row-major (C-style) or column-major (Fortran-style)
	* @throws {TypeError} `buffer` argument must be an array-like object, typed-array-like, or a Buffer
	* @throws {TypeError} `shape` argument must be an array-like object containing nonnegative integers
	* @throws {Error} `shape` argument length must equal the number of dimensions
	* @throws {TypeError} `strides` argument must be an array-like object containing integers
	* @throws {Error} `strides` argument length must equal the number of dimensions
	* @throws {TypeError} `offset` argument must be a nonnegative integer
	* @throws {TypeError} `order` argument must be a supported ndarray order
	* @throws {Error} `buffer` argument must be compatible with specified meta data
	* @returns {ndarray} ndarray instance
	*/

/**
    * Adds a new document to the corpus and updates the k-means model.
    *
    * @param {string} doc - input document
    */

/**
    * Adds new documents to the corpus and repeatedly updates the k-means model.
    *
    * @param {Array} docs - input documents
    */

/**
    * Iterate over the current documents and update the cluster centroids.
    *
    * @param {integer} iter - number of times
    */

/**
    * Processes a document and returns a bag-of-words representation.
    *
    * @param {string} doc - input document
    * @returns {Array} sparse word vector
    */

/**
    * Returns the current class labels for the documents of the corpus.
    *
    * @param {integer} modelIndex - index of model to obtain predictions from
    * @returns {ndarray} one-dimensional vector of class labels
    */

/**
    * Returns the most representative documents for each cluster, i.e. the documents with the lowest distance to the cluster centroids.
    *
    * @param {Object} options - options object
    * @param {integer} options.cluster - index of cluster for which to obtain representative documents
    * @param {integer} options.modelIndex - index of model
    * @param {integer} [options.limit=5] - number of documents to include in returned value
    * @returns {Array} most representative documents
    */

/**
   * Calculates the inverse PCA transform
   * @param {Matrix} dataset
   * @return {Matrix} dataset projected in the PCA space
   */

/**
   * Export the current model to a JSON object
   * @return {Object} model
   */

/**
   * Load a PCA model from JSON
   * @param {Object} model
   * @return {PCA}
   */

/**
   * Project the dataset into the PCA space
   * @param {Matrix} dataset
   * @param {Object} options
   * @return {Matrix} dataset projected in the PCA space
   */

/**
   * Returns the Eigenvalues (on the diagonal)
   * @returns {[number]}
   */

/**
   * Returns the Eigenvectors of the covariance matrix
   * @returns {Matrix}
   */

/**
   * Returns the cumulative proportion of variance
   * @return {[number]}
   */

/**
   * Returns the loadings matrix
   * @return {Matrix}
   */

/**
   * Returns the proportion of variance for each component
   * @return {[number]}
   */

/**
   * Returns the standard deviations of the principal components
   * @returns {[number]}
   */

/**
  * Calculates, stores, and returns the index for a supplied word.
  *
  * @param {string} word
  * @returns {integer} word index
  */

/**
  * Class constructor.
  *
  * @param {Vocabulary} vocabulary - vocabulary used to turn documents into word vectors
  * @param {Array} clusters - array with elements corresponding to the number of clusters for the k-means models to fit
  */

/**
  * Class constructor.
  *
  * @param {integer} dim - word vector length
  */

/**
  * Performs dimensionality reduction and returns xy-coordinates for the model centroids.
  *
  * @param {integer} modelIndex - index of model
  * @returns {Matrix} rows correspond to xy-coordinates for each cluster
  */

/**
 *
 * @param {Array} input
 * @param {object} [options={}]
 * @param {Array} [options.output=[]] specify the output array, can be the input array for in place modification
 */

/**
 * @private
 * Check that a column index is not out of bounds
 * @param {Matrix} matrix
 * @param {number} index
 * @param {boolean} [outer]
 */

/**
 * @private
 * Check that a row index is not out of bounds
 * @param {Matrix} matrix
 * @param {number} index
 * @param {boolean} [outer]
 */

/**
 * @private
 * Check that the provided vector is an array with the right length
 * @param {Matrix} matrix
 * @param {Array|Matrix} vector
 * @return {Array}
 * @throws {RangeError}
 */

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

/**
 * Colors.
 */

/**
 * Computes the maximum of the given values
 * @param {Array<number>} input
 * @return {number}
 */

/**
 * Computes the minimum of the given values
 * @param {Array<number>} input
 * @return {number}
 */

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/

/**
 * Creates new PCA (Principal Component Analysis) from the dataset
 * @param {Matrix} dataset - dataset or covariance matrix.
 * @param {Object} [options]
 * @param {boolean} [options.isCovarianceMatrix=false] - true if the dataset is a covariance matrix.
 * @param {string} [options.method='SVD'] - select which method to use: SVD (default), covarianceMatrirx or NIPALS.
 * @param {number} [options.nCompNIPALS=2] - number of components to be computed with NIPALS.
 * @param {boolean} [options.center=true] - should the data be centered (subtract the mean).
 * @param {boolean} [options.scale=false] - should the data be scaled (divide by the standard deviation).
 * @param {boolean} [options.ignoreZeroVariance=false] - ignore columns with zero variance if `scale` is `true`.
 * */

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */

/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/

/**
 * Helpers.
 */

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

/**
 * Pluralization helper.
 */

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

/**
 * This is the web browser implementation of `debug()`.
 */

/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*
* ## Notice
*
* The following copyright and license were part of the original implementation available as part of [FreeBSD]{@link https://svnweb.freebsd.org/base/release/9.3.0/lib/msun/src/e_log.c}. The implementation follows the original, but has been modified for JavaScript.
*
* ```text
* Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
*
* Developed at SunPro, a Sun Microsystems, Inc. business.
* Permission to use, copy, modify, and distribute this
* software is freely granted, provided that this notice
* is preserved.
* ```
*/

/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*
* ## Notice
*
* The original C code and copyright notice are from the [source implementation]{@link http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/CODES/mt19937ar.c}. The implementation has been modified for JavaScript.
*
* ```text
* Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
*
*   1. Redistributions of source code must retain the above copyright
*      notice, this list of conditions and the following disclaimer.
*
*   2. Redistributions in binary form must reproduce the above copyright
*      notice, this list of conditions and the following disclaimer in the
*      documentation and/or other materials provided with the distribution.
*
*   3. The names of its contributors may not be used to endorse or promote
*      products derived from this software without specific prior written
*      permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
* A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
* PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* ```
*/

/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*
* ## Notice
*
* The original C++ code and copyright notice are from the [Boost library]{http://www.boost.org/doc/libs/1_65_1/doc/html/boost/random/uniform_int_distribution.html}. The implementation has been modified for JavaScript.
*
* ```text
* (C) Copyright John Maddock 2006.
* (C) Copyright Steven Watanabe 2011.
*
* Use, modification and distribution are subject to the
* Boost Software License, Version 1.0. (See accompanying file
* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)
* ```
*/

/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/**
* A 32-bit Mersenne Twister pseudorandom number generator.
*
* @module @stdlib/random/base/mt19937
*
* @example
* var mt19937 = require( '@stdlib/random/base/mt19937' );
*
* var v = mt19937();
* // returns <number>
*
* @example
* var factory = require( '@stdlib/random/base/mt19937' ).factory;
*
* var mt19937 = factory({
*     'seed': 1234
* });
*
* var v = mt19937();
* // returns 822569775
*/

/**
* A linear congruential pseudorandom number generator (LCG) whose output is shuffled.
*
* @module @stdlib/random/base/minstd-shuffle
*
* @example
* var minstd = require( '@stdlib/random/base/minstd-shuffle' );
*
* var v = minstd();
* // returns <number>
*
* @example
* var factory = require( '@stdlib/random/base/minstd-shuffle' ).factory;
*
* var minstd = factory({
*     'seed': 1234
* });
*
* var v = minstd();
* // returns 1421600654
*/

/**
* A vocabulary class for turning strings into word vectors.
*
* -   The implementation uses the "hashing trick" to avoid keeping a dictionary of all encountered words in memory (at the risk of hash collisions). It further allows us to calculate word vectors without access of the entire vocabulary. This is especially useful in an online learning setting where new documents keep trickling in, which may contain words not previously encountered.
* -   Words are directly mapped to indices by applying a hash function (MURMURHASH3) and then restricting the resulting hash value to the range [0, dimension-1] using the modulo function, which represents the index for the given word.
*/

/**
* Allocate a buffer having a specified number of bytes.
*
* @module @stdlib/buffer/alloc-unsafe
*
* @example
* var allocUnsafe = require( '@stdlib/buffer/alloc-unsafe' );
*
* var buf = allocUnsafe( 10 );
* // returns <Buffer>
*/

/**
* Allocates a buffer having a specified number of bytes.
*
* ## Notes
*
* -   The underlying memory of returned `Buffer` instances is not initialized. Memory contents are unknown and may contain sensitive data.
* -   When the size is less than half the pool size (specified on the `Buffer` constructor), memory is allocated from the `Buffer` pool for faster allocation of new `Buffer` instances.
*
*
* @param {NonNegativeInteger} size - number of bytes to allocate
* @throws {TypeError} must provide a nonnegative integer
* @returns {Buffer} new `Buffer` instance
*
* @example
* var buf = allocUnsafe( 10 );
* // returns <Buffer>
*/

/**
* An `Object.create` shim for older JavaScript engines.
*
* @private
* @param {Object} proto - prototype
* @returns {Object} created object
*
* @example
* var obj = createObject( Object.prototype );
* // returns {}
*/

/**
* Applies a function for calculating the squared distance between each data point and a specified centroid.
*
* @private
* @param {Array} out - output array
* @param {Function} dist - distance function to apply
* @param {PositiveInteger} npts - number of data points
* @param {PositiveInteger} ndims - number of dimensions
* @param {ndarray} matrix - data point matrix
* @param {NonNegativeInteger} ci - centroid row index
* @returns {Array} output array
*/

/**
* Attempts to call a `RegExp` method.
*
* @private
* @param {*} value - value to test
* @returns {boolean} boolean indicating if able to call a `RegExp` method
*/

/**
* Attempts to extract a string value.
*
* @private
* @param {*} value - value to test
* @returns {boolean} boolean indicating if a string can be extracted
*/

/**
* Attempts to serialize a value to a string.
*
* @private
* @param {*} value - value to test
* @returns {boolean} boolean indicating if a value can be serialized
*/

/**
* Bias of a double-precision floating-point number's exponent.
*
* ## Notes
*
* The bias can be computed via
*
* ```tex
* \mathrm{bias} = 2^{k-1} - 1
* ```
*
* where \\(k\\) is the number of bits in the exponent; here, \\(k = 11\\).
*
* @constant
* @type {integer32}
* @default 1023
* @see [IEEE 754]{@link https://en.wikipedia.org/wiki/IEEE_754-1985}
*/

/**
* Blas level 1 routine to copy values from `x` into `y`.
*
* @module @stdlib/blas/base/gcopy
*
* @example
* var gcopy = require( '@stdlib/blas/base/gcopy' );
*
* var x = [ 1.0, 2.0, 3.0, 4.0, 5.0 ];
* var y = [ 6.0, 7.0, 8.0, 9.0, 10.0 ];
*
* gcopy( x.length, x, 1, y, 1 );
* // y => [ 1.0, 2.0, 3.0, 4.0, 5.0 ]
*
* @example
* // Use the `ndarray` interface...
* var gcopy = require( '@stdlib/blas/base/gcopy' ).ndarray;
*
* var x = [ 1.0, 2.0, 3.0, 4.0, 5.0 ];
* var y = [ 6.0, 7.0, 8.0, 9.0, 10.0 ];
*
* gcopy( x.length, x, 1, 0, y, 1, 0 );
* // y => [ 1.0, 2.0, 3.0, 4.0, 5.0 ]
*/

/**
* Buffer constructor.
*
* @module @stdlib/buffer/ctor
*
* @example
* var ctor = require( '@stdlib/buffer/ctor' );
*
* var b = new ctor( [ 1, 2, 3, 4 ] );
* // returns <Buffer>
*/

/**
* Buffer constructor.
*
* @throws {Error} not implemented
*/

/**
* Calculates the Euclidean norm of an array.
*
* @param {(Array|TypedArray)} arr - input array
* @returns {number|null} L2 norm or null
*/

/**
* Capitalize the first character in a string.
*
* @module @stdlib/string/capitalize
*
* @example
* var capitalize = require( '@stdlib/string/capitalize' );
*
* var out = capitalize( 'last man standing' );
* // returns 'Last man standing'
*
* out = capitalize( 'Hidden Treasures' );
* // returns 'Hidden Treasures';
*/

/**
* Capitalizes the first character in a string.
*
* @param {string} str - input string
* @throws {TypeError} must provide a string primitive
* @returns {string} capitalized string
*
* @example
* var out = capitalize( 'last man standing' );
* // returns 'Last man standing'
*
* @example
* var out = capitalize( 'presidential election' );
* // returns 'Presidential election'
*
* @example
* var out = capitalize( 'javaScript' );
* // returns 'JavaScript'
*
* @example
* var out = capitalize( 'Hidden Treasures' );
* // returns 'Hidden Treasures'
*/

/**
* Captures everything that is not a space immediately after the `function` keyword and before the first left parenthesis.
*
* Regular expression: `/^\s*function\s*([^(]*)/i`
*
* -   `/^\s*`
*     -   Match zero or more spaces at beginning
*
* -   `function`
*     -   Match the word `function`
*
* -   `\s*`
*     -   Match zero or more spaces after the word `function`
*
* -   `()`
*     -   Capture
*
* -   `[^(]*`
*     -   Match anything except a left parenthesis `(` zero or more times
*
* -   `/i`
*     -   ignore case
*
* @constant
* @type {RegExp}
* @default /^\s*function\s*([^(]*)/i
*/

/**
* Casts buffer elements by copying those elements to a buffer of another data type.
*
* @private
* @param {(Array|TypedArray|Buffer)} buffer - input buffer
* @param {NonNegativeInteger} len - number of elements to cast
* @param {string} dtype - data type
* @returns {(Array|TypedArray|Buffer)} output buffer
*
* @example
* var b = castBuffer( [ 1.0, 2.0, 3.0 ], 3, 'float64' );
* // returns <Float64Array>[ 1.0, 2.0, 3.0 ]
*/

/**
* Checks whether a polyfill is needed when using the `typeof` operator.
*
* @private
* @returns {boolean} boolean indicating whether a polyfill is needed
*/

/**
* Clones a class instance.
*
* ## Notes
*
* -   This should **only** be used for simple cases. Any instances with privileged access to variables (e.g., within closures) cannot be cloned. This approach should be considered **fragile**.
* -   The function is greedy, disregarding the notion of a `level`. Instead, the function deep copies all properties, as we assume the concept of `level` applies only to the class instance reference but not to its internal state. This prevents, in theory, two instances from sharing state.
*
*
* @private
* @param {Object} val - class instance
* @returns {Object} new instance
*/

/**
* Compute an absolute value.
*
* @module @stdlib/math/base/special/abs
*
* @example
* var abs = require( '@stdlib/math/base/special/abs' );
*
* var v = abs( -1.0 );
* // returns 1.0
*
* v = abs( 2.0 );
* // returns 2.0
*
* v = abs( 0.0 );
* // returns 0.0
*
* v = abs( -0.0 );
* // returns 0.0
*
* v = abs( NaN );
* // returns NaN
*/

/**
* Compute an arithmetic mean and corrected sample standard deviation incrementally.
*
* @module @stdlib/stats/incr/meanstdev
*
* @example
* var incrmeanstdev = require( '@stdlib/stats/incr/meanstdev' );
*
* var accumulator = incrmeanstdev();
*
* var ms = accumulator();
* // returns null
*
* ms = accumulator( 2.0 );
* // returns [ 2.0, 0.0 ]
*
* ms = accumulator( -5.0 );
* // returns [ -1.5, ~4.95 ]
*
* ms = accumulator( 3.0 );
* // returns [ 0.0, ~4.36 ]
*
* ms = accumulator( 5.0 );
* // returns [ 1.25, ~4.35 ]
*
* ms = accumulator();
* // returns [ 1.25, ~4.35 ]
*/

/**
* Compute an arithmetic mean incrementally.
*
* @module @stdlib/stats/incr/mean
*
* @example
* var incrmean = require( '@stdlib/stats/incr/mean' );
*
* var accumulator = incrmean();
*
* var mu = accumulator();
* // returns null
*
* mu = accumulator( 2.0 );
* // returns 2.0
*
* mu = accumulator( -5.0 );
* // returns -1.5
*
* mu = accumulator();
* // returns -1.5
*/

/**
* Compute the absolute difference.
*
* @module @stdlib/math/base/utils/absolute-difference
*
* @example
* var diff = require( '@stdlib/math/base/utils/absolute-difference' );
*
* var d = diff( 2.0, 5.0 );
* // returns 3.0
*
* d = diff( -1.0, 3.14 );
* // returns ~4.14
*
* d = diff( 10.1, -2.05 );
* // returns ~12.15
*
* d = diff( -0.0, 0.0 );
* // returns +0.0
*
* d = diff( NaN, 5.0 );
* // returns NaN
*
* d = diff( Infinity, -Infinity  );
* // returns Infinity
*
* d = diff( Infinity, Infinity  );
* // returns NaN
*/

/**
* Compute the minimum and maximum linear indices in an underlying data buffer which are accessible to an array view.
*
* @module @stdlib/ndarray/base/minmax-view-buffer-index
*
* @example
* var minmaxViewBufferIndex = require( '@stdlib/ndarray/base/minmax-view-buffer-index' );
*
* var shape = [ 10, 10 ];
* var strides = [ 10, 1 ];
* var offset = 10;
*
* var idx = minmaxViewBufferIndex( shape, strides, offset );
* // returns [ 10, 109 ]
*
* @example
* var minmaxViewBufferIndex = require( '@stdlib/ndarray/base/minmax-view-buffer-index' );
*
* var shape = [ 10, 10 ];
* var strides = [ -10, -1 ];
* var offset = 99;
*
* var idx = minmaxViewBufferIndex( shape, strides, offset );
* // returns [ 0, 99 ]
*
* @example
* var minmaxViewBufferIndex = require( '@stdlib/ndarray/base/minmax-view-buffer-index' );
*
* var shape = [ 10, 10 ];
* var strides = [ 1, 10 ];
* var offset = 10;
*
* var idx = minmaxViewBufferIndex( shape, strides, offset );
* // returns [ 10, 109 ]
*
* @example
* var minmaxViewBufferIndex = require( '@stdlib/ndarray/base/minmax-view-buffer-index' );
*
* var shape = [ 10, 10 ];
* var strides = [ -1, -10 ];
* var offset = 99;
*
* var idx = minmaxViewBufferIndex( shape, strides, offset );
* // returns [ 0, 99 ]
*/

/**
* Compute the principal square root.
*
* @module @stdlib/math/base/special/sqrt
*
* @example
* var sqrt = require( '@stdlib/math/base/special/sqrt' );
*
* var v = sqrt( 4.0 );
* // returns 2.0
*
* v = sqrt( 9.0 );
* // returns 3.0
*
* v = sqrt( 0.0 );
* // returns 0.0
*
* v = sqrt( -4.0 );
* // returns NaN
*
* v = sqrt( NaN );
* // returns NaN
*/

/**
* Computes the Euclidean distance between two vectors.
*
* @private
* @param {NonNegativeInteger} N - number of elements
* @param {NumericArray} X - strided array
* @param {PositiveInteger} strideX - stride
* @param {NonNegativeInteger} offsetX - index offset
* @param {NumericArray} Y - strided array
* @param {PositiveInteger} strideY - stride
* @param {NonNegativeInteger} offsetY - index offset
* @returns {number} Euclidean distance
*/

/**
* Computes the absolute difference.
*
* @param {number} x - first number
* @param {number} y - second number
* @returns {number} absolute difference
*
* @example
* var d = absoluteDifference( 2.0, 5.0 );
* // returns 3.0
*
* @example
* var d = absoluteDifference( -1.0, 3.14 );
* // returns ~4.14
*
* @example
* var d = absoluteDifference( 10.1, -2.05 );
* // returns ~12.15
*
* @example
* var d = absoluteDifference( -0.0, 0.0 );
* // returns +0.0
*
* @example
* var d = absoluteDifference( NaN, 5.0 );
* // returns NaN
*
* @example
* var d = absoluteDifference( Infinity, -Infinity  );
* // returns Infinity
*
* @example
* var d = absoluteDifference( Infinity, Infinity  );
* // returns NaN
*/

/**
* Computes the absolute value of `x`.
*
* @param {number} x - input value
* @returns {number} absolute value
*
* @example
* var v = abs( -1.0 );
* // returns 1.0
*
* @example
* var v = abs( 2.0 );
* // returns 2.0
*
* @example
* var v = abs( 0.0 );
* // returns 0.0
*
* @example
* var v = abs( -0.0 );
* // returns 0.0
*
* @example
* var v = abs( NaN );
* // returns NaN
*/

/**
* Computes the cosine similarity between two arrays.
*
* @param {(Array|TypedArray)} x - input array
* @param {(Array|TypedArray)} y - input array
* @returns {number|null} cosine similarity or null
*/

/**
* Computes the dot product between two arrays.
*
* @param {(Array|TypedArray)} x - input array
* @param {(Array|TypedArray)} y - input array
* @returns {number|null} dot product
*/

/**
* Computes the dot product of two vectors.
*
* @private
* @param {NonNegativeInteger} N - number of elements
* @param {NumericArray} X - strided array
* @param {PositiveInteger} strideX - stride
* @param {NonNegativeInteger} offsetX - index offset
* @param {NumericArray} Y - strided array
* @param {PositiveInteger} strideY - stride
* @param {NonNegativeInteger} offsetY - index offset
* @returns {number} dot product
*/

/**
* Computes the minimum and maximum linear indices in an underlying data buffer which are accessible to an array view.
*
* @param {(Array|TypedArray|Object)} [out] - output object
* @param {NonNegativeIntegerArray} shape - array shape
* @param {IntegerArray} strides - stride array
* @param {NonNegativeInteger} offset - index offset
* @returns {(Array|TypedArray|Object)} linear indices
*
* @example
* var shape = [ 10, 10 ];
* var strides = [ 10, 1 ];
* var offset = 10;
*
* var idx = minmaxViewBufferIndex( shape, strides, offset );
* // returns [ 10, 109 ]
*
* @example
* var shape = [ 10, 10 ];
* var strides = [ -10, -1 ];
* var offset = 99;
*
* var idx = minmaxViewBufferIndex( shape, strides, offset );
* // returns [ 0, 99 ]
*
* @example
* var shape = [ 10, 10 ];
* var strides = [ 1, 10 ];
* var offset = 10;
*
* var idx = minmaxViewBufferIndex( shape, strides, offset );
* // returns [ 10, 109 ]
*
* @example
* var shape = [ 10, 10 ];
* var strides = [ -1, -10 ];
* var offset = 99;
*
* var idx = minmaxViewBufferIndex( shape, strides, offset );
* // returns [ 0, 99 ]
*
* @example
* var shape = [ 10, 10 ];
* var strides = [ -1, -10 ];
* var offset = 99;
*
* var out = new Array( 2 );
* var idx = minmaxViewBufferIndex( out, shape, strides, offset );
* // returns [ 0, 99 ]
*
* var bool = ( idx === out );
* // returns true
*/

/**
* Computes the minimum and maximum linear indices in an underlying data buffer which are accessible to an array view.
*
* @private
* @param {(Array|TypedArray|Object)} out - output object
* @param {NonNegativeIntegerArray} shape - array shape
* @param {IntegerArray} strides - stride array
* @param {NonNegativeInteger} offset - index offset
* @returns {(Array|TypedArray|Object)} linear indices
*
* @example
* var shape = [ 10, 10 ];
* var strides = [ 10, 1 ];
* var offset = 10;
*
* var out = new Array( 2 );
* var idx = minmaxViewBufferIndex( out, shape, strides, offset );
* // returns [ 10, 109 ]
*
* var bool = ( idx === out );
* // returns true
*
* @example
* var shape = [ 10, 10 ];
* var strides = [ -10, -1 ];
* var offset = 99;
*
* var out = new Array( 2 );
* var idx = minmaxViewBufferIndex( out, shape, strides, offset );
* // returns [ 0, 99 ]
*
* var bool = ( idx === out );
* // returns true
*
* @example
* var shape = [ 10, 10 ];
* var strides = [ 1, 10 ];
* var offset = 10;
*
* var out = new Array( 2 );
* var idx = minmaxViewBufferIndex( out, shape, strides, offset );
* // returns [ 10, 109 ]
*
* var bool = ( idx === out );
* // returns true
*
* @example
* var shape = [ 10, 10 ];
* var strides = [ -1, -10 ];
* var offset = 99;
*
* var out = new Array( 2 );
* var idx = minmaxViewBufferIndex( out, shape, strides, offset );
* // returns [ 0, 99 ]
*
* var bool = ( idx === out );
* // returns true
*/

/**
* Computes the principal square root.
*
* @type {Function}
* @param {number} x - input value
* @returns {number} principal square root
*
* @example
* var v = sqrt( 4.0 );
* // returns 2.0
*
* v = sqrt( 9.0 );
* // returns 3.0
*
* v = sqrt( 0.0 );
* // returns 0.0
*
* v = sqrt( -4.0 );
* // returns NaN
*
* v = sqrt( NaN );
* // returns NaN
*/

/**
* Computes the squared Euclidean distance between two data points.
*
* @private
* @param {NonNegativeInteger} N - number of elements
* @param {NumericArray} X - strided array
* @param {PositiveInteger} strideX - stride
* @param {NonNegativeInteger} offsetX - index offset
* @param {NumericArray} Y - strided array
* @param {PositiveInteger} strideY - stride
* @param {NonNegativeInteger} offsetY - index offset
* @returns {number} squared Euclidean distance
*/

/**
* Computes the squared correlation distance between two data points.
*
* @private
* @param {NonNegativeInteger} N - number of elements
* @param {NumericArray} X - strided array
* @param {PositiveInteger} strideX - stride
* @param {NonNegativeInteger} offsetX - index offset
* @param {NumericArray} Y - strided array
* @param {PositiveInteger} strideY - stride
* @param {NonNegativeInteger} offsetY - index offset
* @returns {number} squared correlation distance
*/

/**
* Computes the squared cosine distance between two data points.
*
* @private
* @param {NonNegativeInteger} N - number of elements
* @param {NumericArray} X - strided array
* @param {PositiveInteger} strideX - stride
* @param {NonNegativeInteger} offsetX - index offset
* @param {NumericArray} Y - strided array
* @param {PositiveInteger} strideY - stride
* @param {NonNegativeInteger} offsetY - index offset
* @returns {number} squared cosine distance
*/

/**
* Constructor which returns a `Number` object.
*
* @module @stdlib/number/ctor
*
* @example
* var Number = require( '@stdlib/number/ctor' );
*
* var v = new Number( 10.0 );
* // returns <Number>
*/

/**
* Convert a string to lowercase.
*
* @module @stdlib/string/lowercase
*
* @example
* var lowercase = require( '@stdlib/string/lowercase' );
*
* var str = lowercase( 'bEEp' );
* // returns 'beep'
*/

/**
* Convert a string to uppercase.
*
* @module @stdlib/string/uppercase
*
* @example
* var uppercase = require( '@stdlib/string/uppercase' );
*
* var str = uppercase( 'bEEp' );
* // returns 'BEEP'
*/

/**
* Convert an ndarray buffer to a generic array (which may include nested arrays).
*
* @module @stdlib/ndarray/base/to-array
*
* @example
* var ndarray2array = require( '@stdlib/ndarray/base/to-array' );
*
* var buffer = [ 1, 2, 3, 4 ];
* var shape = [ 2, 2 ];
* var order = 'row-major';
* var strides = [ 2, 1 ];
* var offset = 0;
*
* var out = ndarray2array( buffer, shape, strides, offset, order );
* // returns [ [ 1, 2 ], [ 3, 4 ] ]
*/

/**
* Converts a string to lowercase.
*
* @param {string} str - string to convert
* @throws {TypeError} must provide a primitive string
* @returns {string} lowercase string
*
* @example
* var str = lowercase( 'bEEp' );
* // returns 'beep'
*/

/**
* Converts a string to uppercase.
*
* @param {string} str - string to convert
* @throws {TypeError} must provide a primitive string
* @returns {string} uppercase string
*
* @example
* var str = uppercase( 'bEEp' );
* // returns 'BEEP'
*/

/**
* Converts an ndarray buffer to a generic array (which may include nested arrays).
*
* @param {(ArrayLikeObject|TypedArray|Buffer)} buffer - data buffer
* @param {NonNegativeIntegerArray} shape - array shape
* @param {IntegerArray} strides - array strides
* @param {NonNegativeInteger} offset - index offset
* @param {string} order - specifies whether an array is row-major (C-style) or column-major (Fortran-style)
* @returns {(EmptyArray|Array|Array<Array>)} array (which may include nested arrays)
*
* @example
* var buffer = [ 1, 2, 3, 4 ];
* var shape = [ 2, 2 ];
* var order = 'row-major';
* var strides = [ 2, 1 ];
* var offset = 0;
*
* var out = ndarray2array( buffer, shape, strides, offset, order );
* // returns [ [ 1, 2 ], [ 3, 4 ] ]
*/

/**
* Copies a `Float32Array`.
*
* @private
* @param {Float32Array} arr - array to copy
* @returns {Float32Array} new array
*/

/**
* Copies a `Float64Array`.
*
* @private
* @param {Float64Array} arr - array to copy
* @returns {Float64Array} new array
*/

/**
* Copies a `Uint16Array`.
*
* @private
* @param {Uint16Array} arr - array to copy
* @returns {Uint16Array} new array
*/

/**
* Copies a `Uint32Array`.
*
* @private
* @param {Uint32Array} arr - array to copy
* @returns {Uint32Array} new array
*/

/**
* Copies a `Uint8Array`.
*
* @private
* @param {Uint8Array} arr - array to copy
* @returns {Uint8Array} new array
*/

/**
* Copies a `Uint8ClampedArray`.
*
* @private
* @param {Uint8ClampedArray} arr - array to copy
* @returns {Uint8ClampedArray} new array
*/

/**
* Copies an `Int16Array`.
*
* @private
* @param {Int16Array} arr - array to copy
* @returns {Int16Array} new array
*/

/**
* Copies an `Int32Array`.
*
* @private
* @param {Int32Array} arr - array to copy
* @returns {Int32Array} new array
*/

/**
* Copies an `Int8Array`.
*
* @private
* @param {Int8Array} arr - array to copy
* @returns {Int8Array} new array
*/

/**
* Copies an error object.
*
* @private
* @param {(Error|TypeError|SyntaxError|URIError|ReferenceError|RangeError|EvalError)} error - error to copy
* @returns {(Error|TypeError|SyntaxError|URIError|ReferenceError|RangeError|EvalError)} error copy
*
* @example
* var err1 = new TypeError( 'beep' );
*
* var err2 = copyError( err1 );
* // returns <TypeError>
*/

/**
* Copies an ndarray view to a data buffer.
*
* @private
* @param {ndarray} arr - input ndarray
* @param {string} dtype - data type
* @returns {(Array|TypedArray|Buffer)} output data buffer
*
* @example
* var ndarray = require( '@stdlib/ndarray/ctor' );
*
* var vector = ndarray( 'generic', 1 );
*
* var buffer = [ 1.0, 2.0, 3.0 ];
* var shape = [ 3 ];
* var strides = [ -1 ];
* var vec = vector( buffer, shape, strides, 2, 'row-major' );
*
* var b = copyView( vec, 'float64' );
* // returns <Float64Array>[ 3.0, 2.0, 1.0 ]
*/

/**
* Copies buffer data to a new `Buffer` instance.
*
* @param {Buffer} buffer - buffer from which to copy
* @throws {TypeError} must provide a `Buffer` instance
* @returns {Buffer} new `Buffer` instance
*
* @example
* var fromArray = require( '@stdlib/buffer/from-array' );
*
* var b1 = fromArray( [ 1, 2, 3, 4 ] );
* // returns <Buffer>
*
* var b2 = fromBuffer( b1 );
* // returns <Buffer>
*/

/**
* Copies matrix elements to another matrix.
*
* ## Notes
*
* -   Why not just use `gcopy` directly? Because `gcopy` 1) assumes only a single stride per strided array and 2) as we cannot assume that a source matrix is single-segment contiguous, we fall back to copying source matrix "chunks" (rows) to a destination matrix. Assuming the source matrix is row-major, then the implementation should be reasonably performant.
*
* @private
* @param {ndarray} Y - destination matrix
* @param {ndarray} X - source matrix
* @returns {ndarray} destination matrix
*/

/**
* Copies ndarray flags.
*
* @private
* @param {Object} flags - flags
* @returns {Object} copy of input object
*/

/**
* Copies or deep clones a value to an arbitrary depth.
*
* @param {*} value - value to copy
* @param {NonNegativeInteger} [level=+infinity] - copy depth
* @throws {TypeError} `level` must be a nonnegative integer
* @returns {*} value copy
*
* @example
* var out = copy( 'beep' );
* // returns 'beep'
*
* @example
* var value = [
*     {
*         'a': 1,
*         'b': true,
*         'c': [ 1, 2, 3 ]
*     }
* ];
* var out = copy( value );
* // returns [ { 'a': 1, 'b': true, 'c': [ 1, 2, 3 ] } ]
*
* var bool = ( value[0].c === out[0].c );
* // returns false
*/

/**
* Copies the contents of array-like object to a new array.
*
*
* @private
* @param {ArrayLike} arr - input array
* @param {NonNegativeInteger} len - array length
* @returns {Array} output array
*
* @example
* var arr = [ 1.0, 2.0, 3.0 ];
*
* var out = copy( arr, arr.length );
* // returns [ 1.0, 2.0, 3.0 ]
*
* var bool = ( arr === out );
* // returns false
*/

/**
* Copies values from `x` into `y`.
*
* @param {PositiveInteger} N - number of values to copy
* @param {(Array|TypedArray)} x - input array
* @param {integer} strideX - `x` stride length
* @param {(Array|TypedArray)} y - destination array
* @param {integer} strideY - `y` stride length
* @returns {(Array|TypedArray)} `y`
*
* @example
* var x = [ 1.0, 2.0, 3.0, 4.0, 5.0 ];
* var y = [ 6.0, 7.0, 8.0, 9.0, 10.0 ];
*
* gcopy( x.length, x, 1, y, 1 );
* // y => [ 1.0, 2.0, 3.0, 4.0, 5.0 ]
*/

/**
* Copies values from `x` into `y`.
*
* @param {PositiveInteger} N - number of values to copy
* @param {(Array|TypedArray)} x - input array
* @param {integer} strideX - `x` stride length
* @param {NonNegativeInteger} offsetX - starting `x` index
* @param {(Array|TypedArray)} y - destination array
* @param {integer} strideY - `y` stride length
* @param {NonNegativeInteger} offsetY - starting `y` index
* @returns {(Array|TypedArray)} `y`
*
* @example
* var x = [ 1.0, 2.0, 3.0, 4.0, 5.0 ];
* var y = [ 6.0, 7.0, 8.0, 9.0, 10.0 ];
*
* gcopy( x.length, x, 1, 0, y, 1, 0 );
* // y => [ 1.0, 2.0, 3.0, 4.0, 5.0 ]
*/

/**
* Copies values from `x` into `y`.
*
* @param {PositiveInteger} N - number of values to copy
* @param {Float64Array} x - input array
* @param {integer} strideX - `x` stride length
* @param {Float64Array} y - destination array
* @param {integer} strideY - `y` stride length
* @returns {Float64Array} `y`
*
* @example
* var x = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0 ] );
* var y = new Float64Array( [ 6.0, 7.0, 8.0, 9.0, 10.0 ] );
*
* dcopy( x.length, x, 1, y, 1 );
* // y => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 5.0 ]
*/

/**
* Copies values from `x` into `y`.
*
* @param {PositiveInteger} N - number of values to copy
* @param {Float64Array} x - input array
* @param {integer} strideX - `x` stride length
* @param {NonNegativeInteger} offsetX - starting `x` index
* @param {Float64Array} y - destination array
* @param {integer} strideY - `y` stride length
* @param {NonNegativeInteger} offsetY - starting `y` index
* @returns {Float64Array} `y`
*
* @example
* var x = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0 ] );
* var y = new Float64Array( [ 6.0, 7.0, 8.0, 9.0, 10.0 ] );
*
* dcopy( x.length, x, 1, 0, y, 1, 0 );
* // y => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 5.0 ]
*/

/**
* Copies vector elements to another vector.
*
* @private
* @param {ndarray} out - destination vector
* @param {ndarray} src - source vector
* @returns {ndarray} destination vector
*/

/**
* Copy buffer data to a new `Buffer` instance.
*
* @module @stdlib/buffer/from-buffer
*
* @example
* var fromArray = require( '@stdlib/buffer/from-array' );
* var copyBuffer = require( '@stdlib/buffer/from-buffer' );
*
* var b1 = fromArray( [ 1, 2, 3, 4 ] );
* // returns <Buffer>
*
* var b2 = copyBuffer( b1 );
* // returns <Buffer>
*/

/**
* Copy or deep clone a value to an arbitrary depth.
*
* @module @stdlib/utils/copy
*
* @example
* var copy = require( '@stdlib/utils/copy' );
*
* var out = copy( 'beep' );
* // returns 'beep'
*
* @example
* var copy = require( '@stdlib/utils/copy' );
*
* var value = [
*     {
*         'a': 1,
*         'b': true,
*         'c': [ 1, 2, 3 ]
*     }
* ];
* var out = copy( value );
* // returns [ {'a': 1, 'b': true, 'c': [ 1, 2, 3 ] } ]
*
* var bool = ( value[0].c === out[0].c );
* // returns false
*/

/**
* Create a constant function.
*
* @module @stdlib/utils/constant-function
*
* @example
* var constantFunction = require( '@stdlib/utils/constant-function' );
*
* var fcn = constantFunction( 3.14 );
*
* var v = fcn();
* // returns 3.14
*
* v = fcn();
* // returns 3.14
*
* v = fcn();
* // returns 3.14
*/

/**
* Create a memoized ndarray constructor.
*
* @module @stdlib/ndarray/base/memoized-ctor
*
* @example
* var ctor = require( '@stdlib/ndarray/base/memoized-ctor' );
*
* var f1 = ctor( 'float64', 3 );
* // returns <Function>
*
* var f2 = ctor( 'float64', 3 );
* // returns <Function>
*
* var bool = ( f1 === f2 );
* // returns true
*
* var buffer = [ 1, 2, 3, 4, 5, 6 ];
* var shape = [ 3, 2 ];
* var strides = [ 2, 1 ];
* var offset = 0;
*
* var out = f1( buffer, shape, strides, offset, 'row-major' );
*/

/**
* Create a memoized ndarray constructor.
*
* @module @stdlib/ndarray/memoized-ctor
*
* @example
* var ctor = require( '@stdlib/ndarray/memoized-ctor' );
*
* var f1 = ctor( 'float64', 3 );
* // returns <Function>
*
* var f2 = ctor( 'float64', 3 );
* // returns <Function>
*
* var bool = ( f1 === f2 );
* // returns true
*
* var buffer = [ 1, 2, 3, 4, 5, 6 ];
* var shape = [ 3, 2 ];
* var strides = [ 2, 1 ];
* var offset = 0;
*
* var out = f1( buffer, shape, strides, offset, 'row-major' );
*/

/**
* Create a regular expression from a regular expression string.
*
* @module @stdlib/utils/regexp-from-string
*
* @example
* var reFromString = require( '@stdlib/utils/regexp-from-string' );
*
* var re = reFromString( '/beep/' );
* // returns /beep/
*/

/**
* Create a zero-filled contiguous linear ndarray data buffer.
*
* @module @stdlib/ndarray/base/buffer
*
* @example
* var buffer = require( '@stdlib/ndarray/base/buffer' );
*
* var buf = buffer( 'float64', 3 );
* // returns <Float64Array>[ 0.0, 0.0, 0.0 ]
*/

/**
* Create an ndarray constructor.
*
* @module @stdlib/ndarray/base/ctor
*
* @example
* var ctor = require( '@stdlib/ndarray/base/ctor' );
*
* var ndarray = ctor( 'float64', 3 );
* // returns <Function>
*
* var buffer = [ 1, 2, 3, 4, 5, 6 ];
* var shape = [ 3, 2 ];
* var strides = [ 2, 1 ];
* var offset = 0;
*
* var out = ndarray( buffer, shape, strides, offset, 'row-major' );
*/

/**
* Create an ndarray constructor.
*
* @module @stdlib/ndarray/ctor
*
* @example
* var ctor = require( '@stdlib/ndarray/ctor' );
*
* var ndarray = ctor( 'generic', 3 );
* // returns <Function>
*
* var buffer = [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ];
* var shape = [ 3, 2 ];
* var strides = [ 2, 1 ];
* var offset = 0;
*
* var out = ndarray( buffer, shape, strides, offset, 'row-major' );
*/

/**
* Creates a function which always returns the same value.
*
* @param {*} [value] - value to always return
* @returns {Function} constant function
*
* @example
* var fcn = wrap( 3.14 );
*
* var v = fcn();
* // returns 3.14
*
* v = fcn();
* // returns 3.14
*
* v = fcn();
* // returns 3.14
*/

/**
* Define (or modify) an object property.
*
* @module @stdlib/utils/define-property
*
* @example
* var defineProperty = require( '@stdlib/utils/define-property' );
*
* var obj = {};
* defineProperty( obj, 'foo', {
*     'value': 'bar',
*     'writable': false,
*     'configurable': false,
*     'enumerable': false
* });
* obj.foo = 'boop'; // => throws
*/

/**
* Define a non-enumerable read-only accessor.
*
* @module @stdlib/utils/define-nonenumerable-read-only-accessor
*
* @example
* var setNonEnumerableReadOnlyAccessor = require( '@stdlib/utils/define-nonenumerable-read-only-accessor' );
*
* function getter() {
*     return 'bar';
* }
*
* var obj = {};
*
* setNonEnumerableReadOnlyAccessor( obj, 'foo', getter );
*
* try {
*     obj.foo = 'boop';
* } catch ( err ) {
*     console.error( err.message );
* }
*/

/**
* Define a non-enumerable read-only property.
*
* @module @stdlib/utils/define-nonenumerable-read-only-property
*
* @example
* var setNonEnumerableReadOnly = require( '@stdlib/utils/define-nonenumerable-read-only-property' );
*
* var obj = {};
*
* setNonEnumerableReadOnly( obj, 'foo', 'bar' );
*
* try {
*     obj.foo = 'boop';
* } catch ( err ) {
*     console.error( err.message );
* }
*/

/**
* Define a non-enumerable read-write accessor.
*
* @module @stdlib/utils/define-nonenumerable-read-write-accessor
*
* @example
* var setNonEnumerableReadWriteAccessor = require( '@stdlib/utils/define-nonenumerable-read-write-accessor' );
*
* function getter() {
*     return name + ' foo';
* }
*
* function setter( v ) {
*     name = v;
* }
*
* var name = 'bar';
* var obj = {};
*
* setNonEnumerableReadWriteAccessor( obj, 'foo', getter, setter );
*
* var v = obj.foo;
* // returns 'bar foo'
*
* obj.foo = 'beep';
*
* v = obj.foo;
* // returns 'beep foo'
*/

/**
* Define a read-only property.
*
* @module @stdlib/utils/define-read-only-property
*
* @example
* var setReadOnly = require( '@stdlib/utils/define-read-only-property' );
*
* var obj = {};
*
* setReadOnly( obj, 'foo', 'bar' );
*
* try {
*     obj.foo = 'boop';
* } catch ( err ) {
*     console.error( err.message );
* }
*/

/**
* Defines (or modifies) an object property.
*
* ## Notes
*
* -   Property descriptors come in two flavors: **data descriptors** and **accessor descriptors**. A data descriptor is a property that has a value, which may or may not be writable. An accessor descriptor is a property described by a getter-setter function pair. A descriptor must be one of these two flavors and cannot be both.
*
* @name defineProperty
* @type {Function}
* @param {Object} obj - object on which to define the property
* @param {(string|symbol)} prop - property name
* @param {Object} descriptor - property descriptor
* @param {boolean} [descriptor.configurable=false] - boolean indicating if property descriptor can be changed and if the property can be deleted from the provided object
* @param {boolean} [descriptor.enumerable=false] - boolean indicating if the property shows up when enumerating object properties
* @param {boolean} [descriptor.writable=false] - boolean indicating if the value associated with the property can be changed with an assignment operator
* @param {*} [descriptor.value] - property value
* @param {(Function|void)} [descriptor.get=undefined] - function which serves as a getter for the property, or, if no getter, undefined. When the property is accessed, a getter function is called without arguments and with the `this` context set to the object through which the property is accessed (which may not be the object on which the property is defined due to inheritance). The return value will be used as the property value.
* @param {(Function|void)} [descriptor.set=undefined] - function which serves as a setter for the property, or, if no setter, undefined. When assigning a property value, a setter function is called with one argument (the value being assigned to the property) and with the `this` context set to the object through which the property is assigned.
* @throws {TypeError} first argument must be an object
* @throws {TypeError} third argument must be an object
* @throws {Error} property descriptor cannot have both a value and a setter and/or getter
* @returns {Object} object with added property
*
* @example
* var obj = {};
*
* defineProperty( obj, 'foo', {
*     'value': 'bar'
* });
*
* var str = obj.foo;
* // returns 'bar'
*/

/**
* Defines (or modifies) an object property.
*
* ## Notes
*
* -   Property descriptors come in two flavors: **data descriptors** and **accessor descriptors**. A data descriptor is a property that has a value, which may or may not be writable. An accessor descriptor is a property described by a getter-setter function pair. A descriptor must be one of these two flavors and cannot be both.
*
* @param {Object} obj - object on which to define the property
* @param {string} prop - property name
* @param {Object} descriptor - property descriptor
* @param {boolean} [descriptor.configurable=false] - boolean indicating if property descriptor can be changed and if the property can be deleted from the provided object
* @param {boolean} [descriptor.enumerable=false] - boolean indicating if the property shows up when enumerating object properties
* @param {boolean} [descriptor.writable=false] - boolean indicating if the value associated with the property can be changed with an assignment operator
* @param {*} [descriptor.value] - property value
* @param {(Function|void)} [descriptor.get=undefined] - function which serves as a getter for the property, or, if no getter, undefined. When the property is accessed, a getter function is called without arguments and with the `this` context set to the object through which the property is accessed (which may not be the object on which the property is defined due to inheritance). The return value will be used as the property value.
* @param {(Function|void)} [descriptor.set=undefined] - function which serves as a setter for the property, or, if no setter, undefined. When assigning a property value, a setter function is called with one argument (the value being assigned to the property) and with the `this` context set to the object through which the property is assigned.
* @throws {TypeError} first argument must be an object
* @throws {TypeError} third argument must be an object
* @throws {Error} property descriptor cannot have both a value and a setter and/or getter
* @returns {Object} object with added property
*
* @example
* var obj = {};
*
* defineProperty( obj, 'foo', {
*     'value': 'bar'
* });
*
* var str = obj.foo;
* // returns 'bar'
*/

/**
* Defines a non-enumerable read-only accessor.
*
* @param {Object} obj - object on which to define the property
* @param {(string|symbol)} prop - property name
* @param {Function} getter - accessor
*
* @example
* function getter() {
*     return 'bar';
* }
*
* var obj = {};
*
* setNonEnumerableReadOnlyAccessor( obj, 'foo', getter );
*
* try {
*     obj.foo = 'boop';
* } catch ( err ) {
*     console.error( err.message );
* }
*/

/**
* Defines a non-enumerable read-only property.
*
* @param {Object} obj - object on which to define the property
* @param {(string|symbol)} prop - property name
* @param {*} value - value to set
*
* @example
* var obj = {};
*
* setNonEnumerableReadOnly( obj, 'foo', 'bar' );
*
* try {
*     obj.foo = 'boop';
* } catch ( err ) {
*     console.error( err.message );
* }
*/

/**
* Defines a non-enumerable read-write accessor.
*
* @param {Object} obj - object on which to define the property
* @param {(string|symbol)} prop - property name
* @param {Function} getter - get accessor
* @param {Function} setter - set accessor
*
* @example
* function getter() {
*     return name + ' foo';
* }
*
* function setter( v ) {
*     name = v;
* }
*
* var name = 'bar';
* var obj = {};
*
* setNonEnumerableReadWriteAccessor( obj, 'foo', getter, setter );
*
* var v = obj.foo;
* // returns 'bar foo'
*
* obj.foo = 'beep';
*
* v = obj.foo;
* // returns 'beep foo'
*/

/**
* Defines a read-only property.
*
* @param {Object} obj - object on which to define the property
* @param {(string|symbol)} prop - property name
* @param {*} value - value to set
*
* @example
* var obj = {};
*
* setReadOnly( obj, 'foo', 'bar' );
*
* try {
*     obj.foo = 'boop';
* } catch ( err ) {
*     console.error( err.message );
* }
*/

/**
* Detects whether an environment returns the expected internal class of the `arguments` object.
*
* @private
* @returns {boolean} boolean indicating whether an environment behaves as expected
*
* @example
* var bool = detect();
* // returns <boolean>
*/

/**
* Determine (nested) array dimensions.
*
* @module @stdlib/array/shape
*
* @example
* var arrayShape = require( '@stdlib/array/shape' );
*
* var arr = [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ];
*
* var shape = arrayShape( arr );
* // returns [ 3, 3 ]
*
* @example
* var arrayShape = require( '@stdlib/array/shape' );
*
* var arr = [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8 ] ];
*
* var shape = arrayShape( arr );
* // returns [ 3 ]
*
* @example
* var arrayShape = require( '@stdlib/array/shape' );
*
* var arr = [ [ 1, 2, 3 ], [ 4, 5, 6 ], null ];
*
* var shape = arrayShape( arr );
* // returns [ 3 ]
*/

/**
* Determine a value's type.
*
* @module @stdlib/utils/type-of
*
* @example
* var typeOf = require( '@stdlib/utils/type-of' );
*
* var str = typeOf( 'a' );
* // returns 'string'
*
* str = typeOf( 5 );
* // returns 'number'
*/

/**
* Determine if an array data type can be cast to another array data type according to a specified casting rule.
*
* @module @stdlib/ndarray/base/assert/is-allowed-data-type-cast
*
* @example
* var isAllowedCast = require( '@stdlib/ndarray/base/assert/is-allowed-data-type-cast' );
*
* var bool = isAllowedCast( 'float32', 'float64', 'safe' );
* // returns true
*
* bool = isAllowedCast( 'float64', 'int32', 'safe' );
* // returns false
*/

/**
* Determine if an ndarray data type can be safely cast to another ndarray data type.
*
* @module @stdlib/ndarray/base/assert/is-safe-data-type-cast
*
* @example
* var isSafeCast = require( '@stdlib/ndarray/base/assert/is-safe-data-type-cast' );
*
* var bool = isSafeCast( 'float32', 'float64' );
* // returns true
*
* bool = isSafeCast( 'float64', 'int32' );
* // returns false
*/

/**
* Determine if an ndarray data type can be safely cast to, or is of the same "kind" as, another ndarray data type.
*
* @module @stdlib/ndarray/base/assert/is-same-kind-data-type-cast
*
* @example
* var isSameKindCast = require( '@stdlib/ndarray/base/assert/is-same-kind-data-type-cast' );
*
* var bool = isSameKindCast( 'float32', 'float64' );
* // returns true
*
* bool = isSameKindCast( 'uint16', 'int16' );
* // returns false
*/

/**
* Determine the index offset which specifies the location of the first indexed value in a multidimensional array based on a stride array.
*
* @module @stdlib/ndarray/strides2offset
*
* @example
* var strides2offset = require( '@stdlib/ndarray/base/strides2offset' );
*
* var shape = [ 2, 3, 10 ];
* var strides = [ 30, -10, 1 ];
*
* var offset = strides2offset( shape, strides );
* // returns 20
*/

/**
* Determine the name of a value's constructor.
*
* @module @stdlib/utils/constructor-name
*
* @example
* var constructorName = require( '@stdlib/utils/constructor-name' );
*
* var v = constructorName( 'a' );
* // returns 'String'
*
* v = constructorName( {} );
* // returns 'Object'
*
* v = constructorName( true );
* // returns 'Boolean'
*/

/**
* Determine the order of a multidimensional array based on a provided stride array.
*
* @module @stdlib/ndarray/base/strides2order
*
* @example
* var strides2order = require( '@stdlib/ndarray/base/strides2order' );
*
* var order = strides2order( [ 2, 1 ] );
* // returns 'row-major'
*
* order = strides2order( [ 1, 2 ] );
* // returns 'column-major'
*
* order = strides2order( [ 1, 1, 1 ] );
* // returns 'both'
*
* order = strides2order( [ 2, 3, 1 ] );
* // returns 'none'
*/

/**
* Determines (nested) array dimensions.
*
* @param {Array} arr - array
* @throws {TypeError} must provide an array
* @returns {Array} array shape
*
* @example
* var arr = [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ];
*
* var shape = arrayShape( arr );
* // returns [ 3, 3 ]
*
* @example
* var arr = [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8 ] ];
*
* var shape = arrayShape( arr );
* // returns [ 3 ]
*
* @example
* var arr = [ [ 1, 2, 3 ], [ 4, 5, 6 ], null ];
*
* var shape = arrayShape( arr );
* // returns [ 3 ]
*/

/**
* Determines a value's type.
*
* @param {*} v - input value
* @returns {string} string indicating the value's type
*/

/**
* Determines if an array is column-major contiguous.
*
* @private
* @param {string} order - **inferred** array order
* @param {boolean} contiguous - boolean indicating is an array is contiguous
* @returns {boolean} boolean indicating if an array is column-major contiguous
*/

/**
* Determines if an array is contiguous.
*
* @private
* @param {NonNegativeInteger} len - array length
* @param {NonNegativeIntegerArray} shape - array shape
* @param {IntegerArray} strides - stride array
* @param {NonNegativeInteger} offset - index offset
* @param {integer} iterationOrder - iteration order
* @returns {boolean} boolean indicating if an array is contiguous
*/

/**
* Determines if an array is row-major contiguous.
*
* @private
* @param {string} order - **inferred** array order
* @param {boolean} contiguous - boolean indicating is an array is contiguous
* @returns {boolean} boolean indicating if an array is row-major contiguous
*/

/**
* Determines the name of a value's constructor.
*
* @param {*} v - input value
* @returns {string} name of a value's constructor
*
* @example
* var v = constructorName( 'a' );
* // returns 'String'
*
* @example
* var v = constructorName( 5 );
* // returns 'Number'
*
* @example
* var v = constructorName( null );
* // returns 'Null'
*
* @example
* var v = constructorName( undefined );
* // returns 'Undefined'
*
* @example
* var v = constructorName( function noop() {} );
* // returns 'Function'
*/

/**
* Determines the order of a multidimensional array based on a provided stride array.
*
* @param {IntegerArray} strides - stride array
* @returns {string} order
*
* @example
* var strides2order = require( '@stdlib/ndarray/base/strides2order' );
*
* var order = strides2order( [ 2, 1 ] );
* // returns 'row-major'
*
* order = strides2order( [ 1, 2 ] );
* // returns 'column-major'
*
* order = strides2order( [ 1, 1, 1 ] );
* // returns 'both'
*
* order = strides2order( [ 2, 3, 1 ] );
* // returns 'none'
*/

/**
* Determines whether an environment throws when comparing to the prototype of a value's constructor (e.g., [IE9][1]).
*
* [1]: https://stackoverflow.com/questions/7688070/why-is-comparing-the-constructor-property-of-two-windows-unreliable
*
* @private
* @returns {boolean} boolean indicating whether an environment is buggy
*/

/**
* Discrete uniform distribution pseudorandom numbers.
*
* @module @stdlib/random/base/discrete-uniform
*
* @example
* var discreteUniform = require( '@stdlib/random/base/discrete-uniform' );
*
* var v = discreteUniform( 1, 10 );
* // returns <number>
*
* @example
* var factory = require( '@stdlib/random/base/discrete-uniform' ).factory;
* var discreteUniform = factory( -5, 5, {
*     'seed': 297
* });
*
* var v = discreteUniform();
* // returns <number>
*
* @example
* var factory = require( '@stdlib/random/base/discrete-uniform' ).factory;
* var discreteUniform = factory({
*     'seed': 297
* });
*
* var v = discreteUniform( -5, 5 );
* // returns <number>
*/

/**
* Double-precision floating-point negative infinity.
*
* ## Notes
*
* Double-precision floating-point negative infinity has the bit sequence
*
* ```binarystring
* 1 11111111111 00000000000000000000 00000000000000000000000000000000
* ```
*
* @constant
* @type {number}
* @default Number.NEGATIVE_INFINITY
* @see [IEEE 754]{@link https://en.wikipedia.org/wiki/IEEE_754-1985}
*/

/**
* Double-precision floating-point negative infinity.
*
* @module @stdlib/constants/math/float64-ninf
* @type {number}
*
* @example
* var FLOAT64_NINF = require( '@stdlib/constants/math/float64-ninf' );
* // returns -Infinity
*/

/**
* Double-precision floating-point positive infinity.
*
* ## Notes
*
* Double-precision floating-point positive infinity has the bit sequence
*
* ```binarystring
* 0 11111111111 00000000000000000000 00000000000000000000000000000000
* ```
*
* @constant
* @type {number}
* @default Number.POSITIVE_INFINITY
* @see [IEEE 754]{@link https://en.wikipedia.org/wiki/IEEE_754-1985}
*/

/**
* Double-precision floating-point positive infinity.
*
* @module @stdlib/constants/math/float64-pinf
* @type {number}
*
* @example
* var FLOAT64_PINF = require( '@stdlib/constants/math/float64-pinf' );
* // returns Infinity
*/

/**
* Dummy constructor.
*
* @private
*/

/**
* Dummy function.
*
* @private
*/

/**
* Escape a regular expression string or pattern.
*
* @module @stdlib/utils/escape-regexp-string
*
* @example
* var rescape = require( '@stdlib/utils/escape-regexp-string' );
*
* var str = rescape( '[A-Z]*' );
* // returns '\\[A\\-Z\\]\\*'
*/

/**
* Escapes a regular expression string.
*
* @param {string} str - regular expression string
* @throws {TypeError} first argument must be a string primitive
* @returns {string} escaped string
*
* @example
* var str = rescape( '[A-Z]*' );
* // returns '\\[A\\-Z\\]\\*'
*/

/**
* Evaluate the natural logarithm.
*
* @module @stdlib/math/base/special/ln
*
* @example
* var ln = require( '@stdlib/math/base/special/ln' );
*
* var v = ln( 4.0 );
* // returns ~1.386
*
* v = ln( 0.0 );
* // returns -Infinity
*
* v = ln( Infinity );
* // returns Infinity
*
* v = ln( NaN );
* // returns NaN
*
* v = ln( -4.0 );
* // returns NaN
*/

/**
* Evaluates a polynomial.
*
* ## Notes
*
* -   The implementation uses [Horner's rule][horners-method] for efficient computation.
*
* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method
*
*
* @private
* @param {number} x - value at which to evaluate the polynomial
* @returns {number} evaluated polynomial
*/

/**
* Evaluates the natural logarithm.
*
* @param {NonNegativeNumber} x - input value
* @returns {number} function value
*
* @example
* var v = ln( 4.0 );
* // returns ~1.386
*
* @example
* var v = ln( 0.0 );
* // returns -Infinity
*
* @example
* var v = ln( Infinity );
* // returns Infinity
*
* @example
* var v = ln( NaN );
* // returns NaN
*
* @example
* var v = ln( -4.0 );
* // returns NaN
*/

/**
* Expand contractions.
*
* @module @stdlib/nlp/expand-contractions
*
* @example
* var expandContractions = require( '@stdlib/nlp/expand-contractions' );
*
* var str = 'I won\'t be able to get y\'all out of this one.';
* var out = expandContractions( str );
* // returns 'I will not be able to get you all out of this one.'
*
* str = 'It oughtn't to be my fault, because, you know, I didn't know';
* out = expandContractions( str );
* // returns 'It ought not to be my fault, because, you know, I did not know'
*/

/**
* Expands a strides array to accommodate an expanded array shape (i.e., an array shape with prepended singleton dimensions).
*
* @private
* @param {NonNegativeInteger} ndims - number of dimensions
* @param {Array} shape - expanded array shape
* @param {Array} strides - strides array
* @param {string} order - memory layout order
* @returns {Array} output strides array
*
* @example
* var out = expandStrides( 4, [ 1, 1, 2, 2 ], [ 1, 2 ], 'column-major' );
* // returns [ 1, 1, 1, 2 ]
*
* @example
* var out = expandStrides( 4, [ 1, 1, 2, 2 ], [ 2, 1 ], 'row-major' );
* // returns [ 4, 4, 2, 1 ]
*/

/**
* Expands all contractions to their formal equivalents.
*
* @param {string} str - string to convert
* @throws {TypeError} must provide a primitive string
* @returns {string} string with expanded contractions
*
* @example
* var str = 'I won\'t be able to get y\'all out of this one.';
* var out = expandContractions( str );
* // returns 'I will not be able to get you all out of this one.'
*
* @example
* var str = 'It oughtn\'t to be my fault, because, you know, I didn\'t know';
* var out = expandContractions( str );
* // returns 'It ought not to be my fault, because, you know, I did not know'
*/

/**
* Extends an array by the elements of another array.
*
* @private
* @param {Array} arr - input array
* @param {Array} ext - array to extend `arr` with
* @returns {Array} mutated input array
*
* @example
* var arr = [ 1, 2, 3 ];
* var out = extend( arr, [ 4, 5 ] );
* // returns [ 1, 2, 3, 4, 5 ]
*/

/**
* Fills an array-like object with zeros.
*
* @private
* @param {(Array|TypedArray|Buffer)} v - array-like object to fill
* @returns {(Array|TypedArray|Buffer)} input value
*
* @example
* var arr = zeros( new Array( 2 ) );
* // returns [ 0, 0 ]
*/

/**
* Finds the closest centroid.
*
* @private
* @param {Function} dist - distance function
* @param {PositiveInteger} k - number of clusters
* @param {PositiveInteger} ndims - number of dimensions
* @param {NumericArray} C - strided array containing centroids
* @param {PositiveInteger} strideC - centroid row stride
* @param {NonNegativeInteger} offsetC - centroid index offset
* @param {NumericArray} V - strided array containing a data point
* @param {integer} strideV - vector stride
* @param {NonNegativeInteger} offsetV - vector index offset
* @returns {NonNegativeInteger} centroid index
*/

/**
* Flatten an array.
*
* @module @stdlib/utils/flatten-array
*
* @example
* var flattenArray = require( '@stdlib/utils/flatten-array' );
*
* var arr = [ 1, [2, [3, [4, [ 5 ], 6], 7], 8], 9 ];
*
* var out = flattenArray( arr );
* // returns [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
*
* @example
* var flattenArray = require( '@stdlib/utils/flatten-array' );
*
* var flatten = flattenArray.factory( [2,2], {
*     'copy': false
* });
*
* var out = flatten( [[1,2],[3,4]] );
* // returns [ 1, 2, 3, 4 ]
*
* out = flatten( [[5,6],[7,8]] );
* // returns [ 5, 6, 7, 8 ]
*/

/**
* Flattens an array.
*
* @param {Array} arr - input array
* @param {Options} [options] - function options
* @param {NonNegativeInteger} [options.depth] - maximum depth to flatten
* @param {boolean} [options.copy=false] - boolean indicating whether to deep copy array elements
* @throws {TypeError} first argument must be an array
* @throws {TypeError} options argument must be an object
* @throws {TypeError} must provide valid options
* @returns {Array} flattened array
*
* @example
* var arr = [ 1, [2, [3, [4, [ 5 ], 6], 7], 8], 9 ];
*
* var out = flattenArray( arr );
* // returns [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
*/

/**
* Generate a stride array from an array shape.
*
* @module @stdlib/ndarray/base/shape2strides
*
* @example
* var shape2strides = require( '@stdlib/ndarray/base/shape2strides' );
*
* var strides = shape2strides( [ 3, 2 ], 'row-major' );
* // returns [ 2, 1 ]
*
* strides = shape2strides( [ 3, 2 ], 'column-major' );
* // returns [ 1, 3 ]
*/

/**
* Generates a full table of safe casts for each ndarray data type.
*
* @private
* @returns {Object} table
*/

/**
* Generates a full table of same "kind" casts for each ndarray data type.
*
* @private
* @returns {Object} table
*/

/**
* Generates a stride array from an array shape.
*
* @param {(Array|TypedArray|Object)} [out] - output object
* @param {NonNegativeIntegerArray} shape - array shape
* @param {string} order - specifies whether an array is row-major (C-style) or column-major (Fortran-style)
* @returns {(Array|TypedArray|Object)} array strides
*
* @example
* var strides = shape2strides( [ 3, 2 ], 'row-major' );
* // returns [ 2, 1 ]
*
* strides = shape2strides( [ 3, 2 ], 'column-major' );
* // returns [ 1, 3 ]
*/

/**
* Generates a stride array from an array shape.
*
* @private
* @param {(Array|TypedArray|Object)} out - output object
* @param {NonNegativeIntegerArray} shape - array shape
* @param {string} order - specifies whether an array is row-major (C-style) or column-major (Fortran-style)
* @returns {(Array|TypedArray|Object)} array strides
*
* @example
* var strides = new Array( 2 );
*
* var out = shape2strides( strides, [ 3, 2 ], 'row-major' );
* // returns [ 2, 1 ]
*
* var bool = ( out === strides );
* // returns true
*
* out = shape2strides( strides, [ 3, 2 ], 'column-major' );
* // returns [ 1, 3 ]
*/

/**
* Generates a table of safe casts for each ndarray data type.
*
* @private
* @returns {Object} table
*/

/**
* Generates a table of same "kind" casts for each ndarray data type.
*
* @private
* @returns {Object} table
*/

/**
* Given a stride array, determine array iteration order.
*
* @module @stdlib/ndarray/base/iteration-order
*
* @example
* var iterationOrder = require( '@stdlib/ndarray/base/iteration-order' );
*
* var o = iterationOrder( [ 2, 1 ] );
* // returns 1
*
* o = iterationOrder( [ -2, 1 ] );
* // returns 0
*
* o = iterationOrder( [ -2, -1 ] );
* // returns -1
*/

/**
* Handles incoming messages, delegates work, and sends back results to main thread.
*
* @param {Event} e - incoming event from main thread
*/

/**
* Implement prototypical inheritance by replacing the prototype of one constructor with the prototype of another constructor.
*
* @module @stdlib/utils/inherit
*
* @example
* var inherit = require( '@stdlib/utils/inherit' );
*
* function Foo() {
*     return this;
* }
* Foo.prototype.beep = function beep() {
*     return 'boop';
* };
*
* function Bar() {
*     Foo.call( this );
*     return this;
* }
* inherit( Bar, Foo );
*
* var bar = new Bar();
* var v = bar.beep();
* // returns 'boop'
*/

/**
* Implements prototypical inheritance by replacing the prototype of one constructor with the prototype of another constructor.
*
* ## Notes
*
* -   This implementation is not designed to work with ES2015/ES6 classes. For ES2015/ES6 classes, use `class` with `extends`.
* -   For reference, see [node#3455](https://github.com/nodejs/node/pull/3455), [node#4179](https://github.com/nodejs/node/issues/4179), [node#3452](https://github.com/nodejs/node/issues/3452), and [node commit](https://github.com/nodejs/node/commit/29da8cf8d7ab8f66b9091ab22664067d4468461e#diff-3deb3f32958bb937ae05c6f3e4abbdf5).
*
*
* @param {(Object|Function)} ctor - constructor which will inherit
* @param {(Object|Function)} superCtor - super (parent) constructor
* @throws {TypeError} first argument must be either an object or a function which can inherit
* @throws {TypeError} second argument must be either an object or a function from which a constructor can inherit
* @throws {TypeError} second argument must have an inheritable prototype
* @returns {(Object|Function)} child constructor
*
* @example
* function Foo() {
*     return this;
* }
* Foo.prototype.beep = function beep() {
*     return 'boop';
* };
*
* function Bar() {
*     Foo.call( this );
*     return this;
* }
* inherit( Bar, Foo );
*
* var bar = new Bar();
* var v = bar.beep();
* // returns 'boop'
*/

/**
* Incrementally partition data into `k` clusters.
*
* @module @stdlib/ml/incr/kmeans
*
* @example
* var Float64Array = require( '@stdlib/array/float64' );
* var ctor = require( '@stdlib/ndarray/ctor' );
* var incrkmeans = require( '@stdlib/ml/incr/kmeans' );
*
* var vector = ctor( 'float64', 1 );
* var matrix = ctor( 'float64', 2 );
*
* // Define initial centroid locations:
* var buffer = [
*     0.0, 0.0,
*     1.0, 1.0,
*     1.0, -1.0,
*     -1.0, -1.0,
*     -1.0, 1.0
* ];
* var shape = [ 5, 2 ];
* var strides = [ 2, 1 ];
* var offset = 0;
* var order = 'row-major';
*
* var centroids = matrix( buffer, shape, strides, offset, order );
*
* // Create a k-means accumulator:
* var accumulator = incrkmeans( centroids );
*
* var out = accumulator();
* // returns {...}
*
* // Create a data vector:
* buffer = new Float64Array( 2 );
* shape = [ 2 ];
* strides = [ 1 ];
*
* var vec = vector( buffer, shape, strides, offset, order );
*
* // Provide data to the accumulator:
* vec.set( 0, 2.0 );
* vec.set( 1, 1.0 );
*
* out = accumulator( vec );
* // returns {...}
*
* vec.set( 0, -5.0 );
* vec.set( 1, 3.14 );
*
* out = accumulator( vec );
* // returns {...}
*
* // Retrieve the current cluster results:
* out = accumulator();
* // returns {...}
*/

/**
* Initializes a PRNG state array according to a seed array.
*
* @private
* @param {Uint32Array} state - state array
* @param {NonNegativeInteger} N - state array length
* @param {ArrayLikeObject} seed - seed array
* @param {NonNegativeInteger} M - seed array length
* @returns {Uint32Array} state array
*/

/**
* Initializes a shuffle table.
*
* @private
* @param {PRNG} rand - pseudorandom number generator
* @param {Int32Array} table - table
* @param {PositiveInteger} N - table size
* @throws {Error} PRNG returned `NaN`
* @returns {NumberArray} shuffle table
*/

/**
* Initializes centroids by performing the k-means++ initialization procedure.
*
* ## Methods
*
* The k-means++ algorithm for choosing initial centroids is as follows:
*
* 1.  Select a data point uniformly at random from a data set \\( X \\). This data point is first centroid and denoted \\( c_0 \\).
*
* 2.  Compute the distance from each data point to \\( c_0 \\). Denote the distance between \\( c_j \\) and data point \\( m \\) as \\( d(x_m, c_j) \\).
*
* 3.  Select the next centroid, \\( c_1 \\), at random from \\( X \\) with probability
*
*     ```tex
*     \frac{d^2(x_m, c_0)}{\sum_{j=0}^{n-1} d^2(x_j, c_0)}
*     ```
*
*     where \\( n \\) is the number of data points.
*
* 4.  To choose centroid \\( j \\),
*
*     a.   Compute the distances from each data point to each centroid and assign each data point to its closest centroid.
*
*     b.   For \\( i = 0,\ldots,n-1 \\) and \\( p = 0,\ldots,j-2 \\), select centroid \\( j \\) at random from \\( X \\) with probability
*
*          ```tex
*          \frac{d^2(x_i, c_p)}{\sum_{\{h; x_h \exits C_p\}} d^2(x_h, c_p)}
*          ```
*
*          where \\( C_p \\) is the set of all data points closest to centroid \\( c_p \\) and \\( x_i \\) belongs to \\( c_p \\).
*
*          Stated more plainly, select each subsequent centroid with a probability proportional to the distance from the centroid to the closest centroid already chosen.
*
* 5.  Repeat step `4` until \\( k \\) centroids have been chosen.
*
* ## References
*
* -   Arthur, David, and Sergei Vassilvitskii. 2007. "K-means++: The Advantages of Careful Seeding." In _Proceedings of the Eighteenth Annual Acm-Siam Symposium on Discrete Algorithms_, 102735. SODA '07. Philadelphia, PA, USA: Society for Industrial and Applied Mathematics. <http://dl.acm.org/citation.cfm?id=1283383.1283494>.
*
* @private
* @param {ndarray} out - output centroids `kxd` matrix
* @param {ndarray} buffer - data buffer
* @param {string} metric - distance metric
* @param {PositiveInteger} trials - number of potential centroids per iteration
* @param {*} seed - PRNG seed
* @returns {ndarray} centroids
*/

/**
* Initializes centroids by randomly assigning each data point to cluster and computing centroids.
*
* ## References
*
* -   Forgy, E. 1965. "Cluster Analysis of Multivariate Data: Efficiency versus Interpretability of Classification." _Biometrics_ 21 (3): 76869.
*
* @private
* @param {ndarray} out - output centroids `kxd` matrix
* @param {ndarray} buffer - buffer containing data points
* @param {*} seed - PRNG seed
* @returns {ndarray} centroids
*/

/**
* Initializes centroids by randomly sampling from a data buffer.
*
* @private
* @param {ndarray} out - output centroids `kxd` matrix
* @param {ndarray} buffer - buffer from which to sample
* @param {*} seed - PRNG seed
* @returns {ndarray} centroids
*/

/**
* Initializes clusters and associated statistics given a set of centroids.
*
* ## Notes
*
* -   We follow the same approach when calculating cluster statistics as if the centroids had been provided by a user (i.e., not computed internally), as this ensures consistency with how statistics are computed when subsequent data vectors are provided to the accumulator.
*
* @private
* @param {ndarray} data - matrix containing data points
* @param {ndarray} centroids - matrix containing centroids
* @param {ndarray} stats - matrix containing cluster statistics
* @param {Function} acc - cluster statistics accumulator
* @param {Function} dist - distance function
*/

/**
* Initializes incremental accumulators for computing the mean vector and associated standard deviation along each dimension.
*
* @private
* @param {PositiveInteger} ndims - number of dimensions
* @returns {Object} accumulators
*/

/**
* Matches parts of a regular expression string.
*
* Regular expression: `/^\/((?:\\\/|[^\/])+)\/([imgy]*)$/`
*
* -   `/^\/`
*     -   match a string that begins with a `/`
*
* -   `()`
*     -   capture
*
* -   `(?:)+`
*     -   capture, but do not remember, a group of characters which occur one or more times
*
* -   `\\\/`
*     -   match the literal `\/`
*
* -   `|`
*     -   OR
*
* -   `[^\/]`
*     -   anything which is not the literal `\/`
*
* -   `\/`
*     -   match the literal `/`
*
* -   `([imgy]*)`
*     -   capture any characters matching `imgy` occurring zero or more times
*
* -   `$/`
*     -   string end
*
*
* @constant
* @type {RegExp}
* @default /^\/((?:\\\/|[^\/])+)\/([imgy]*)$/
*/

/**
* Maximum double-precision floating-point number.
*
* ## Notes
*
* The maximum is given by
*
* ```tex
* 2^{1023} (2 - 2^{-52})
* ```
*
* @constant
* @type {number}
* @default 1.7976931348623157e+308
* @see [IEEE 754]{@link http://en.wikipedia.org/wiki/IEEE_754-1985}
*/

/**
* Maximum double-precision floating-point number.
*
* @module @stdlib/constants/math/float64-max
* @type {number}
*
* @example
* var FLOAT64_MAX = require( '@stdlib/constants/math/float64-max' );
* // returns 1.7976931348623157e+308
*/

/**
* Maximum length of a generic array.
*
* @module @stdlib/constants/array/max-array-length
*
* @example
* var MAX_ARRAY_LENGTH = require( '@stdlib/constants/array/max-array-length' );
* // returns 4294967295
*/

/**
* Maximum length of a generic array.
*
* ```tex
* 2^{32} - 1
* ```
*
* @constant
* @type {uinteger32}
* @default 4294967295
*/

/**
* Maximum length of a typed array.
*
* @module @stdlib/constants/array/max-typed-array-length
*
* @example
* var MAX_TYPED_ARRAY_LENGTH = require( '@stdlib/constants/array/max-typed-array-length' );
* // returns 9007199254740991
*/

/**
* Maximum length of a typed array.
*
* ```tex
* 2^{53} - 1
* ```
*
* @constant
* @type {number}
* @default 9007199254740991
*/

/**
* Maximum safe double-precision floating-point integer.
*
* ## Notes
*
* The integer has the value
*
* ```tex
* 2^{53} - 1
* ```
*
* @constant
* @type {number}
* @default 9007199254740991
* @see [Safe Integers]{@link http://www.2ality.com/2013/10/safe-integers.html}
* @see [IEEE 754]{@link https://en.wikipedia.org/wiki/IEEE_754-1985}
*/

/**
* Maximum safe double-precision floating-point integer.
*
* @module @stdlib/constants/math/float64-max-safe-integer
* @type {number}
*
* @example
* var FLOAT64_MAX_SAFE_INTEGER = require( '@stdlib/constants/math/float64-max-safe-integer' );
* // returns 9007199254740991
*/

/**
* Maximum signed 16-bit integer.
*
* ## Notes
*
* The number has the value
*
* ```tex
* 2^{15} - 1
* ```
*
* which corresponds to the bit sequence
*
* ```binarystring
* 0111111111111111
* ```
*
* @constant
* @type {integer32}
* @default 32767
*/

/**
* Maximum signed 16-bit integer.
*
* @module @stdlib/constants/math/int16-max
* @type {integer32}
*
* @example
* var INT16_MAX = require( '@stdlib/constants/math/int16-max' );
* // returns 32767
*/

/**
* Maximum signed 32-bit integer.
*
* ## Notes
*
* The number has the value
*
* ```tex
* 2^{31} - 1
* ```
*
* which corresponds to the bit sequence
*
* ```binarystring
* 01111111111111111111111111111111
* ```
*
* @constant
* @type {integer32}
* @default 2147483647
*/

/**
* Maximum signed 32-bit integer.
*
* @module @stdlib/constants/math/int32-max
* @type {integer32}
*
* @example
* var INT32_MAX = require( '@stdlib/constants/math/int32-max' );
* // returns 2147483647
*/

/**
* Maximum signed 8-bit integer.
*
* ## Notes
*
* The number is given by
*
* ```tex
* 2^{7} - 1
* ```
*
* which corresponds to the bit sequence
*
* ```binarystring
* 01111111
* ```
*
* @constant
* @type {integer32}
* @default 127
*/

/**
* Maximum signed 8-bit integer.
*
* @module @stdlib/constants/math/int8-max
* @type {integer32}
*
* @example
* var INT8_MAX = require( '@stdlib/constants/math/int8-max' );
* // returns 127
*/

/**
* Maximum unsigned 16-bit integer.
*
* ## Notes
*
* The number has the value
*
* ```tex
* 2^{16} - 1
* ```
*
* which corresponds to the bit sequence
*
* ```binarystring
* 1111111111111111
* ```
*
* @constant
* @type {integer32}
* @default 65535
*/

/**
* Maximum unsigned 16-bit integer.
*
* @module @stdlib/constants/math/uint16-max
* @type {integer32}
*
* @example
* var UINT16_MAX = require( '@stdlib/constants/math/uint16-max' );
* // returns 65535
*/

/**
* Maximum unsigned 32-bit integer.
*
* ## Notes
*
* The number has the value
*
* ```tex
* 2^{32} - 1
* ```
*
* which corresponds to the bit sequence
*
* ```binarystring
* 11111111111111111111111111111111
* ```
*
* @constant
* @type {uinteger32}
* @default 4294967295
*/

/**
* Maximum unsigned 32-bit integer.
*
* @module @stdlib/constants/math/uint32-max
* @type {uinteger32}
*
* @example
* var UINT32_MAX = require( '@stdlib/constants/math/uint32-max' );
* // returns 4294967295
*/

/**
* Maximum unsigned 8-bit integer.
*
* ## Notes
*
* The number has the value
*
* ```tex
* 2^{8} - 1
* ```
*
* which corresponds to the bit sequence
*
* ```binarystring
* 11111111
* ```
*
* @constant
* @type {integer32}
* @default 255
*/

/**
* Maximum unsigned 8-bit integer.
*
* @module @stdlib/constants/math/uint8-max
* @type {integer32}
*
* @example
* var UINT8_MAX = require( '@stdlib/constants/math/uint8-max' );
* // returns 255
*/

/**
* Minimum signed 16-bit integer.
*
* ## Notes
*
* The number has the value
*
* ```tex
* -(2^{15})
* ```
*
* which corresponds to the two's complement bit sequence
*
* ```binarystring
* 1000000000000000
* ```
*
* @constant
* @type {integer32}
* @default -32768
*/

/**
* Minimum signed 16-bit integer.
*
* @module @stdlib/constants/math/int16-min
* @type {integer32}
*
* @example
* var INT16_MIN = require( '@stdlib/constants/math/int16-min' );
* // returns -32768
*/

/**
* Minimum signed 32-bit integer.
*
* ## Notes
*
* The number has the value
*
* ```tex
* -(2^{31})
* ```
*
* which corresponds to the two's complement bit sequence
*
* ```binarystring
* 10000000000000000000000000000000
* ```
*
* @constant
* @type {integer32}
* @default -2147483648
*/

/**
* Minimum signed 32-bit integer.
*
* @module @stdlib/constants/math/int32-min
* @type {integer32}
*
* @example
* var INT32_MIN = require( '@stdlib/constants/math/int32-min' );
* // returns -2147483648
*/

/**
* Minimum signed 8-bit integer.
*
* ## Notes
*
* The number is given by
*
* ```tex
* -(2^{7})
* ```
*
* which corresponds to the two's complement bit sequence
*
* ```binarystring
* 10000000
* ```
*
* @constant
* @type {integer32}
* @default -128
*/

/**
* Minimum signed 8-bit integer.
*
* @module @stdlib/constants/math/int8-min
* @type {integer32}
*
* @example
* var INT8_MIN = require( '@stdlib/constants/math/int8-min' );
* // returns -128
*/

/**
* Multidimensional array.
*
* @module @stdlib/ndarray/array
*
* @example
* var array = require( '@stdlib/ndarray/array' );
*
* var arr = array( [ [ 1, 2 ], [ 3, 4 ] ] );
* // returns <ndarray>
*
* var v = arr.get( 0, 0 );
* // returns 1
*
* @example
* var array = require( '@stdlib/ndarray/array' );
*
* var opts = {
*     'dtype': 'generic',
*     'flatten': false
* };
*
* var arr = array( [ [ 1, 2 ], [ 3, 4 ] ], opts );
* // returns <ndarray>
*
* var v = arr.get( 0 );
* // returns [ 1, 2 ]
*
* @example
* var Float64Array = require( '@stdlib/array/float64' );
* var array = require( '@stdlib/ndarray/array' );
*
* var opts = {
*     'shape': [ 2, 2 ]
* };
*
* var arr = array( new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] ), opts );
* // returns <ndarray>
*
* var v = arr.get( 0, 0 );
* // returns 1.0
*/

/**
* No operation.
*
* @example
* noop();
* // ...does nothing.
*/

/**
* No operation.
*
* @module @stdlib/utils/noop
*
* @example
* var noop = require( '@stdlib/utils/noop' );
*
* noop();
* // ...does nothing.
*/

/**
* Normalizes a vector by standardization.
*
* @private
* @param {NonNegativeInteger} N - number of elements
* @param {NumericArray} X - strided array
* @param {integer} strideX - stride
* @param {NonNegativeInteger} offsetX - index offset
* @param {NumericArray} mean - strided array containing the sample mean along each dimension
* @param {integer} strideM - stride
* @param {NonNegativeInteger} offsetM - index offset
* @param {NumericArray} stdev - strided array containing the standard deviation along each dimension
* @param {integer} strideS - stride
* @param {NonNegativeInteger} offsetS - index offset
* @returns {ndarray} input array
*/

/**
* Normalizes a vector.
*
* @private
* @param {NonNegativeInteger} N - number of elements
* @param {NumericArray} X - strided array
* @param {integer} strideX - stride
* @param {NonNegativeInteger} offsetX - index offset
* @returns {NumericArray} input array
*/

/**
* Normalizes matrix elements by row magnitudes.
*
* @private
* @param {ndarray} mat - matrix to normalize
* @returns {ndarray} input matrix
*/

/**
* Normalizes matrix elements by standardization.
*
* @private
* @param {ndarray} mat - matrix to normalize
* @param {Float64Array} stats - strided array containing the mean and standard deviation along each dimension
* @returns {ndarray} input matrix
*/

/**
* Parses a regular expression string and returns a new regular expression.
*
* @param {string} str - regular expression string
* @throws {TypeError} must provide a regular expression string
* @returns {(RegExp|null)} regular expression or null
*
* @example
* var re = reFromString( '/beep/' );
* // returns /beep/
*/

/**
* Perform C-like multiplication of two unsigned 32-bit integers.
*
* @module @stdlib/math/base/special/uimul
*
* @example
* var uimul = require( '@stdlib/math/base/special/uimul' );
*
* var v = uimul( 10>>>0, 4>>>0 );
* // returns 40
*/

/**
* Performs C-like multiplication of two unsigned 32-bit integers.
*
* ## Method
*
* -   To emulate C-like multiplication without the aid of 64-bit integers, we recognize that a 32-bit integer can be split into two 16-bit words
*
*     ```tex
*     a = w_h*2^{16} + w_l
*     ```
*
*     where \\( w_h \\) is the most significant 16 bits and \\( w_l \\) is the least significant 16 bits. For example, consider the maximum unsigned 32-bit integer \\( 2^{32}-1 \\)
*
*     ```binarystring
*     11111111111111111111111111111111
*     ```
*
*     The 16-bit high word is then
*
*     ```binarystring
*     1111111111111111
*     ```
*
*     and the 16-bit low word
*
*     ```binarystring
*     1111111111111111
*     ```
*
*     If we cast the high word to 32-bit precision and multiply by \\( 2^{16} \\) (equivalent to a 16-bit left shift), then the bit sequence is
*
*     ```binarystring
*     11111111111111110000000000000000
*     ```
*
*     Similarly, upon casting the low word to 32-bit precision, the bit sequence is
*
*     ```binarystring
*     00000000000000001111111111111111
*     ```
*
*     From the rules of binary addition, we recognize that adding the two 32-bit values for the high and low words will return our original value \\( 2^{32}-1 \\).
*
* -   Accordingly, the multiplication of two 32-bit integers can be expressed
*
*     ```tex
*     \begin{align*}
*     a \cdot b &= ( a_h \cdot 2^{16} + a_l) \cdot ( b_h \cdot 2^{16} + b_l) \\
*           &= a_l \cdot b_l + a_h \cdot b_l \cdot 2^{16} + a_l \cdot b_h \cdot 2^{16} + (a_h \cdot b_h) \cdot 2^{32} \\
*           &= a_l \cdot b_l + (a_h \cdot b_l + a_l \cdot b_h) \cdot 2^{16} + (a_h \cdot b_h) \cdot 2^{32}
*     \end{align*}
*     ```
*
* -   We note that multiplying (dividing) an integer by \\( 2^n \\) is equivalent to performing a left (right) shift of \\( n \\) bits.
*
* -   Further, as we want to return an integer of the same precision, for a 32-bit integer, the return value will be modulo \\( 2^{32} \\). Stated another way, we only care about the low word of a 64-bit result.
*
* -   Accordingly, the last term, being evenly divisible by \\( 2^{32} \\), drops from the equation leaving the remaining two terms as the remainder.
*
*     ```tex
*     a \cdot b = a_l \cdot b_l + (a_h \cdot b_l + a_l \cdot b_h) << 16
*     ```
*
* -   Lastly, the second term in the above equation contributes to the middle bits and may cause the product to "overflow". However, we can disregard (`>>>0`) overflow bits due modulo arithmetic, as discussed earlier with regard to the term involving the partial product of high words.
*
*
* @param {uinteger32} a - integer
* @param {uinteger32} b - integer
* @returns {uinteger32} product
*
* @example
* var v = uimul( 10>>>0, 4>>>0 );
* // returns 40
*/

/**
* Pre-processes a document. The function performs the following steps:
*
* -   turning all characters to lowercase
* -   expand contractions such as don't => do not
* -   remove all punctuation characters
* -   remove a list of very common English words ("stopwords") that do not add much value for clustering and selecting documents
* -   trims whitespace from the beginning and end of the string
*
* @param {string} doc - input document
* @returns {string} pre-processed document
*/

/**
* Prepends singleton dimensions in order to satisfy a minimum number of dimensions.
*
* @private
* @param {NonNegativeInteger} ndims - number of dimensions
* @param {Array} shape - array dimensions
* @param {NonNegativeInteger} ndmin - minimum number of dimensions
* @returns {Array} output shape array
*/

/**
* Recursively (and eagerly) attempts to resolve nested array dimensions.
*
* @private
* @param {Array} shape - output array
* @param {Array} arr - array
* @returns {Array} shape array
*/

/**
* Recursively converts an ndarray to a generic array.
*
* @private
* @param {(ArrayLikeObject|TypedArray|Buffer)} buffer - data buffer
* @param {NonNegativeIntegerArray} shape - array shape
* @param {IntegerArray} strides - array strides
* @param {NonNegativeInteger} offset - index offset
* @param {string} order - specifies whether an array is row-major (C-style) or column-major (Fortran-style)
* @param {NonNegativeInteger} dim - dimension
* @returns {(Array|Array<Array>)} output array
*/

/**
* Recursively flattens an array.
*
* @private
* @param {Array} out - output array
* @param {Array} arr - input array
* @param {NonNegativeInteger} depth - recursion depth
* @returns {Array} output array
*/

/**
* Recursively performs a deep copy of an input object.
*
* @private
* @param {*} val - value to copy
* @param {(Array|Object)} copy - copy
* @param {Array} cache - an array of visited objects
* @param {Array} refs - an array of object references
* @param {NonNegativeInteger} level - copy depth
* @returns {*} deep copy
*/

/**
* Recursively verifies that all nested arrays have consistent dimensions.
*
* @private
* @param {PositiveInteger} ndims - number of dimensions
* @param {Array} shape - shape array
* @param {NonNegativeInteger} d - dimension
* @param {Array} arr - array element to verify
* @param {boolean} flg - boolean indicating whether to continue recursing
* @returns {NonNegativeInteger} number of consistent dimensions
*/

/**
* Regular expression to capture everything that is not a space immediately after the `function` keyword and before the first left parenthesis.
*
* @module @stdlib/regexp/function-name
* @type {RegExp}
*
* @example
* var RE_FUNCTION_NAME = require( '@stdlib/regexp/function-name' );
*
* function fname( fcn ) {
*     return RE_FUNCTION_NAME.exec( fcn.toString() )[ 1 ];
* }
*
* var fn = fname( Math.sqrt );
* // returns 'sqrt'
*
* fn = fname( Int8Array );
* // returns 'Int8Array'
*
* fn = fname( Object.prototype.toString );
* // returns 'toString'
*
* fn = fname( function(){} );
* // returns ''
*/

/**
* Regular expression to parse a regular expression string.
*
* @module @stdlib/regexp/regexp
* @type {RegExp}
*
* @example
* var RE_REGEXP = require( '@stdlib/regexp/regexp' );
*
* var bool = RE_REGEXP.test( '/^beep$/' );
* // returns true
*
* bool = RE_REGEXP.test( '' );
* // returns false
*
* @example
* var RE_REGEXP = require( '@stdlib/regexp/regexp' );
*
* var parts = RE_REGEXP.exec( '/^.*$/ig' );
* // returns [ '/^.*$/ig', '^.*$', 'ig', 'index': 0, 'input': '/^.*$/ig' ]
*/

/**
* Remove a list of words from a string.
*
* @module @stdlib/string/remove-words
*
* @example
* var removeWords = require( '@stdlib/string/remove-words' );
*
* var str = 'beep boop Foo bar';
* var words = [ 'boop', 'foo' ];
*
* var out = removeWords( str, words );
* // returns 'beep  Foo bar'
*
* // Case-insensitive:
* out = removeWords( str, words, true )
* //returns 'beep   bar'
*/

/**
* Remove punctuation characters from a string.
*
* @module @stdlib/string/remove-punctuation
*
* @example
* var removePunctuation = require( '@stdlib/string/remove-punctuation' );
*
* var out = removePunctuation( 'Sun Tzu said: "A leader leads by example not by force."' );
* // returns 'Sun Tzu said A leader leads by example not by force'
*
* out = removePunctuation( 'Double, double, toil and trouble; Fire burn, and cauldron bubble!' ) );
* // returns 'Double double toil and trouble Fire burn and cauldron bubble'
*/

/**
* Removes a list of words from a string.
*
* @param {string} str - input string
* @param {StringArray} words - array of words to be removed
* @param {boolean} [ignoreCase=false] - boolean indicating whether to perform a case-insensitive operation
* @throws {TypeError} first argument must be a string primitive
* @throws {TypeError} second argument must be an array of words
* @throws {TypeError} third argument must be a boolean primitive
* @returns {string} output string
*
* @example
* var str = 'beep boop Foo bar';
* var out = removeWords( str, [ 'boop', 'foo' ] );
* // returns 'beep  Foo bar'
*
* @example
* var str = 'beep boop Foo bar';
* var out = removeWords( str, [ 'boop', 'foo' ], true );
* // returns 'beep   bar'
*/

/**
* Removes punctuation characters from a string.
*
* @param {string} str - input string
* @throws {TypeError} must provide a string primitive
* @returns {string} output string
*
* @example
* var str = 'Sun Tzu said: "A leader leads by example not by force."';
* var out = removePunctuation( str );
* // returns 'Sun Tzu said A leader leads by example not by force'
*
* @example
* var str = 'Double, double, toil and trouble; Fire burn, and cauldron bubble!';
* var out = removePunctuation( str );
* // returns 'Double double toil and trouble Fire burn and cauldron bubble'
*
* @example
* var str = 'This module removes these characters: `{}[]:,!/<>().;~|?\'"';
* var out = removePunctuation( str );
* // returns 'This module removes these characters '
*/

/**
* Replace search occurrences with a replacement string.
*
* @module @stdlib/string/replace
*
* @example
* var replace = require( '@stdlib/string/replace' );
*
* var str = 'beep';
* var out = replace( str, 'e', 'o' );
* // returns 'boop'
*
* str = 'Hello World';
* out = replace( str, /world/i, 'Mr. President' );
* // returns 'Hello Mr. President'
*/

/**
* Replace search occurrences with a replacement string.
*
* @param {string} str - input string
* @param {(string|RegExp)} search - search expression
* @param {(string|Function)} newval - replacement value or function
* @throws {TypeError} first argument must be a string primitive
* @throws {TypeError} second argument argument must be a string primitive or regular expression
* @throws {TypeError} third argument must be a string primitive or function
* @returns {string} new string containing replacement(s)
*
* @example
* var str = 'beep';
* var out = replace( str, 'e', 'o' );
* // returns 'boop'
*
* @example
* var str = 'Hello World';
* var out = replace( str, /world/i, 'Mr. President' );
* // returns 'Hello Mr. President'
*
* @example
* var capitalize = require( '@stdlib/string/capitalize' );
*
* var str = 'Oranges and lemons say the bells of St. Clement\'s';
*
* function replacer( match, p1 ) {
*     return capitalize( p1 );
* }
*
* var out = replace( str, /([^\s]*)/gi, replacer);
* // returns 'Oranges And Lemons Say The Bells Of St. Clement\'s'
*/

/**
* Restrict an index to the interval `[0,max]`.
*
* @module @stdlib/ndarray/base/clamp-index
*
* @example
* var clampIndex = require( '@stdlib/ndarray/base/clamp-index' );
*
* var idx = clampIndex( -1, 10 );
* // returns 0
*
* idx = clampIndex( 15, 10 );
* // returns 10
*
* idx = clampIndex( 5, 10 );
* // returns 5
*/

/**
* Restricts an index to the interval `[0,max]`.
*
* @param {integer} idx - index
* @param {NonNegativeInteger} max - maximum index
* @returns {NonNegativeInteger} index
*
* @example
* var idx = clampIndex( -1, 10 );
* // returns 0
*
* idx = clampIndex( 15, 10 );
* // returns 10
*
* idx = clampIndex( 5, 10 );
* // returns 5
*/

/**
* Return a JSON representation of a typed array.
*
* @module @stdlib/array/to-json
*
* @example
* var Float64Array = require( '@stdlib/array/float64' );
* var toJSON = require( '@stdlib/array/to-json' );
*
* var arr = new Float64Array( [ 5.0, 3.0 ] );
* var json = toJSON( arr );
* // returns { 'type': 'Float64Array', 'data': [ 5.0, 3.0 ] }
*/

/**
* Return a boolean indicating if a buffer length is compatible with provided ndarray meta data.
*
* @module @stdlib/ndarray/base/assert/is-stride-offset-buffer-compatible
*
* @example
* var isBufferLengthCompatible = require( '@stdlib/ndarray/base/assert/is-buffer-length-compatible' );
*
* var shape = [ 2, 2 ];
* var strides = [ 2, 1 ];
* var offset = 0;
*
* var bool = isBufferLengthCompatible( 4, shape, strides, offset );
* // returns true
*
* @example
* var isBufferLengthCompatible = require( '@stdlib/ndarray/base/assert/is-buffer-length-compatible' );
*
* var shape = [ 2, 2 ];
* var strides = [ 2, 1 ];
* var offset = 2;
*
* var bool = isBufferLengthCompatible( 4, shape, strides, offset );
* // returns false
*/

/**
* Return a boolean indicating if an environment is little endian.
*
* @module @stdlib/assert/is-little-endian
*
* @example
* var IS_LITTLE_ENDIAN = require( '@stdlib/assert/is-little-endian' );
*
* var bool = IS_LITTLE_ENDIAN;
* // returns <boolean>
*/

/**
* Return a function which tests if every element in an array passes a test condition.
*
* @module @stdlib/assert/tools/array-function
*
* @example
* var isOdd = require( '@stdlib/assert/is-odd' );
* var arrayfcn = require( '@stdlib/assert/tools/array-function' );
*
* var arr1 = [ 1, 3, 5, 7 ];
* var arr2 = [ 3, 5, 8 ];
*
* var validate = arrayfcn( isOdd );
*
* var bool = validate( arr1 );
* // returns true
*
* bool = validate( arr2 );
* // returns false
*/

/**
* Return a function which tests if every element in an array-like object passes a test condition.
*
* @module @stdlib/assert/tools/array-like-function
*
* @example
* var isOdd = require( '@stdlib/assert/is-odd' );
* var arraylikefcn = require( '@stdlib/assert/tools/array-like-function' );
*
* var arr1 = [ 1, 3, 5, 7 ];
* var arr2 = [ 3, 5, 8 ];
*
* var validate = arraylikefcn( isOdd );
*
* var bool = validate( arr1 );
* // returns true
*
* bool = validate( arr2 );
* // returns false
*/

/**
* Return a list of ndarray casting modes.
*
* @module @stdlib/ndarray/casting-modes
*
* @example
* var modes = require( '@stdlib/ndarray/casting-modes' );
*
* var list = modes();
* // returns [ 'none', 'equiv', 'safe', 'same-kind', 'unsafe' ]
*/

/**
* Return a list of ndarray data types to which a provided ndarray data type can be safely cast or cast within the same "kind".
*
* @module @stdlib/ndarray/same-kind-casts
*
* @example
* var sameKindCasts = require( '@stdlib/ndarray/same-kind-casts' );
*
* var list = sameKindCasts( 'float32' );
* // returns [...]
*/

/**
* Return a list of ndarray data types to which a provided ndarray data type can be safely cast.
*
* @module @stdlib/ndarray/safe-casts
*
* @example
* var safeCasts = require( '@stdlib/ndarray/safe-casts' );
*
* var list = safeCasts( 'float32' );
* // returns [...]
*/

/**
* Return a list of ndarray data types.
*
* @module @stdlib/ndarray/dtypes
*
* @example
* var dtypes = require( '@stdlib/ndarray/dtypes' );
*
* var list = dtypes();
* // returns [...]
*/

/**
* Return a list of ndarray index modes.
*
* @module @stdlib/ndarray/index-modes
*
* @example
* var modes = require( '@stdlib/ndarray/index-modes' );
*
* var list = modes();
* // returns [ 'throw', 'clamp', 'wrap' ]
*/

/**
* Return a list of ndarray orders.
*
* @module @stdlib/ndarray/orders
*
* @example
* var orders = require( '@stdlib/ndarray/orders' );
*
* var list = orders();
* // returns [ 'row-major', 'column-major' ]
*/

/**
* Return a property descriptor for an object's own property.
*
* @module @stdlib/utils/property-descriptor
*
* @example
* var getOwnPropertyDescriptor = require( '@stdlib/utils/property-descriptor' );
*
* var obj = {
*   'foo': 'bar',
*   'beep': 'boop'
* };
*
* var keys = getOwnPropertyDescriptor( obj, 'foo' );
* // returns {'configurable':true,'enumerable':true,'writable':true,'value':'bar'}
*/

/**
* Return a string value indicating a specification defined classification of an object.
*
* @module @stdlib/utils/native-class
*
* @example
* var nativeClass = require( '@stdlib/utils/native-class' );
*
* var str = nativeClass( 'a' );
* // returns '[object String]'
*
* str = nativeClass( 5 );
* // returns '[object Number]'
*
* function Beep() {
*     return this;
* }
* str = nativeClass( new Beep() );
* // returns '[object Object]'
*/

/**
* Return an array of an object's own enumerable and non-enumerable property names.
*
* @module @stdlib/utils/property-names
*
* @example
* var getOwnPropertyNames = require( '@stdlib/utils/property-names' );
*
* var keys = getOwnPropertyNames({
*   'foo': 'bar',
*   'beep': 'boop'
* });
* // e.g., returns [ 'foo', 'beep' ]
*/

/**
* Return an array of an object's own enumerable property names.
*
* @module @stdlib/utils/keys
*
* @example
* var keys = require( '@stdlib/utils/keys' );
*
* var obj = {
*     'beep': 'boop',
*     'foo': 3.14
* };
*
* var k = keys( obj );
* // e.g., returns [ 'beep', 'foo' ]
*/

/**
* Return an index given an index mode.
*
* @module @stdlib/ndarray/base/ind
*
* @example
* var ind = require( '@stdlib/ndarray/base/ind' );
*
* var idx = ind( -1, 10, 'wrap' );
* // returns 10
*
* idx = ind( 14, 10, 'wrap' );
* // returns 3
*
* idx = ind( 6, 10, 'wrap' );
* // returns 6
*
* @example
* var ind = require( '@stdlib/ndarray/base/ind' );
*
* var idx = ind( -1, 10, 'clamp' );
* // returns 0
*
* idx = ind( 14, 10, 'clamp' );
* // returns 10
*
* idx = ind( 6, 10, 'clamp' );
* // returns 6
*
* @example
* var ind = require( '@stdlib/ndarray/base/ind' );
*
* var idx = ind( 1, 10, 'throw' );
* // returns 1
*
* idx = ind( 14, 10, 'throw' );
* // throws <RangeError>
*
* idx = ind( -1, 10, 'throw' );
* // throws <RangeError>
*/

/**
* Return an unsigned 32-bit integer corresponding to the more significant 32 bits of a double-precision floating-point number.
*
* @module @stdlib/number/float64/base/get-high-word
*
* @example
* var getHighWord = require( '@stdlib/number/float64/base/get-high-word' );
*
* var w = getHighWord( 3.14e201 ); // => 01101001110001001000001011000011
* // returns 1774486211
*/

/**
* Return the data type of an ndarray data buffer.
*
* @module @stdlib/ndarray/base/buffer-dtype
*
* @example
* var Float64Array = require( '@stdlib/array/float64' );
* var dtype = require( '@stdlib/ndarray/base/buffer-dtype' );
*
* var buf = new Float64Array( 10 );
*
* var dt = dtype( buf );
* // returns 'float64'
*
* dt = dtype( {} );
* // returns 'generic'
*
* dt = dtype( 'beep' );
* // returns null
*/

/**
* Return the first index at which a given element can be found.
*
* @module @stdlib/utils/index-of
*
* @example
* var indexOf = require( '@stdlib/utils/index-of' );
*
* var arr = [ 4, 3, 2, 1 ];
* var idx = indexOf( arr, 3 );
* // returns 1
*
* arr = [ 4, 3, 2, 1 ];
* idx = indexOf( arr, 5 );
* // returns -1
*
* // Using a `fromIndex`:
* arr = [ 1, 2, 3, 4, 5, 2, 6 ];
* idx = indexOf( arr, 2, 3 );
* // returns 5
*
* // `fromIndex` which exceeds `array` length:
* arr = [ 1, 2, 3, 4, 2, 5 ];
* idx = indexOf( arr, 2, 10 );
* // returns -1
*
* // Negative `fromIndex`:
* arr = [ 1, 2, 3, 4, 5, 2, 6, 2 ];
* idx = indexOf( arr, 2, -4 );
* // returns 5
*
* idx = indexOf( arr, 2, -1 );
* // returns 7
*
* // Negative `fromIndex` exceeding input `array` length:
* arr = [ 1, 2, 3, 4, 5, 2, 6 ];
* idx = indexOf( arr, 2, -10 );
* // returns 1
*
* // Array-like objects:
* var str = 'bebop';
* idx = indexOf( str, 'o' );
* // returns 3
*/

/**
* Return the global object.
*
* @module @stdlib/utils/global
*
* @example
* var getGlobal = require( '@stdlib/utils/global' );
*
* var g = getGlobal();
* // returns {...}
*/

/**
* Return the maximum value.
*
* @module @stdlib/math/base/special/max
*
* @example
* var max = require( '@stdlib/math/base/special/max' );
*
* var v = max( 3.14, 4.2 );
* // returns 4.2
*
* v = max( 5.9, 3.14, 4.2 );
* // returns 5.9
*
* v = max( 3.14, NaN );
* // returns NaN
*
* v = max( +0.0, -0.0 );
* // returns +0.0
*/

/**
* Return the name of a function.
*
* @module @stdlib/utils/function-name
*
* @example
* var functionName = require( '@stdlib/utils/function-name' );
*
* var v = functionName( String );
* // returns 'String'
*
* v = functionName( function foo(){} );
* // returns 'foo'
*
* v = functionName( function(){} );
* // returns '' || 'anonymous'
*/

/**
* Return the number of bytes per element provided an underlying array data type.
*
* @module @stdlib/ndarray/base/bytes-per-element
*
* @example
* var bytesPerElement = require( '@stdlib/ndarray/base/bytes-per-element' );
*
* var nbytes = bytesPerElement( 'float64' );
* // returns 8
*
* nbytes = bytesPerElement( 'generic' );
* // returns null
*/

/**
* Return the number of elements in an array.
*
* @module @stdlib/ndarray/base/numel
*
* @example
* var numel = require( '@stdlib/ndarray/base/numel' );
*
* var n = numel( [ 3, 3, 3 ] );
* // returns 27
*/

/**
* Return the prototype of a provided object.
*
* @module @stdlib/utils/get-prototype-of
*
* @example
* var getPrototype = require( '@stdlib/utils/get-prototype-of' );
*
* var proto = getPrototype( {} );
* // returns {}
*/

/**
* Returns a 32-bit Mersenne Twister pseudorandom number generator.
*
* ## Notes
*
* -   In contrast to the original C implementation, array seeds of length `1` are considered integer seeds. This ensures that the seed `[ 1234 ]` generates the same output as the seed `1234`. In the original C implementation, the two seeds would yield different output, which is **not** obvious from a user perspective.
*
* @param {Options} [options] - options
* @param {PRNGSeedMT19937} [options.seed] - pseudorandom number generator seed
* @param {PRNGStateMT19937} [options.state] - pseudorandom number generator state
* @param {boolean} [options.copy=true] - boolean indicating whether to copy a provided pseudorandom number generator state
* @throws {TypeError} options argument must be an object
* @throws {TypeError} a seed must be either a positive integer less than or equal to the maximum unsigned 32-bit integer or an array-like object containing integers less than or equal to the maximum unsigned 32-bit integer
* @throws {RangeError} a numeric seed must be a positive integer less than or equal to the maximum unsigned 32-bit integer
* @throws {TypeError} state must be a `Uint32Array`
* @throws {Error} must provide a valid state
* @throws {TypeError} `copy` option must be a boolean
* @returns {PRNG} Mersenne Twister PRNG
*
* @example
* var mt19937 = factory();
*
* var v = mt19937();
* // returns <number>
*
* @example
* // Return a seeded Mersenne Twister PRNG:
* var mt19937 = factory({
*     'seed': 1234
* });
*
* var v = mt19937();
* // returns 822569775
*/

/**
* Returns a JSON representation of a typed array.
*
* ## Notes
*
* -   We build a JSON object representing a typed array similar to how Node.js `Buffer` objects are represented. See [Buffer][1].
*
* [1]: https://nodejs.org/api/buffer.html#buffer_buf_tojson
*
* @param {TypedArray} arr - typed array to serialize
* @throws {TypeError} first argument must be a typed array
* @returns {Object} JSON representation
*
* @example
* var Float64Array = require( '@stdlib/array/float64' );
*
* var arr = new Float64Array( [ 5.0, 3.0 ] );
* var json = toJSON( arr );
* // returns { 'type': 'Float64Array', 'data': [ 5.0, 3.0 ] }
*/

/**
* Returns a boolean indicating if a buffer length is compatible with provided ndarray meta data.
*
* @param {NonNegativeInteger} len - buffer length
* @param {NonNegativeIntegerArray} shape - array shape
* @param {IntegerArray} strides - stride array
* @param {NonNegativeInteger} offset - index offset
* @returns {boolean} boolean indicating if a buffer length is compatible
*
* @example
* var shape = [ 2, 2 ];
* var strides = [ 2, 1 ];
* var offset = 0;
*
* var bool = isBufferLengthCompatible( 4, shape, strides, offset );
* // returns true
*
* @example
* var shape = [ 2, 2 ];
* var strides = [ 2, 1 ];
* var offset = 2;
*
* var bool = isBufferLengthCompatible( 4, shape, strides, offset );
* // returns false
*/

/**
* Returns a boolean indicating if a provided ndarray data type can be cast to another ndarray data type according to a specified casting mode.
*
* @param {string} from - ndarray data type
* @param {string} to - ndarray data type
* @param {string} casting - ndarray casting mode
* @returns {boolean} boolean indicating if a data type can be cast to another data type
*
* @example
* var bool = isAllowedCast( 'float32', 'float64', 'safe' );
* // returns true
*
* bool = isAllowedCast( 'float64', 'int32', 'safe' );
* // returns false
*/

/**
* Returns a boolean indicating if a provided ndarray data type can be safely cast to another ndarray data type.
*
* @param {string} from - ndarray data type
* @param {string} to - ndarray data type
* @returns {boolean} boolean indicating if a data type can be safely cast to another data type
*
* @example
* var bool = isSafeCast( 'float32', 'float64' );
* // returns true
*
* bool = isSafeCast( 'float64', 'int32' );
* // returns false
*/

/**
* Returns a boolean indicating if a provided ndarray data type can be safely cast to, or is of the same "kind" as, another ndarray data type.
*
* @param {string} from - ndarray data type
* @param {string} to - ndarray data type
* @returns {boolean} boolean indicating if a data type can be cast to another data type
*
* @example
* var bool = isSameKindCast( 'float32', 'float64' );
* // returns true
*
* bool = isSameKindCast( 'uint16', 'int16' );
* // returns false
*/

/**
* Returns a cache key.
*
* @private
* @param {string} dtype - data type
* @param {Options} opts - function options
* @param {boolean} opts.codegen - boolean indicating whether to use code generation
* @param {string} opts.mode - specifies how to handle indices which exceed array dimensions
* @param {StringArray} opts.submode - specifies how to handle subscripts which exceed array dimensions on a per dimension basis
* @returns {string} cache key
*
* @example
* var opts = {
*     'codegen': true,
*     'mode': 'throw',
*     'submode': [ 'throw' ]
* };
* var key = getKey( 'float64', opts );
* // returns 'float64;codegen=true,mode="throw",submode=["throw"]'
*/

/**
* Returns a cache key.
*
* @private
* @param {string} dtype - data type
* @param {Options} opts - function options
* @param {boolean} opts.codegen - boolean indicating whether to use code generation
* @returns {string} cache key
*
* @example
* var opts = {
*     'codegen': true
* };
* var key = getKey( 'float64', opts );
* // returns 'float64;codegen=true'
*/

/**
* Returns a constructor cache.
*
* ## Notes
*
* -   Should return something similar to the following:
*
*     ```text
*     {
*         "float64;codegen=true": [],
*         "float64;codegen=false": [],
*         "float32;codegen=true": [],
*         "float32;codegen=false": [],
*         ...
*     }
*     ```
*
* @private
* @returns {Object} constructor cache
*/

/**
* Returns a constructor cache.
*
* @private
* @returns {Object} constructor cache
*/

/**
* Returns a function for flattening arrays having specified dimensions.
*
* @param {PositiveIntegerArray} dims - dimensions
* @param {Options} [options] - function options
* @param {boolean} [options.copy=false] - boolean indicating whether to deep copy array elements
* @throws {TypeError} first argument must be an array of positive integers
* @throws {TypeError} options argument must be an object
* @throws {TypeError} must provide valid options
* @returns {Function} flatten function
*
* @example
* var flatten = factory( [2,2], {
*     'copy': false
* });
*
* var out = flatten( [[1,2],[3,4]] );
* // returns [ 1, 2, 3, 4 ]
*
* out = flatten( [[5,6],[7,8]] );
* // returns [ 5, 6, 7, 8 ]
*/

/**
* Returns a function to flatten an array and deep copy.
*
* @private
* @param {Function} flatten - flatten function
* @returns {Function} wrapped flatten function
*/

/**
* Returns a function to flatten an array containing elements all having the same dimensions.
*
* @private
* @param {PositiveIntegerArray} dims - dimensions
* @returns {Function} flatten function
*/

/**
* Returns a function to flatten an array.
*
* @private
* @param {Function} flatten - flatten function
* @returns {Function} wrapped flatten function
*/

/**
* Returns a function to sample elements from an array-like object.
*
* @param {ArrayLike} [pool] - array-like object from which to sample
* @param {Options} [options] - function options
* @param {PositiveInteger} [options.seed] - integer-valued seed
* @param {NonNegativeInteger} [options.size] - sample size
* @param {boolean} [options.replace=true] - boolean indicating whether to sample with replacement
* @param {boolean} [options.mutate=false] - boolean indicating whether to mutate the `pool` when sampling without replacement
* @throws {TypeError} `pool` must be an array-like object
* @throws {TypeError} options argument must be an object
* @throws {TypeError} must provide valid options
* @returns {Function} function to sample elements from an array-like object
*
* @example
* var sample = factory({
*     'seed': 232
* });
* var out = sample( 'abcdefg' );
* // e.g., returns [ 'g', 'd', 'g', 'f', 'c', 'e', 'f' ]
*
* @example
* var sample = factory( [ 1, 2, 3, 4, 5, 6 ], {
*     'seed': 232,
*     'size': 2
* });
* var out = sample();
* // e.g., returns [ 6, 4 ]
*
* out = sample();
* // e.g., returns [ 6, 5 ]
*
* @example
* var sample = factory( [ 1, 2, 3, 4, 5, 6 ], {
*     'seed': 474,
*     'size': 3,
*     'mutate': true,
*     'replace': false
* });
* var out = sample();
* // e.g., returns [ 4, 3, 6 ]
*
* out = sample();
* // e.g., returns [ 1, 5, 2 ]
*
* out = sample();
* // returns null
*
* @example
* var sample = factory( [ 0, 1 ], {
*     'size': 2
* });
*
* var out = sample();
* // e.g., returns [ 1, 1 ]
*
* out = sample({
*     'size': 10
* });
* // e.g., returns [ 0, 1, 1, 1, 0, 1, 0, 0, 1, 1 ]
*
* @example
* var sample = factory( [ 0, 1 ], {
*     'size': 2
* });
*
* var out = sample();
* // e.g., returns [ 1, 1 ]
*
* out = sample({
*     'replace': false
* });
* // e.g., returns [ 0, 1 ] or [ 1, 0 ]
*
* out = sample();
* // e.g., returns [ 1, 1 ]
*
* @example
* var sample = factory( [ 0, 1 ], {
*     'size': 2,
*     'mutate': true
* });
*
* var out = sample();
* // e.g., returns [ 1, 1 ]
*
* out = sample({
*     'replace': false
* });
* // e.g., returns [ 0, 1 ] or [ 1, 0 ]
*
* out = sample();
* // returns null
*/

/**
* Returns a function which tests if every element in an array passes a test condition.
*
* @param {Function} predicate - function to apply
* @throws {TypeError} must provide a function
* @returns {Function} an array function
*
* @example
* var isOdd = require( '@stdlib/assert/is-odd' );
*
* var arr1 = [ 1, 3, 5, 7 ];
* var arr2 = [ 3, 5, 8 ];
*
* var validate = arrayfcn( isOdd );
*
* var bool = validate( arr1 );
* // returns true
*
* bool = validate( arr2 );
* // returns false
*/

/**
* Returns a function which tests if every element in an array-like object passes a test condition.
*
* @param {Function} predicate - function to apply
* @throws {TypeError} must provide a function
* @returns {Function} an array-like object function
*
* @example
* var isOdd = require( '@stdlib/assert/is-odd' );
*
* var arr1 = [ 1, 3, 5, 7 ];
* var arr2 = [ 3, 5, 8 ];
*
* var validate = arraylikefcn( isOdd );
*
* var bool = validate( arr1 );
* // returns true
*
* bool = validate( arr2 );
* // returns false
*/

/**
* Returns a getter function for arrays having a specified number of dimensions.
*
* @private
* @param {PositiveInteger} ndims - array dimensions
* @param {StringArray} mode - specifies how to handle indices which exceed array dimensions
* @returns {Function} getter
*
* @example
* var f = get( 3 );
* // returns <Function>
*/

/**
* Returns a getter function for arrays having a specified number of dimensions.
*
* @private
* @param {PositiveInteger} ndims - array dimensions
* @returns {Function} getter
*
* @example
* var f = get( 3 );
* // returns <Function>
*/

/**
* Returns a hash of functions for copying typed arrays.
*
* @private
* @returns {Object} function hash
*/

/**
* Returns a linear congruential pseudorandom number generator (LCG) whose output is shuffled.
*
* @param {Options} [options] - options
* @param {PRNGSeedMINSTD} [options.seed] - pseudorandom number generator seed
* @param {PRNGStateMINSTD} [options.state] - pseudorandom number generator state
* @param {boolean} [options.copy=true] - boolean indicating whether to copy a provided pseudorandom number generator state
* @throws {TypeError} options argument must be an object
* @throws {TypeError} a seed must be either a positive integer less than the maximum signed 32-bit integer or an array-like object containing integers less than the maximum signed 32-bit integer
* @throws {RangeError} a numeric seed must be a positive integer less than the maximum signed 32-bit integer
* @throws {TypeError} state must be an `Int32Array`
* @throws {Error} must provide a valid state
* @throws {TypeError} `copy` option must be a boolean
* @returns {PRNG} shuffled LCG PRNG
*
* @example
* var minstd = factory();
*
* var v = minstd();
* // returns <number>
*
* @example
* // Return a seeded LCG:
* var minstd = factory({
*     'seed': 1234
* });
*
* var v = minstd();
* // returns 1421600654
*/

/**
* Returns a list of English stop words.
*
* @returns {StringArray} stop words
*
* @example
* var list = stopwords();
* // returns [ 'a', 'about', 'above', 'across', 'actually', ... ]
*/

/**
* Returns a list of ndarray casting modes.
*
* @returns {StringArray} list of ndarray casting modes
*
* @example
* var list = modes();
* // returns [ 'none', 'equiv', 'safe', 'same-kind', 'unsafe' ]
*/

/**
* Returns a list of ndarray data types to which a provided ndarray data type can be safely cast or cast within the same "kind".
*
* @param {string} [dtype] - ndarray data type
* @returns {(Object|StringArray|null)} list of ndarray data types or null
*
* @example
* var list = sameKindCasts( 'float32' );
* // returns [...]
*/

/**
* Returns a list of ndarray data types to which a provided ndarray data type can be safely cast.
*
* @param {string} [dtype] - ndarray data type
* @returns {(Object|StringArray|null)} list of ndarray data types or null
*
* @example
* var list = safeCasts( 'float32' );
* // returns [...]
*/

/**
* Returns a list of ndarray data types.
*
* @returns {StringArray} list of ndarray data types
*
* @example
* var list = dtypes();
* // returns [...]
*/

/**
* Returns a list of ndarray index modes.
*
* @returns {StringArray} list of ndarray index modes
*
* @example
* var list = modes();
* // returns [ 'throw', 'clamp', 'wrap' ]
*/

/**
* Returns a list of ndarray orders.
*
* @returns {StringArray} list of ndarray orders
*
* @example
* var list = orders();
* // returns [ 'row-major', 'column-major' ]
*/

/**
* Returns a matrix.
*
* @private
* @param {PositiveInteger} m - number of rows
* @param {PositiveInteger} n - number of columns
* @param {boolean} bool - boolean indicating whether to create a low-level ndarray
* @returns {ndarray} matrix
*/

/**
* Returns a memoized ndarray constructor.
*
* @param {string} dtype - data type
* @param {PositiveInteger} ndims - number of dimensions
* @param {Options} [options] - function options
* @param {boolean} [options.codegen=true] - boolean indicating whether to use code generation
* @param {string} [options.mode="throw"] - specifies how to handle indices which exceed array dimensions
* @param {StringArray} [options.submode=["throw"]] - specifies how to handle subscripts which exceed array dimensions on a per dimension basis
* @throws {TypeError} first argument must be a supported ndarray data type
* @throws {TypeError} second argument must be a number having a positive integer value
* @throws {TypeError} options argument must be an object
* @throws {TypeError} must provide valid options
* @returns {Function} memoized ndarray constructor
*
* @example
* var f1 = ctor( 'float64', 3 );
* // returns <Function>
*
* var f2 = ctor( 'float64', 3 );
* // returns <Function>
*
* var bool = ( f1 === f2 );
* // returns true
*
* var buffer = [ 1, 2, 3, 4, 5, 6 ];
* var shape = [ 3, 2 ];
* var strides = [ 2, 1 ];
* var offset = 0;
*
* var out = f1( buffer, shape, strides, offset, 'row-major' );
*/

/**
* Returns a memoized ndarray constructor.
*
* @param {string} dtype - data type
* @param {PositiveInteger} ndims - number of dimensions
* @param {Options} [options] - function options
* @param {boolean} [options.codegen=true] - boolean indicating whether to use code generation
* @returns {Function} memoized ndarray constructor
*
* @example
* var f1 = ctor( 'float64', 3 );
* // returns <Function>
*
* var f2 = ctor( 'float64', 3 );
* // returns <Function>
*
* var bool = ( f1 === f2 );
* // returns true
*
* var buffer = [ 1, 2, 3, 4, 5, 6 ];
* var shape = [ 3, 2 ];
* var strides = [ 2, 1 ];
* var offset = 0;
*
* var out = f1( buffer, shape, strides, offset, 'row-major' );
*/

/**
* Returns a method for getting an array element located at a specified linear index.
*
* @private
* @param {Function} base - parent (super) method
* @param {string} mode - specifies how to handle indices which exceed array dimensions
* @returns {Function} method for getting an array element
*/

/**
* Returns a method for returning an array element.
*
* @private
* @param {StringArray} mode - specifies how to handle indices which exceed array dimensions
* @returns {Function} method for returning an array element
*/

/**
* Returns a method for setting an array element located at a specified linear index.
*
* @private
* @param {Function} base - parent (super) method
* @param {string} mode - specifies how to handle indices which exceed array dimensions
* @returns {Function} method for setting an array element
*/

/**
* Returns a method for setting an array element.
*
* @private
* @param {StringArray} mode - specifies how to handle indices which exceed array dimensions
* @returns {Function} method for setting an array element
*/

/**
* Returns a method to return an array element.
*
* @private
* @param {PositiveInteger} ndims - number of dimensions
* @param {boolean} codegen - boolean indicating whether to use code generation
* @param {StringArray} mode - specifies how to handle indices which exceed array dimensions
* @returns {Function} method to return an array element
*/

/**
* Returns a method to set an array element.
*
* @private
* @param {PositiveInteger} ndims - number of dimensions
* @param {boolean} codegen - boolean indicating whether to use code generation
* @param {StringArray} mode - specifies how to handle indices which exceed array dimensions
* @returns {Function} method to set an array element
*/

/**
* Returns a multidimensional array.
*
* @param {(ArrayLikeObject|TypedArrayLike|Buffer|ndarrayLike)} [buffer] - data source
* @param {Options} [options] - function options
* @param {(ArrayLikeObject|TypedArrayLike|Buffer|ndarrayLike)} [options.buffer] - data source
* @param {string} [options.dtype="float64"] - underlying storage data type (if the input data is not of the same type, this option specifies the data type to which to cast the input data)
* @param {string} [options.order="row-major"] - specifies the memory layout of the array as either row-major (C-style) or column-major (Fortran-style)
* @param {NonNegativeIntegerArray} [options.shape] - array shape
* @param {boolean} [options.codegen=true] - boolean indicating whether to use code generation
* @param {string} [options.mode="throw"] - specifies how to handle indices which exceed array dimensions
* @param {StringArray} [options.submode=["throw"]] - specifies how to handle subscripts which exceed array dimensions on a per dimension basis
* @param {boolean} [options.copy=false] - boolean indicating whether to copy source data to a new data buffer
* @param {boolean} [options.flatten=true] - boolean indicating whether to automatically flatten generic array data sources
* @param {NonNegativeInteger} [options.ndmin=0] - minimum number of dimensions
* @param {string} [options.casting="safe"] - casting rule used to determine what constitutes an acceptable cast
* @throws {TypeError} options argument must be an object
* @throws {TypeError} must provide valid options
* @throws {Error} must provide either an array shape, data source, or both
* @throws {Error} invalid cast
* @throws {RangeError} data source must be compatible with specified meta data
* @returns {ndarray} ndarray instance
*
* @example
* var arr = array( [ [ 1, 2 ], [ 3, 4 ] ] );
* // returns <ndarray>
*
* var v = arr.get( 0, 0 );
* // returns 1
*
* @example
* var opts = {
*     'dtype': 'generic',
*     'flatten': false
* };
*
* var arr = array( [ [ 1, 2 ], [ 3, 4 ] ], opts );
* // returns <ndarray>
*
* var v = arr.get( 0 );
* // returns [ 1, 2 ]
*
* @example
* var Float64Array = require( '@stdlib/array/float64' );
*
* var opts = {
*     'shape': [ 2, 2 ]
* };
*
* var arr = array( new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] ), opts );
* // returns <ndarray>
*
* var v = arr.get( 0, 0 );
* // returns 1.0
*/

/**
* Returns a property descriptor for an object's own property.
*
* ## Notes
*
* -   In contrast to the built-in `Object.getOwnPropertyDescriptor()`, this function returns `null` if provided `undefined` or `null`, rather than throwing an error.
* -   In contrast to the built-in `Object.getOwnPropertyDescriptor()`, this function returns `null` if an object does not have a provided property, rather than `undefined`.
*
* @private
* @param {*} value - input object
* @param {(string|symbol)} property - property
* @returns {(Object|null)} property descriptor or null
*
* @example
* var obj = {
*     'beep': 'boop',
*     'foo': 3.14
* };
*
* var desc = getOwnPropertyDescriptor( obj, 'foo' );
* // returns {'configurable':true,'enumerable':true,'writable':true,'value':3.14}
*/

/**
* Returns a property descriptor for an object's own property.
*
* ## Notes
*
* -   In contrast to the built-in `Object.getOwnPropertyDescriptor()`, this function returns `null` if provided `undefined` or `null`, rather than throwing an error.
* -   In contrast to the built-in `Object.getOwnPropertyDescriptor()`, this function returns `null` if an object does not have a provided property, rather than `undefined`.
* -   In environments lacking `Object.getOwnPropertyDescriptor()` support, property descriptors do not exist. In non-supporting environment, if an object has a provided property, this function returns a descriptor object equivalent to that returned in a supporting environment; otherwise, the function returns `null`.
*
* @private
* @param {*} value - input object
* @param {(string|symbol)} property - property
* @returns {(Object|null)} property descriptor or null
*
* @example
* var obj = {
*     'beep': 'boop',
*     'foo': 3.14
* };
*
* var desc = getOwnPropertyDescriptor( obj, 'foo' );
* // returns {'configurable':true,'enumerable':true,'writable':true,'value':3.14}
*/

/**
* Returns a pseudorandom integer on the interval \\([1, 2^{31}-1)\\).
*
* @private
* @returns {PositiveInteger} pseudorandom integer
*
* @example
* var v = randint32();
* // returns <number>
*/

/**
* Returns a pseudorandom integer on the interval \\([1, 2^{32}-1)\\).
*
* @private
* @returns {PositiveInteger} pseudorandom integer
*
* @example
* var v = randuint32();
* // returns <number>
*/

/**
* Returns a pseudorandom number drawn from a discrete uniform distribution with minimum support `a` and maximum support `b`.
*
* ## Method
*
* -   Let \\( R \\) be a pseudorandom generator (PRNG) which yields integers on the interval \\( \[ A, B ] \\).
*
* -   If \\( a = b \\), then \\( rv = a \\).
*
* -   Let \\( r1 = b - a \\) and \\( r2 = B - A \\). If \\( r2 = r1 \\) (likely a rare occurrence), then
*
*     ```tex
*     rv = ( R() - B ) + a
*     ```
*
*     where, for real integer types, operation order is important in order to avoid overflow.
*
* -   If \\( r2 < r1 \\), use rejection sampling to map random variates from \\( R \\) to a larger domain (e.g., \\( {0,1,2,3} \rightarrow {0,1,2,3,4} \\)). For real integer types (and floating-point integer values), we must take extra care to avoid overflow. During sampling, the following conditions will hold:
*
*     -   First, consider the post-condition: \\( \textrm{result} \leq r2 \\), thus avoiding overflow.
*
*     -   Begin with definition of \\( \textrm{limit} \\)
*
*         ```tex
*         \textrm{limit} = \lfloor{\frac{r2+1}{r1+1}\rfloor
*         ```
*
*         thus,
*
*         ```tex
*         \textrm{limit}\ \cdot (r1+1) \leq r2+1
*         ```
*
*     -   Let \\( m \\) be a random factor where the loop condition is defined as
*
*         ```tex
*         m \leq \textrm{limit}
*         ```
*
*     -   Let \\( \textrm{result} \\) be the generator output, which is expressed base \\( r2+1 \\) and obeys the loop invariant \\( \textrm{result} < m \\).
*
*     -   Let \\( rv \\) be a realization of the PRNG. Then,
*
*         ```tex
*         rv-A \leq r1
*         ```
*
*         and, by the loop condition, \\( m \leq \textrm{limit} \\).
*
*     -   Therefore,
*
*         ```tex
*         m \cdot (rv - A + 1) \leq r2+1
*         ```
*
*     -   Rearranging terms,
*
*         ```tex
*         m + m \cdot (rv - A) \leq r2+1
*         ```
*
*     -   Since \\( \textrm{result} < m \\),
*
*         ```tex
*         \textrm{result} + m \cdot (rv - A) < r2+1
*         ```
*
*     -   Next, consider the post-condition: \\( \textrm{result} < m \cdot (r2+1) \\).
*
*     -   Since \\( \textrm{result} < m \\) and \\( rv - A \leq r1 \\),
*
*         ```tex
*         \textrm{result} + m \cdot (rv - A) < m + m \cdot (rv - A)
*         ```
*
*     -   Therefore,
*
*         ```tex
*         \textrm{result} + m \cdot (rv - A) < m + m \cdot r1
*         ```
*
*     -   Therefore,
*
*         ```tex
*         \textrm{result} + m \cdot (rv - A) < m \cdot (r1+1)
*         ```
*
*     -   Next, consider the post-condition: \\( m \leq r2 \\).
*
*     -   According to the definition of \\( \textrm{limit} \\) and the loop condition \\( m \leq \textrm{limit} \\),
*
*         ```tex
*         m \cdot (r1+1) \leq r2+1
*         ```
*
*     -   If \\( r2 \\) is **not** an integer power of the generator range \\( r1 \\), i.e.,
*
*         ```tex
*         m \cdot (r1+1) \neq r2+1
*         ```
*
*         then
*
*         ```tex
*         m \cdot (r1+1) < r2+1
*         ```
*
*     -   Thus, \\( \textrm{result} < m \\).
*
*     -   Next, consider the post-condition: \\( r2/m < r1+1 \\).
*
*     -   To show this is true, let us try to prove its opposite. Given the loop condition \\( m > \textrm{limit} \\), assume
*
*         ```tex
*         r2/m > r1+1
*         ```
*
*     -   Accordingly,
*
*         ```tex
*         r2 \geq m \cdot (r1+1)
*         ```
*
*     -   Hence,
*
*         ```tex
*         r2+1 > m \cdot (r1+1)
*         ```
*
*     -   Using the loop condition,
*
*         ```tex
*         r2+1 > (\textrm{limit}+1) \cdot (r1+1)
*         ```
*
*     -   Rearranging terms,
*
*         ```tex
*         \frac{r2+1}{r1+1} > \textrm{limit} + 1
*         ```
*
*     -   Hence,
*
*         ```tex
*         \textrm{limit} < \lfloor{\frac{r2+1}{r1+1}} \rfloor
*         ```
*
*     -   But the definition of \\( \textrm{limit} \\) is
*
*         ```tex
*         \textrm{limit} = \lfloor{\frac{r2+1}{r1+1}}
*         ```
*
*     -   Thus, our assumption cannot be true, providing the post-condition by reductio ad absurdum.
*
*     -   Next, consider the post-condition
*
*         ```tex
*         r2 \leq \frac{r2}{m} \cdot m + (m - 1)
*         ```
*
*     -   Recall the identity
*
*         ```tex
*         r2 = \frac{r2}{m} \cdot m + r2 \mod m
*         ```
*
*     -   By the definition of the modulus
*
*         ```tex
*         r2 \mod m < m
*         ```
*
*     -   Therefore,
*
*         ```tex
*         r2 < \frac{r2}{m} \cdot m + m
*         ```
*
*     -   Hence,
*
*         ```tex
*         r2 \leq \frac{r2}{m} \cdot m + (m - 1)
*         ```
*
*     At this point, the maximum value \\( \textrm{result} \\) is \\( m-1 \\). Hence, we can generate numbers that can be at least as large as \\( r2 \\), but we must be careful to avoid overflow during addition and in the sampling rejection. Anything which overflows is larger than \\( r2 \\) and can thus be rejected.
*
* -   If \\( r1 > r2 \\), use rejection sampling to map random variates from \\( R \\) to a smaller domain (e.g., \\( {0,1,2,3,4} \rightarrow {0,1,2,3} \\)) by defining "buckets" in which multiple random variates in \\( R \\) map to a single random variate in the smaller domain. We are safe in adding 1 to \\( r2 \\); however, we need to be careful to not cause overflow when adding 1 to \\( r1 \\).
*
* @name discreteUniform
* @type {PRNG}
* @param {integer} a - minimum support
* @param {integer} b - maximum support
* @returns {integer} pseudorandom number
*
* @example
* var v = discreteUniform( 1, 10 );
* // returns <number>
*/

/**
* Returns a pseudorandom number drawn from a discrete uniform distribution with minimum support `a` and maximum support `b`.
*
* @private
* @param {PRNG} rand - pseudorandom number generator which outputs integer values
* @param {integer} a - minimum support
* @param {integer} b - maximum support
* @returns {integer} pseudorandom number
*/

/**
* Returns a pseudorandom number generator for generating random numbers draw from a discrete uniform distribution.
*
* @param {integer} [a] - minimum support
* @param {integer} [b] - maximum support
* @param {Options} [options] - function options
* @param {PRNG} [options.prng] - pseudorandom number generator which generates uniformly distributed pseudorandom integers
* @param {PRNGSeedMT19937} [options.seed] - pseudorandom number generator seed
* @param {PRNGStateMT19937} [options.state] - pseudorandom number generator state
* @param {boolean} [options.copy=true] - boolean indicating whether to copy a provided pseudorandom number generator state
* @throws {TypeError} `a` must be an integer
* @throws {TypeError} `b` must be an integer
* @throws {RangeError} `a` must be less than `b`
* @throws {TypeError} options argument must be an object
* @throws {TypeError} must provide valid options
* @throws {TypeError} provided PRNG must have a valid `MIN` property
* @throws {TypeError} provided PRNG must have a valid `MAX` property
* @throws {Error} must provide a valid state
* @returns {PRNG} pseudorandom number generator
*
* @example
* var discreteUniform = factory( 1, 10 );
* var v = discreteUniform();
* // returns <number>
*
* @example
* var discreteUniform = factory( -30, -1, {
*     'seed': 297
* });
* var v = discreteUniform();
* // returns <number>
*/

/**
* Returns a results object.
*
* @private
* @param {PositiveInteger} k - number of clusters
* @param {PositiveInteger} ndims - number of dimensions
* @returns {Object} results object
*/

/**
* Returns a setter function for arrays having a specified number of dimensions.
*
* @private
* @param {PositiveInteger} ndims - array dimensions
* @param {StringArray} mode - specifies how to handle indices which exceed array dimensions
* @returns {Function} setter
*
* @example
* var f = set( 3 );
* // returns <Function>
*/

/**
* Returns a setter function for arrays having a specified number of dimensions.
*
* @private
* @param {PositiveInteger} ndims - array dimensions
* @returns {Function} setter
*
* @example
* var f = set( 3 );
* // returns <Function>
*/

/**
* Returns a string value indicating a specification defined classification (via the internal property `[[Class]]`) of an object.
*
* @param {*} v - input value
* @returns {string} string value indicating a specification defined classification of the input value
*
* @example
* var str = nativeClass( 'a' );
* // returns '[object String]'
*
* @example
* var str = nativeClass( 5 );
* // returns '[object Number]'
*
* @example
* function Beep() {
*     return this;
* }
* var str = nativeClass( new Beep() );
* // returns '[object Object]'
*/

/**
* Returns a string value indicating a specification defined classification of an object in environments supporting `Symbol.toStringTag`.
*
* @param {*} v - input value
* @returns {string} string value indicating a specification defined classification of the input value
*
* @example
* var str = nativeClass( 'a' );
* // returns '[object String]'
*
* @example
* var str = nativeClass( 5 );
* // returns '[object Number]'
*
* @example
* function Beep() {
*     return this;
* }
* var str = nativeClass( new Beep() );
* // returns '[object Object]'
*/

/**
* Returns a vector.
*
* @private
* @param {PositiveInteger} N - number of elements
* @param {boolean} bool - boolean indicating whether to create a low-level ndarray
* @returns {ndarray} vector
*/

/**
* Returns a zero-filled contiguous linear ndarray data buffer.
*
* @param {string} dtype - data type
* @param {NonNegativeInteger} size - buffer size
* @returns {(Array|TypedArray|Buffer)|null} data buffer
*
* @example
* var buf = buffer( 'float64', 3 );
* // returns <Float64Array>[ 0.0, 0.0, 0.0 ]
*/

/**
* Returns an accumulator for computing cluster statistics.
*
* @private
* @param {ndarray} out - matrix for storing cluster statistics
* @param {PositiveInteger} k - number of clusters
* @returns {Function} accumulator
*/

/**
* Returns an accumulator function which incrementally computes an arithmetic mean and corrected sample standard deviation.
*
* ## Method
*
* -   This implementation uses [Welford's method][algorithms-variance] for efficient computation, which can be derived as follows. Let
*
*     ```tex
*     \begin{align*}
*     S_n &= n \sigma_n^2 \\
*         &= \sum_{i=1}^{n} (x_i - \mu_n)^2 \\
*         &= \biggl(\sum_{i=1}^{n} x_i^2 \biggr) - n\mu_n^2
*     \end{align*}
*     ```
*
*     Accordingly,
*
*     ```tex
*     \begin{align*}
*     S_n - S_{n-1} &= \sum_{i=1}^{n} x_i^2 - n\mu_n^2 - \sum_{i=1}^{n-1} x_i^2 + (n-1)\mu_{n-1}^2 \\
*                   &= x_n^2 - n\mu_n^2 + (n-1)\mu_{n-1}^2 \\
*                   &= x_n^2 - \mu_{n-1}^2 + n(\mu_{n-1}^2 - \mu_n^2) \\
*                   &= x_n^2 - \mu_{n-1}^2 + n(\mu_{n-1} - \mu_n)(\mu_{n-1} + \mu_n) \\
*                   &= x_n^2 - \mu_{n-1}^2 + (\mu_{n-1} - x_n)(\mu_{n-1} + \mu_n) \\
*                   &= x_n^2 - \mu_{n-1}^2 + \mu_{n-1}^2 - x_n\mu_n - x_n\mu_{n-1} + \mu_n\mu_{n-1} \\
*                   &= x_n^2 - x_n\mu_n - x_n\mu_{n-1} + \mu_n\mu_{n-1} \\
*                   &= (x_n - \mu_{n-1})(x_n - \mu_n) \\
*                   &= S_{n-1} + (x_n - \mu_{n-1})(x_n - \mu_n)
*     \end{align*}
*     ```
*
*     where we use the identity
*
*     ```tex
*     x_n - \mu_{n-1} = n (\mu_n - \mu_{n-1})
*     ```
*
* [algorithms-variance]: https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance
*
* @param {ArrayLikeObject} [out] - output array
* @throws {TypeError} output argument must be array-like
* @returns {Function} accumulator function
*
* @example
* var accumulator = incrmeanstdev();
*
* var ms = accumulator();
* // returns null
*
* ms = accumulator( 2.0 );
* // returns [ 2.0, 0.0 ]
*
* ms = accumulator( -5.0 );
* // returns [ -1.5, ~4.95 ]
*
* ms = accumulator( 3.0 );
* // returns [ 0.0, ~4.36 ]
*
* ms = accumulator( 5.0 );
* // returns [ 1.25, ~4.35 ]
*
* ms = accumulator();
* // returns [ 1.25, ~4.35 ]
*/

/**
* Returns an accumulator function which incrementally computes an arithmetic mean.
*
* ## Method
*
* -   This implementation uses [Welford's method][algorithms-variance] for efficient computation, which can be derived as follows
*
*     ```tex
*     \begin{align*}
*     \mu_n &= \frac{1}{n} \sum_{i=0}^{n-1} x_i \\
*           &= \frac{1}{n} \biggl(x_{n-1} + \sum_{i=0}^{n-2} x_i \biggr) \\
*           &= \frac{1}{n} (x_{n-1} + (n-1)\mu_{n-1}) \\
*           &= \mu_{n-1} + \frac{1}{n} (x_{n-1} - \mu_{n-1})
*     \end{align*}
*     ```
*
* [algorithms-variance]: https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance
*
* @returns {Function} accumulator function
*
* @example
* var accumulator = incrmean();
*
* var mu = accumulator();
* // returns null
*
* mu = accumulator( 2.0 );
* // returns 2.0
*
* mu = accumulator( -5.0 );
* // returns -1.5
*
* mu = accumulator();
* // returns -1.5
*/

/**
* Returns an accumulator function which incrementally partitions data into `k` clusters.
*
* @param {(PositiveInteger|ndarray)} k - number of clusters or a `k x ndims` matrix containing initial centroids
* @param {PositiveInteger} [ndims] - number of dimensions (should only be provided if provided a numeric `k` argument)
* @param {Options} [options] - function options
* @param {string} [options.metric="euclidean"] - distance metric
* @param {ArrayLikeObject} [options.init] - method for determining initial centroids
* @param {boolean} [options.normalize=true] - boolean indicating whether to normalize incoming data (only relevant for non-Euclidean distance metrics)
* @param {boolean} [options.copy=true] - boolean indicating whether to copy incoming data to prevent mutation during normalization
* @param {*} [options.seed] - PRNG seed
* @throws {TypeError} first argument must be a positive integer
* @throws {TypeError} second argument must be a positive integer
* @throws {TypeError} options argument must be an object
* @throws {TypeError} must provide valid options
* @throws {RangeError} when using sampling to generate initial centroids, the sample size must be greater than or equal to the number of clusters
* @returns {Function} accumulator function
*
* @example
* var Float64Array = require( '@stdlib/array/float64' );
* var ctor = require( '@stdlib/ndarray/ctor' );
*
* var vector = ctor( 'float64', 1 );
* var matrix = ctor( 'float64', 2 );
*
* // Define initial centroid locations:
* var buffer = [
*     0.0, 0.0,
*     1.0, 1.0,
*     1.0, -1.0,
*     -1.0, -1.0,
*     -1.0, 1.0
* ];
* var shape = [ 5, 2 ];
* var strides = [ 2, 1 ];
* var offset = 0;
* var order = 'row-major';
*
* var centroids = matrix( buffer, shape, strides, offset, order );
*
* // Create a k-means accumulator:
* var accumulator = incrkmeans( centroids );
*
* var out = accumulator();
* // returns {...}
*
* // Create a data vector:
* buffer = new Float64Array( 2 );
* shape = [ 2 ];
* strides = [ 1 ];
*
* var vec = vector( buffer, shape, strides, offset, order );
*
* // Provide data to the accumulator:
* vec.set( 0, 2.0 );
* vec.set( 1, 1.0 );
*
* out = accumulator( vec );
* // returns {...}
*
* vec.set( 0, -5.0 );
* vec.set( 1, 3.14 );
*
* out = accumulator( vec );
* // returns {...}
*
* // Retrieve the current cluster results:
* out = accumulator();
* // returns {...}
*/

/**
* Returns an array element located a specified linear view index.
*
* @private
* @param {integer} idx - linear view index
* @returns {*} array element
*/

/**
* Returns an array element.
*
* @private
* @param {...integer} idx - indices
* @returns {*} array element
*/

/**
* Returns an array of an object's own enumerable and non-enumerable property names.
*
* ## Notes
*
* -   In contrast to the built-in `Object.getOwnPropertyNames()`, this function returns an empty array if provided `undefined` or `null`, rather than throwing an error.
*
* @private
* @param {*} value - input object
* @returns {Array} a list of own property names
*
* @example
* var obj = {
*     'beep': 'boop',
*     'foo': 3.14
* };
*
* var keys = getOwnPropertyNames( obj );
* // e.g., returns [ 'beep', 'foo' ]
*/

/**
* Returns an array of an object's own enumerable and non-enumerable property names.
*
* ## Notes
*
* -   In contrast to the built-in `Object.getOwnPropertyNames()`, this function returns an empty array if provided `undefined` or `null`, rather than throwing an error.
* -   In environments lacking support for `Object.getOwnPropertyNames()`, property descriptors are unavailable, and thus all properties can be safely assumed to be enumerable. Hence, we can defer to calling `Object.keys`, which retrieves all own enumerable property names.
*
* @private
* @param {*} value - input object
* @returns {Array} a list of own property names
*
* @example
* var obj = {
*     'beep': 'boop',
*     'foo': 3.14
* };
*
* var keys = getOwnPropertyNames( obj );
* // e.g., returns [ 'beep', 'foo' ]
*/

/**
* Returns an array of an object's own enumerable property names.
*
* ## Notes
*
* -   In contrast to the built-in `Object.keys()`, this function returns an empty array if provided `undefined` or `null`, rather than throwing an error.
*
* @private
* @param {*} value - input object
* @returns {Array} a list of own enumerable property names
*
* @example
* var obj = {
*     'beep': 'boop',
*     'foo': 3.14
* };
*
* var k = keys( obj );
* // e.g., returns [ 'beep', 'foo' ]
*/

/**
* Returns an array of an object's own enumerable property names.
*
* @private
* @param {*} value - input object
* @returns {Array} a list of own enumerable property names
*
* @example
* var obj = {
*     'beep': 'boop',
*     'foo': 3.14
* };
*
* var k = keys( obj );
* // e.g., returns [ 'beep', 'foo' ]
*/

/**
* Returns an index given an index mode.
*
* @param {integer} idx - index
* @param {NonNegativeInteger} max - maximum index
* @param {string} mode - specifies how to handle an index outside the interval `[0,max]`
* @throws {RangeError} index out-of-bounds
* @returns {integer} index
*
* @example
* var idx = ind( 2, 9, 'clamp' );
* // returns 2
*
* idx = ind( 10, 9, 'clamp' );
* // returns 9
*
* idx = ind( -1, 9, 'clamp' );
* // returns 0
*
* @example
* var idx = ind( 2, 9, 'wrap' );
* // returns 2
*
* idx = ind( 10, 9, 'wrap' );
* // returns 0
*
* idx = ind( -1, 9, 'wrap' );
* // returns 9
*
* @example
* var idx = ind( 2, 9, 'throw' );
* // returns 2
*
* idx = ind( 10, 9, 'throw' );
* // throws <RangeError>
*
* idx = ind( -1, 9, 'throw' );
* // throws <RangeError>
*/

/**
* Returns an initial PRNG state.
*
* @private
* @param {Uint32Array} state - state array
* @param {PositiveInteger} N - state size
* @param {uinteger32} s - seed
* @returns {Uint32Array} state array
*/

/**
* Returns an initialization accumulator for computing initial centroids.
*
* @private
* @param {ndarray} centroids - matrix for storing centroids
* @param {ndarray} stats - matrix for storing cluster statistics
* @param {Function} clusterstats - cluster statistics accumulator
* @param {(Function|void)} incrstats - mean vector accumulator
* @param {Function} dist - distance function
* @param {Options} opts - accumulator options
* @param {string} opts.metric - distance metric
* @param {Array} opts.init - initialization metric and associated parameters
* @param {boolean} opts.normalize - boolean indicating whether to normalize incoming data (only relevant for non-Euclidean distance metrics)
* @param {*} opts.seed - PRNG seed
* @returns {Function} accumulator
*/

/**
* Returns an ndarray constructor.
*
* @param {string} dtype - data type
* @param {PositiveInteger} ndims - number of dimensions
* @param {Options} [options] - function options
* @param {boolean} [options.codegen=true] - boolean indicating whether to use code generation
* @param {string} [options.mode="throw"] - specifies how to handle indices which exceed array dimensions
* @param {StringArray} [options.submode=["throw"]] - specifies how to handle subscripts which exceed array dimensions on a per dimension basis
* @throws {TypeError} first argument must be a supported ndarray data type
* @throws {TypeError} second argument must be a number having a positive integer value
* @throws {TypeError} options argument must be an object
* @throws {TypeError} must provide valid options
* @throws {RangeError} too many dimensions
* @returns {Function} ndarray constructor
*
* @example
* var ndarray = ctor( 'generic', 2 );
* // returns <Function>
*
* var buffer = [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ];
* var shape = [ 3, 2 ];
* var strides = [ 2, 1 ];
* var offset = 0;
*
* var out = ndarray( buffer, shape, strides, offset, 'row-major' );
*/

/**
* Returns an ndarray constructor.
*
* @param {string} dtype - data type
* @param {PositiveInteger} ndims - number of dimensions
* @param {Options} [options] - function options
* @param {boolean} [options.codegen=true] - boolean indicating whether to use code generation
* @returns {Function} ndarray constructor
*
* @example
* var ndarray = ctor( 'float64', 3 );
* // returns <Function>
*
* var buffer = [ 1, 2, 3, 4, 5, 6 ];
* var shape = [ 3, 2 ];
* var strides = [ 2, 1 ];
* var offset = 0;
*
* var out = ndarray( buffer, shape, strides, offset, 'row-major' );
*/

/**
* Returns an ndarray data buffer constructor.
*
* @param {string} dtype - data type
* @returns {(Function|null)} data buffer constructor or null
*
* @example
* var ctor = ctors( 'float64' );
* // returns <Function>
*
* @example
* var ctor = ctors( 'float' );
* // returns null
*/

/**
* Returns an unsigned 32-bit integer corresponding to the more significant 32 bits of a double-precision floating-point number.
*
* ## Notes
*
* ```text
* float64 (64 bits)
* f := fraction (significand/mantissa) (52 bits)
* e := exponent (11 bits)
* s := sign bit (1 bit)
*
* |-------- -------- -------- -------- -------- -------- -------- --------|
* |                                Float64                                |
* |-------- -------- -------- -------- -------- -------- -------- --------|
* |              Uint32               |               Uint32              |
* |-------- -------- -------- -------- -------- -------- -------- --------|
* ```
*
* If little endian (more significant bits last):
*
* ```text
*                         <-- lower      higher -->
* |   f7       f6       f5       f4       f3       f2    e2 | f1 |s|  e1  |
* ```
*
* If big endian (more significant bits first):
*
* ```text
*                         <-- higher      lower -->
* |s| e1    e2 | f1     f2       f3       f4       f5        f6      f7   |
* ```
*
* In which Uint32 can we find the higher order bits? If little endian, the second; if big endian, the first.
*
*
* ## References
*
* -   [Open Group][1]
*
* [1]: http://pubs.opengroup.org/onlinepubs/9629399/chap14.htm
*
* @param {number} x - input value
* @returns {uinteger32} higher order word
*
* @example
* var w = getHighWord( 3.14e201 ); // => 01101001110001001000001011000011
* // returns 1774486211
*/

/**
* Returns array iteration order.
*
* ## Notes
*
* -   Return value key:
*
*     -   `0`: unordered (i.e., strides of mixed sign; e.g., `[ 9, -3, 1 ]`)
*     -   `1`: ordered left-to-right (i.e., all nonnegative strides)
*     -   `-1`: ordered right-to-left (i.e., all negative strides)
*
* @param {IntegerArray} strides - stride array
* @returns {integer} iteration order
*
* @example
* var o = iterationOrder( [ 2, 1 ] );
* // returns 1
*
* o = iterationOrder( [ -2, 1 ] );
* // returns 0
*
* o = iterationOrder( [ -2, -1 ] );
* // returns -1
*/

/**
* Returns the data type of an ndarray data buffer.
*
* @param {*} value - input value
* @returns {(string|null)} data type
*
* @example
* var dt = dtype( [ 1, 2, 3 ] );
* // returns 'generic'
*
* var dt = dtype( 'beep' );
* // returns null
*/

/**
* Returns the first index at which a given element can be found.
*
* @param {ArrayLike} arr - array-like object
* @param {*} searchElement - element to find
* @param {integer} [fromIndex] - starting index (if negative, the start index is determined relative to last element)
* @throws {TypeError} must provide an array-like object
* @throws {TypeError} `fromIndex` must be an integer
* @returns {integer} index or -1
*
* @example
* var arr = [ 4, 3, 2, 1 ];
* var idx = indexOf( arr, 3 );
* // returns 1
*
* @example
* var arr = [ 4, 3, 2, 1 ];
* var idx = indexOf( arr, 5 );
* // returns -1
*
* @example
* // Using a `fromIndex`:
* var arr = [ 1, 2, 3, 4, 5, 2, 6 ];
* var idx = indexOf( arr, 2, 3 );
* // returns 5
*
* @example
* // `fromIndex` which exceeds `array` length:
* var arr = [ 1, 2, 3, 4, 2, 5 ];
* var idx = indexOf( arr, 2, 10 );
* // returns -1
*
* @example
* // Negative `fromIndex`:
* var arr = [ 1, 2, 3, 4, 5, 2, 6, 2 ];
* var idx = indexOf( arr, 2, -4 );
* // returns 5
*
* idx = indexOf( arr, 2, -1 );
* // returns 7
*
* @example
* // Negative `fromIndex` exceeding input `array` length:
* var arr = [ 1, 2, 3, 4, 5, 2, 6 ];
* var idx = indexOf( arr, 2, -10 );
* // returns 1
*
* @example
* // Array-like objects:
* var str = 'bebop';
* var idx = indexOf( str, 'o' );
* // returns 3
*/

/**
* Returns the global object using code generation.
*
* @private
* @returns {Object} global object
*/

/**
* Returns the global object.
*
* ## Notes
*
* -   Using code generation is the **most** reliable way to resolve the global object; however, doing so is likely to violate content security policies (CSPs) in, e.g., Chrome Apps and elsewhere.
*
* @param {boolean} [codegen=false] - boolean indicating whether to use code generation to resolve the global object
* @throws {TypeError} must provide a boolean
* @throws {Error} unable to resolve global object
* @returns {Object} global object
*
* @example
* var g = getGlobal();
* // returns {...}
*/

/**
* Returns the index offset which specifies the location of the first indexed value in a multidimensional array based on a stride array.
*
* @param {NonNegativeIntegerArray} shape - array shape
* @param {IntegerArray} strides - stride array
* @returns {NonNegativeInteger} offset - offset
*
* @example
* var shape = [ 2, 3, 10 ];
* var strides = [ 30, -10, 1 ];
*
* var offset = strides2offset( shape, strides );
* // returns 20
*/

/**
* Returns the maximum value.
*
* @param {number} [x] - first number
* @param {number} [y] - second number
* @param {...number} [args] - numbers
* @returns {number} maximum value
*
* @example
* var v = max( 3.14, 4.2 );
* // returns 4.2
*
* @example
* var v = max( 5.9, 3.14, 4.2 );
* // returns 5.9
*
* @example
* var v = max( 3.14, NaN );
* // returns NaN
*
* @example
* var v = max( +0.0, -0.0 );
* // returns +0.0
*/

/**
* Returns the name of a function.
*
* @param {Function} fcn - input function
* @throws {TypeError} must provide a function
* @returns {string} function name
*
* @example
* var v = functionName( Math.sqrt );
* // returns 'sqrt'
*
* @example
* var v = functionName( function foo(){} );
* // returns 'foo'
*
* @example
* var v = functionName( function(){} );
* // returns '' || 'anonymous'
*
* @example
* var v = functionName( String );
* // returns 'String'
*/

/**
* Returns the number of bytes per element provided an underlying array data type.
*
* @param {string} dtype - data type
* @returns {(NonNegativeInteger|null)} number of bytes per element
*
* @example
* var nbytes = bytesPerElement( 'float64' );
* // returns 8
*
* nbytes = bytesPerElement( 'generic' );
* // returns null
*/

/**
* Returns the number of elements in an array.
*
* @param {(NonNegativeIntegerArray|EmptyArray)} shape - array shape
* @returns {NonNegativeInteger} number of elements
*
* @example
* var n = numel( [ 3, 3, 3 ] );
* // returns 27
*/

/**
* Returns the prototype of a provided object.
*
* @param {*} value - input value
* @returns {(Object|null)} prototype
*
* @example
* var proto = getPrototypeOf( {} );
* // returns {}
*/

/**
* Returns the prototype of a provided object.
*
* @private
* @param {Object} obj - input object
* @returns {(Object|null)} prototype
*/

/**
* Returns the typed array type.
*
* @private
* @param {TypedArray} arr - typed array
* @returns {(string|void)} typed array type
*
* @example
* var Float64Array = require( '@stdlib/array/float64' );
*
* var arr = new Float64Array( 5 );
* var str = typeName( arr );
* // returns 'Float64Array'
*/

/**
* Returns the value of the `__proto__` property.
*
* @private
* @param {Object} obj - input object
* @returns {*} value of `__proto__` property
*/

/**
* Round a numeric value toward negative infinity.
*
* @module @stdlib/math/base/special/floor
*
* @example
* var floor = require( '@stdlib/math/base/special/floor' );
*
* var v = floor( -4.2 );
* // returns -5.0
*
* v = floor( 9.99999 );
* // returns 9.0
*
* v = floor( 0.0 );
* // returns 0.0
*
* v = floor( NaN );
* // returns NaN
*/

/**
* Rounds a numeric value toward negative infinity.
*
* @param {number} x - input value
* @returns {number} rounded value
*
* @example
* var v = floor( -4.2 );
* // returns -5.0
*
* @example
* var v = floor( 9.99999 );
* // returns 9.0
*
* @example
* var v = floor( 0.0 );
* // returns 0.0
*
* @example
* var v = floor( NaN );
* // returns NaN
*/

/**
* Sample elements from an array-like object.
*
* @module @stdlib/random/sample
*
* @example
* var sample = require( '@stdlib/random/sample' );
*
* var out = sample( 'abc' );
* // e.g., returns [ 'a', 'a', 'b' ]
*
* out = sample( [ 3, 6, 9 ] );
* // e.g., returns [ 3, 9, 6 ]
*
* var bool = ( out.length === 3 );
* // returns true
*
* @example
* var sample = require( '@stdlib/random/sample' );
*
* var mysample = sample.factory({
*     'seed': 323
* });
* var out = mysample( [ 3, 6, 9 ], {
*     'size': 10
* });
* // e.g., returns [ 3, 9, 3, 3, 3, 6, 3, 3, 3, 6 ]
*/

/**
* Samples elements from an array-like object.
*
* @name sample
* @type {Function}
* @param {ArrayLike} x - array-like object from which to sample
* @param {Options} [options] - function options
* @param {NonNegativeInteger} [options.size] - sample size
* @param {ProbabilityArray} [options.probs] - element probabilities
* @param {boolean} [options.replace=true] - boolean indicating whether to sample with replacement
* @throws {TypeError} first argument must be array-like
* @throws {TypeError} options argument must be an object
* @throws {TypeError} must provide valid options
* @throws {RangeError} `size` option must be less than or equal to the length of `x` when the `replace` option is `false`
* @returns {Array} sample
*
* @example
* var out = sample( [ 3, null, NaN, 'abc', function(){} ] );
* // e.g., returns [ 3, 'abc', null, 3, null ]
*/

/**
* Samples from a discrete uniform distribution (equal probabilities and with replacement).
*
* @private
* @param {ArrayLike} x - array-like object from which to sample
* @param {NonNegativeInteger} size - sample size
* @param {Function} rand - PRNG for generating uniformly distributed numbers
* @returns {Array} sample
*/

/**
* Samples uniformly without replacement using the Fisher-Yates shuffle.
*
* ## References
*
* -   Knuth, Donald E. 1997. _The Art of Computer Programming, Volume 2 (3rd Ed.): Seminumerical Algorithms_. Boston, MA, USA: Addison-Wesley Longman Publishing Co., Inc.
*
* @private
* @param {ArrayLike} x - array-like object from which to sample
* @param {NonNegativeInteger} size - sample size
* @param {Function} rand - PRNG for generating uniformly distributed numbers
* @returns {Array} sample
*/

/**
* Samples with replacement and non-uniform probabilities using Vose's [alias method][alias-method].
*
* ## References
*
* -   Vose, Michael D. 1991. "A linear algorithm for generating random numbers with a given distribution." _IEEE Transactions on Software Engineering_ 17 (9): 97275. doi:[10.1109/32.92917][@vose:1991].
*
* [alias-method]: http://keithschwarz.com/darts-dice-coins/
* [@vose:1991]: https://doi.org/10.1109/32.92917
*
*
* @private
* @param {ArrayLike} x - array-like object from which to sample
* @param {NonNegativeInteger} size - sample size
* @param {Function} rand - PRNG for generating uniformly distributed numbers
* @param {ProbabilityArray} probabilities - element probabilities
* @returns {Array} sample
*/

/**
* Samples without replacement from a discrete set using custom probabilities.
*
* ## Notes
*
* -   After each draw, the probabilities of the remaining observations are renormalized so that they sum to one.
*
*
* @private
* @param {ArrayLike} x - array-like object from which to sample
* @param {NonNegativeInteger} size - sample size
* @param {Function} rand - PRNG for generating uniformly distributed numbers
* @param {ProbabilityArray} probabilities - element probabilities
* @returns {Array} sample
*/

/**
* Serializes an ndarray as a JSON object.
*
* ## Notes
*
* -   The method does **not** serialize data outside of the buffer region defined by the array configuration.
*
* @private
* @returns {Object} JSON representation
*/

/**
* Serializes an ndarray as a string.
*
* ## Notes
*
* -   The method does **not** serialize data outside of the buffer region defined by the array configuration.
*
* @private
* @returns {string} string representation
*/

/**
* Set the more significant 32 bits of a double-precision floating-point number.
*
* @module @stdlib/number/float64/base/set-high-word
*
* @example
* var setHighWord = require( '@stdlib/number/float64/base/set-high-word' );
*
* var high = 5 >>> 0; // => 0 00000000000 00000000000000000101
*
* var y = setHighWord( 3.14e201, high ); // => 0 00000000000 0000000000000000010110010011110010110101100010000010
* // returns 1.18350528745e-313
*
* @example
* var setHighWord = require( '@stdlib/number/float64/base/set-high-word' );
* var PINF = require( '@stdlib/constants/math/float64-pinf' ); //  => 0 11111111111 00000000000000000000 00000000000000000000000000000000
*
* var high = 1072693248 >>> 0; // => 0 01111111111 00000000000000000000
*
* // Set the higher order bits of `+infinity` to return `1`:
* var y = setHighWord( PINF, high ); => 0 01111111111 0000000000000000000000000000000000000000000000000000
* // returns 1.0
*/

/**
* Sets an array element located a specified linear view index.
*
* @private
* @param {integer} idx - linear view index
* @param {*} v - value to set
* @returns {ndarray} ndarray instance
*/

/**
* Sets an array element.
*
* @private
* @param {...integer} idx - indices
* @param {*} v - value to set
* @returns {ndarray} ndarray instance
*/

/**
* Sets the more significant 32 bits of a double-precision floating-point number.
*
* ## Notes
*
* ```text
* float64 (64 bits)
* f := fraction (significand/mantissa) (52 bits)
* e := exponent (11 bits)
* s := sign bit (1 bit)
*
* |-------- -------- -------- -------- -------- -------- -------- --------|
* |                                Float64                                |
* |-------- -------- -------- -------- -------- -------- -------- --------|
* |              Uint32               |               Uint32              |
* |-------- -------- -------- -------- -------- -------- -------- --------|
* ```
*
* If little endian (more significant bits last):
*
* ```text
*                         <-- lower      higher -->
* |   f7       f6       f5       f4       f3       f2    e2 | f1 |s|  e1  |
* ```
*
* If big endian (more significant bits first):
*
* ```text
*                         <-- higher      lower -->
* |s| e1    e2 | f1     f2       f3       f4       f5        f6      f7   |
* ```
*
* In which Uint32 can we find the higher order bits? If little endian, the second; if big endian, the first.
*
*
* ## References
*
* -   [Open Group][1]
*
* [1]: http://pubs.opengroup.org/onlinepubs/9629399/chap14.htm
*
* @param {number} x - double
* @param {uinteger32} high - unsigned 32-bit integer to replace the higher order word of `x`
* @returns {number} double having the same lower order word as `x`
*
* @example
* var high = 5 >>> 0; // => 0 00000000000 00000000000000000101
*
* var y = setHighWord( 3.14e201, high ); //  => 0 00000000000 0000000000000000010110010011110010110101100010000010
* // returns 1.18350528745e-313
*
* @example
* var PINF = require( '@stdlib/constants/math/float64-pinf' ); // => 0 11111111111 00000000000000000000 00000000000000000000000000000000
*
* var high = 1072693248 >>> 0; // => 0 01111111111 00000000000000000000
*
* // Set the higher order bits of `+infinity` to return `1`:
* var y = setHighWord( PINF, high ); // => 0 01111111111 0000000000000000000000000000000000000000000000000000
* // returns 1.0
*/

/**
* Square root of double-precision floating-point epsilon.
*
* @module @stdlib/constants/math/float64-sqrt-eps
* @type {number}
*
* @example
* var FLOAT64_SQRT_EPSILON = require( '@stdlib/constants/math/float64-sqrt-eps' );
* // returns 0.14901161193847656e-7
*/

/**
* Square root of double-precision floating-point epsilon.
*
* ```tex
* \sqrt{\frac{1}{2^{52}}}
* ```
*
* @constant
* @type {number}
* @default 0.14901161193847656e-7
* @see [IEEE 754]{@link https://en.wikipedia.org/wiki/IEEE_754-1985}
* @see [Machine Epsilon]{@link https://en.wikipedia.org/wiki/Machine_epsilon}
*/

/**
* Test for `Object.defineProperty` support.
*
* @module @stdlib/assert/has-define-property-support
*
* @example
* var hasDefinePropertySupport = require( '@stdlib/assert/has-define-property-support' );
*
* var bool = hasDefinePropertySupport();
* // returns <boolean>
*/

/**
* Test for native `Buffer` support.
*
* @module @stdlib/assert/has-node-buffer-support
*
* @example
* var hasNodeBufferSupport = require( '@stdlib/assert/has-node-buffer-support' );
*
* var bool = hasNodeBufferSupport();
* // returns <boolean>
*/

/**
* Test for native `Float32Array` support.
*
* @module @stdlib/assert/has-float32array-support
*
* @example
* var hasFloat32ArraySupport = require( '@stdlib/assert/has-float32array-support' );
*
* var bool = hasFloat32ArraySupport();
* // returns <boolean>
*/

/**
* Test for native `Float64Array` support.
*
* @module @stdlib/assert/has-float64array-support
*
* @example
* var hasFloat64ArraySupport = require( '@stdlib/assert/has-float64array-support' );
*
* var bool = hasFloat64ArraySupport();
* // returns <boolean>
*/

/**
* Test for native `Int16Array` support.
*
* @module @stdlib/assert/has-int16array-support
*
* @example
* var hasInt16ArraySupport = require( '@stdlib/assert/has-int16array-support' );
*
* var bool = hasInt16ArraySupport();
* // returns <boolean>
*/

/**
* Test for native `Int32Array` support.
*
* @module @stdlib/assert/has-int32array-support
*
* @example
* var hasInt32ArraySupport = require( '@stdlib/assert/has-int32array-support' );
*
* var bool = hasInt32ArraySupport();
* // returns <boolean>
*/

/**
* Test for native `Int8Array` support.
*
* @module @stdlib/assert/has-int8array-support
*
* @example
* var hasInt8ArraySupport = require( '@stdlib/assert/has-int8array-support' );
*
* var bool = hasInt8ArraySupport();
* // returns <boolean>
*/

/**
* Test for native `Symbol` support.
*
* @module @stdlib/assert/has-symbol-support
*
* @example
* var hasSymbolSupport = require( '@stdlib/assert/has-symbol-support' );
*
* var bool = hasSymbolSupport();
* // returns <boolean>
*/

/**
* Test for native `Uint16Array` support.
*
* @module @stdlib/assert/has-uint16array-support
*
* @example
* var hasUint16ArraySupport = require( '@stdlib/assert/has-uint16array-support' );
*
* var bool = hasUint16ArraySupport();
* // returns <boolean>
*/

/**
* Test for native `Uint32Array` support.
*
* @module @stdlib/assert/has-uint32array-support
*
* @example
* var hasUint32ArraySupport = require( '@stdlib/assert/has-uint32array-support' );
*
* var bool = hasUint32ArraySupport();
* // returns <boolean>
*/

/**
* Test for native `Uint8Array` support.
*
* @module @stdlib/assert/has-uint8array-support
*
* @example
* var hasUint8ArraySupport = require( '@stdlib/assert/has-uint8array-support' );
*
* var bool = hasUint8ArraySupport();
* // returns <boolean>
*/

/**
* Test for native `Uint8ClampedArray` support.
*
* @module @stdlib/assert/has-uint8clampedarray-support
*
* @example
* var hasUint8ClampedArraySupport = require( '@stdlib/assert/has-uint8clampedarray-support' );
*
* var bool = hasUint8ClampedArraySupport();
* // returns <boolean>
*/

/**
* Test for native `toStringTag` support.
*
* @module @stdlib/assert/has-tostringtag-support
*
* @example
* var hasToStringTagSupport = require( '@stdlib/assert/has-tostringtag-support' );
*
* var bool = hasToStringTagSupport();
* // returns <boolean>
*/

/**
* Test for native function `name` support.
*
* @module @stdlib/assert/has-function-name-support
*
* @example
* var hasFunctionNameSupport = require( '@stdlib/assert/has-function-name-support' );
*
* var bool = hasFunctionNameSupport();
* // returns <boolean>
*/

/**
* Test if a finite double-precision floating-point number is an integer.
*
* @module @stdlib/math/base/assert/is-integer
*
* @example
* var isInteger = require( '@stdlib/math/base/assert/is-integer' );
*
* var bool = isInteger( 1.0 );
* // returns true
*
* bool = isInteger( 3.14 );
* // returns false
*/

/**
* Test if a numeric value is `NaN`.
*
* @module @stdlib/math/base/assert/is-nan
*
* @example
* var isnan = require( '@stdlib/math/base/assert/is-nan' );
*
* var bool = isnan( NaN );
* // returns true
*
* bool = isnan( 7.0 );
* // returns false
*/

/**
* Test if a numeric value is infinite.
*
* @module @stdlib/math/base/assert/is-infinite
*
* @example
* var isInfinite = require( '@stdlib/math/base/assert/is-infinite' );
*
* var bool = isInfinite( Infinity );
* // returns true
*
* bool = isInfinite( -Infinity );
* // returns true
*
* bool = isInfinite( 5.0 );
* // returns false
*
* bool = isInfinite( NaN );
* // returns false
*/

/**
* Test if a numeric value is positive zero.
*
* @module @stdlib/math/base/assert/is-positive-zero
*
* @example
* var isPositiveZero = require( '@stdlib/math/base/assert/is-positive-zero' );
*
* var bool = isPositiveZero( 0.0 );
* // returns true
*
* bool = isPositiveZero( -0.0 );
* // returns false
*/

/**
* Test if a value is `NaN`.
*
* @module @stdlib/assert/is-nan
*
* @example
* var isnan = require( '@stdlib/assert/is-nan' );
*
* var bool = isnan( NaN );
* // returns true
*
* bool = isnan( new Number( NaN ) );
* // returns true
*
* bool = isnan( 3.14 );
* // returns false
*
* bool = isnan( null );
* // returns false
*
* @example
* var isnan = require( '@stdlib/assert/is-nan' ).isPrimitive;
*
* var bool = isnan( NaN );
* // returns true
*
* bool = isnan( 3.14 );
* // returns false
*
* bool = isnan( new Number( NaN ) );
* // returns false
*
* @example
* var isnan = require( '@stdlib/assert/is-nan' ).isObject;
*
* var bool = isnan( NaN );
* // returns false
*
* bool = isnan( new Number( NaN ) );
* // returns true
*/

/**
* Test if a value is a 1-dimensional ndarray-like object.
*
* @module @stdlib/assert/is-vector-like
*
* @example
* var ctor = require( '@stdlib/ndarray/ctor' );
* var isVectorLike = require( '@stdlib/assert/is-vector-like' );
*
* var ndarray = ctor( 'generic', 1 );
*
* var arr = ndarray( [ 0, 0, 0, 0 ], [ 4 ], [ 1 ], 0, 'row-major' );
*
* var bool = isVectorLike( arr );
* // returns true
*
* bool = isVectorLike( [] );
* // returns false
*/

/**
* Test if a value is a 2-dimensional ndarray-like object.
*
* @module @stdlib/assert/is-matrix-like
*
* @example
* var ctor = require( '@stdlib/ndarray/ctor' );
* var isMatrixLike = require( '@stdlib/assert/is-matrix-like' );
*
* var ndarray = ctor( 'generic', 2 );
*
* var arr = ndarray( [ 0, 0, 0, 0 ], [ 2, 2 ], [ 2, 1 ], 0, 'row-major' );
*
* var bool = isMatrixLike( arr );
* // returns true
*
* bool = isMatrixLike( [] );
* // returns false
*/

/**
* Test if a value is a Buffer instance.
*
* @module @stdlib/assert/is-buffer
*
* @example
* var isBuffer = require( '@stdlib/assert/is-buffer' );
*
* var v = isBuffer( new Buffer( 'beep' ) );
* // returns true
*
* v = isBuffer( {} );
* // returns false
*/

/**
* Test if a value is a Float32Array.
*
* @module @stdlib/assert/is-float32array
*
* @example
* var isFloat32Array = require( '@stdlib/assert/is-float32array' );
*
* var bool = isFloat32Array( new Float32Array( 10 ) );
* // returns true
*
* bool = isFloat32Array( [] );
* // returns false
*/

/**
* Test if a value is a Float64Array.
*
* @module @stdlib/assert/is-float64array
*
* @example
* var isFloat64Array = require( '@stdlib/assert/is-float64array' );
*
* var bool = isFloat64Array( new Float64Array( 10 ) );
* // returns true
*
* bool = isFloat64Array( [] );
* // returns false
*/

/**
* Test if a value is a Uint16Array.
*
* @module @stdlib/assert/is-uint16array
*
* @example
* var isUint16Array = require( '@stdlib/assert/is-uint16array' );
*
* var bool = isUint16Array( new Uint16Array( 10 ) );
* // returns true
*
* bool = isUint16Array( [] );
* // returns false
*/

/**
* Test if a value is a Uint32Array.
*
* @module @stdlib/assert/is-uint32array
*
* @example
* var isUint32Array = require( '@stdlib/assert/is-uint32array' );
*
* var bool = isUint32Array( new Uint32Array( 10 ) );
* // returns true
*
* bool = isUint32Array( [] );
* // returns false
*/

/**
* Test if a value is a Uint8Array.
*
* @module @stdlib/assert/is-uint8array
*
* @example
* var isUint8Array = require( '@stdlib/assert/is-uint8array' );
*
* var bool = isUint8Array( new Uint8Array( 10 ) );
* // returns true
*
* bool = isUint8Array( [] );
* // returns false
*/

/**
* Test if a value is a Uint8ClampedArray.
*
* @module @stdlib/assert/is-uint8clampedarray
*
* @example
* var isUint8ClampedArray = require( '@stdlib/assert/is-uint8clampedarray' );
*
* var bool = isUint8ClampedArray( new Uint8ClampedArray( 10 ) );
* // returns true
*
* bool = isUint8ClampedArray( [] );
* // returns false
*/

/**
* Test if a value is a boolean.
*
* @module @stdlib/assert/is-boolean
*
* @example
* var isBoolean = require( '@stdlib/assert/is-boolean' );
*
* var bool = isBoolean( false );
* // returns true
*
* bool = isBoolean( new Boolean( false ) );
* // returns true
*
* @example
* // Use interface to check for boolean primitives...
* var isBoolean = require( '@stdlib/assert/is-boolean' ).isPrimitive;
*
* var bool = isBoolean( false );
* // returns true
*
* bool = isBoolean( new Boolean( true ) );
* // returns false
*
* @example
* // Use interface to check for boolean objects...
* var isBoolean = require( '@stdlib/assert/is-boolean' ).isObject;
*
* var bool = isBoolean( true );
* // returns false
*
* bool = isBoolean( new Boolean( false ) );
* // returns true
*/

/**
* Test if a value is a collection.
*
* @module @stdlib/assert/is-collection
*
* @example
* var isCollection = require( '@stdlib/assert/is-collection' );
*
* var bool = isCollection( [] );
* // returns true
*
* bool = isCollection( {} );
* // returns false
*/

/**
* Test if a value is a function.
*
* @module @stdlib/assert/is-function
*
* @example
* var isFunction = require( '@stdlib/assert/is-function' );
*
* function beep() {
*     return 'beep';
* }
*
* var bool = isFunction( beep );
* // returns true
*/

/**
* Test if a value is a nonnegative integer.
*
* @module @stdlib/assert/is-nonnegative-integer
*
* @example
* var isNonNegativeInteger = require( '@stdlib/assert/is-nonnegative-integer' );
*
* var bool = isNonNegativeInteger( 5.0 );
* // returns true
*
* bool = isNonNegativeInteger( new Number( 5.0 ) );
* // returns true
*
* bool = isNonNegativeInteger( -5.0 );
* // returns false
*
* bool = isNonNegativeInteger( 3.14 );
* // returns false
*
* bool = isNonNegativeInteger( null );
* // returns false
*
* @example
* var isNonNegativeInteger = require( '@stdlib/assert/is-nonnegative-integer' ).isPrimitive;
*
* var bool = isNonNegativeInteger( 3.0 );
* // returns true
*
* bool = isNonNegativeInteger( new Number( 3.0 ) );
* // returns false
*
* @example
* var isNonNegativeInteger = require( '@stdlib/assert/is-nonnegative-integer' ).isObject;
*
* var bool = isNonNegativeInteger( 3.0 );
* // returns false
*
* bool = isNonNegativeInteger( new Number( 3.0 ) );
* // returns true
*/

/**
* Test if a value is a number.
*
* @module @stdlib/assert/is-number
*
* @example
* var isNumber = require( '@stdlib/assert/is-number' );
*
* var bool = isNumber( 3.14 );
* // returns true
*
* bool = isNumber( new Number( 3.14 ) );
* // returns true
*
* bool = isNumber( NaN );
* // returns true
*
* bool = isNumber( null );
* // returns false
*
* @example
* var isNumber = require( '@stdlib/assert/is-number' ).isPrimitive;
*
* var bool = isNumber( 3.14 );
* // returns true
*
* bool = isNumber( NaN );
* // returns true
*
* bool = isNumber( new Number( 3.14 ) );
* // returns false
*
* @example
* var isNumber = require( '@stdlib/assert/is-number' ).isObject;
*
* var bool = isNumber( 3.14 );
* // returns false
*
* bool = isNumber( new Number( 3.14 ) );
* // returns true
*/

/**
* Test if a value is a plain object.
*
* @module @stdlib/assert/is-plain-object
*
* @example
* var isPlainObject = require( '@stdlib/assert/is-plain-object' );
*
* var bool = isPlainObject( {} );
* // returns true
*
* bool = isPlainObject( null );
* // returns false
*/

/**
* Test if a value is a positive integer.
*
* @module @stdlib/assert/is-positive-integer
*
* @example
* var isPositiveInteger = require( '@stdlib/assert/is-positive-integer' );
*
* var bool = isPositiveInteger( 5.0 );
* // returns true
*
* bool = isPositiveInteger( new Number( 5.0 ) );
* // returns true
*
* bool = isPositiveInteger( -5.0 );
* // returns false
*
* bool = isPositiveInteger( 3.14 );
* // returns false
*
* bool = isPositiveInteger( null );
* // returns false
*
* @example
* var isPositiveInteger = require( '@stdlib/assert/is-positive-integer' ).isPrimitive;
*
* var bool = isPositiveInteger( 3.0 );
* // returns true
*
* bool = isPositiveInteger( new Number( 3.0 ) );
* // returns false
*
* @example
* var isPositiveInteger = require( '@stdlib/assert/is-positive-integer' ).isObject;
*
* var bool = isPositiveInteger( 3.0 );
* // returns false
*
* bool = isPositiveInteger( new Number( 3.0 ) );
* // returns true
*/

/**
* Test if a value is a regular expression.
*
* @module @stdlib/assert/is-regexp
*
* @example
* var isRegExp = require( '@stdlib/assert/is-regexp' );
*
* var bool = isRegExp( /\.+/ );
* // returns true
*
* bool = isRegExp( {} );
* // returns false
*/

/**
* Test if a value is a string having an uppercase first character.
*
* @module @stdlib/assert/is-capitalized
*
* @example
* var isCapitalized = require( '@stdlib/assert/is-capitalized' );
*
* var bool = isCapitalized( 'Hello' );
* // returns true
*
* bool = isCapitalized( 'world' );
* // returns false
*/

/**
* Test if a value is a string.
*
* @module @stdlib/assert/is-string
*
* @example
* var isString = require( '@stdlib/assert/is-string' );
*
* var bool = isString( 'beep' );
* // returns true
*
* bool = isString( new String( 'beep' ) );
* // returns true
*
* bool = isString( 5 );
* // returns false
*
* @example
* var isString = require( '@stdlib/assert/is-string' ).isObject;
*
* var bool = isString( new String( 'beep' ) );
* // returns true
*
* bool = isString( 'beep' );
* // returns false
*
* @example
* var isString = require( '@stdlib/assert/is-string' ).isPrimitive;
*
* var bool = isString( 'beep' );
* // returns true
*
* bool = isString( new String( 'beep' ) );
* // returns false
*/

/**
* Test if a value is a typed array.
*
* @module @stdlib/assert/is-typed-array
*
* @example
* var Int8Array = require( '@stdlib/array/int8' );
* var isTypedArray = require( '@stdlib/assert/is-typed-array' );
*
* var bool = isTypedArray( new Int8Array( 10 ) );
* // returns true
*/

/**
* Test if a value is an Int16Array.
*
* @module @stdlib/assert/is-int16array
*
* @example
* var isInt16Array = require( '@stdlib/assert/is-int16array' );
*
* var bool = isInt16Array( new Int16Array( 10 ) );
* // returns true
*
* bool = isInt16Array( [] );
* // returns false
*/

/**
* Test if a value is an Int32Array.
*
* @module @stdlib/assert/is-int32array
*
* @example
* var isInt32Array = require( '@stdlib/assert/is-int32array' );
*
* var bool = isInt32Array( new Int32Array( 10 ) );
* // returns true
*
* bool = isInt32Array( [] );
* // returns false
*/

/**
* Test if a value is an Int8Array.
*
* @module @stdlib/assert/is-int8array
*
* @example
* var isInt8Array = require( '@stdlib/assert/is-int8array' );
*
* var bool = isInt8Array( new Int8Array( 10 ) );
* // returns true
*
* bool = isInt8Array( [] );
* // returns false
*/

/**
* Test if a value is an `Error` object.
*
* @module @stdlib/assert/is-error
*
* @example
* var isError = require( '@stdlib/assert/is-error' );
*
* var bool = isError( new Error( 'beep' ) );
* // returns true
*
* bool = isError( {} );
* // returns false
*/

/**
* Test if a value is an `arguments` object.
*
* @module @stdlib/assert/is-arguments
*
* @example
* var isArguments = require( '@stdlib/assert/is-arguments' );
*
* function foo() {
*     return arguments;
* }
*
* var bool = isArguments( foo() );
* // returns true
*
* bool = isArguments( [] );
* // returns false
*/

/**
* Test if a value is an array of probabilities that sum to one.
*
* @module @stdlib/assert/is-unity-probability-array
*
* @example
* var isUnityProbabilityArray = require( '@stdlib/assert/is-unity-probability-array' );
*
* var bool = isUnityProbabilityArray( [ 0.25, 0.5, 0.25 ] );
* // returns true
*
* bool = isUnityProbabilityArray( new Uint8Array( [ 0, 1 ] ) );
* // returns true
*
* bool = isUnityProbabilityArray( [ 0.4, 0.4, 0.4 ] );
* // returns false
*
* bool = isUnityProbabilityArray( [ 3.14, 0.0 ] );
* // returns false
*/

/**
* Test if a value is an array of strings.
*
* @module @stdlib/assert/is-string-array
*
* @example
* var isStringArray = require( '@stdlib/assert/is-string-array' );
*
* var bool = isStringArray( [ 'abc', 'def' ] );
* // returns true
*
* bool = isStringArray( [ 'abc', 123 ] );
* // returns false
*
* @example
* var isStringArray = require( '@stdlib/assert/is-string-array' ).primitives;
*
* var bool = isStringArray( [ 'abc', 'def' ] );
* // returns true
*
* bool = isStringArray( [ 'abc', new String( 'def' ) ] );
* // returns false
*
* @example
* var isStringArray = require( '@stdlib/assert/is-string-array' ).objects;
*
* var bool = isStringArray( [ new String( 'abc' ), new String( 'def' ) ] );
* // returns true
*
* bool = isStringArray( [ new String( 'abc' ), 'def' ] );
* // returns false
*/

/**
* Test if a value is an array-like object containing only integers.
*
* @module @stdlib/assert/is-integer-array
*
* @example
* var isIntegerArray = require( '@stdlib/assert/is-integer-array' );
*
* var bool = isIntegerArray( [ -3.0, new Number(0.0), 2.0 ] );
* // returns true
*
* bool = isIntegerArray( [ -3.0, '3.0' ] );
* // returns false
*
* @example
* var isIntegerArray = require( '@stdlib/assert/is-integer-array' ).primitives;
*
* var bool = isIntegerArray( [ -1.0, 10.0 ] );
* // returns true
*
* bool = isIntegerArray( [ -1.0, 0.0, 5.0 ] );
* // returns true
*
* bool = isIntegerArray( [ -3.0, new Number(-1.0) ] );
* // returns false
*
* @example
* var isIntegerArray = require( '@stdlib/assert/is-integer-array' ).objects;
*
* var bool = isIntegerArray( [ new Number(1.0), new Number(3.0) ] );
* // returns true
*
* bool = isIntegerArray( [ -1.0, 0.0, 3.0 ] );
* // returns false
*
* bool = isIntegerArray( [ 3.0, new Number(-1.0) ] );
* // returns false
*/

/**
* Test if a value is an array-like object containing only nonnegative integers.
*
* @module @stdlib/assert/is-nonnegative-integer-array
*
* @example
* var isNonNegativeIntegerArray = require( '@stdlib/assert/is-nonnegative-integer-array' );
*
* var bool = isNonNegativeIntegerArray( [ 3.0, new Number(3.0) ] );
* // returns true
*
* bool = isNonNegativeIntegerArray( [ 3.0, '3.0' ] );
* // returns false
*
* @example
* var isNonNegativeIntegerArray = require( '@stdlib/assert/is-nonnegative-integer-array' ).primitives;
*
* var bool = isNonNegativeIntegerArray( [ 1.0, 0.0, 10.0 ] );
* // returns true
*
* bool = isNonNegativeIntegerArray( [ 3.0, new Number(1.0) ] );
* // returns false
*
* @example
* var isNonNegativeIntegerArray = require( '@stdlib/assert/is-nonnegative-integer-array' ).objects;
*
* var bool = isNonNegativeIntegerArray( [ new Number(3.0), new Number(1.0) ] );
* // returns true
*
* bool = isNonNegativeIntegerArray( [ 1.0, 0.0, 10.0 ] );
* // returns false
*/

/**
* Test if a value is an array-like object containing only positive integers.
*
* @module @stdlib/assert/is-positive-integer-array
*
* @example
* var isPositiveIntegerArray = require( '@stdlib/assert/is-positive-integer-array' );
*
* var bool = isPositiveIntegerArray( [ 3.0, new Number(3.0) ] );
* // returns true
*
* bool = isPositiveIntegerArray( [ 3.0, '3.0' ] );
* // returns false
*
* @example
* var isPositiveIntegerArray = require( '@stdlib/assert/is-positive-integer-array' ).primitives;
*
* var bool = isPositiveIntegerArray( [ 1.0, 2.0, 10.0 ] );
* // returns true
*
* bool = isPositiveIntegerArray( [ 3.0, new Number(1.0) ] );
* // returns false
*
* @example
* var isPositiveIntegerArray = require( '@stdlib/assert/is-positive-integer-array' ).objects;
*
* var bool = isPositiveIntegerArray( [ new Number(3.0), new Number(1.0) ] );
* // returns true
*
* bool = isPositiveIntegerArray( [ 1.0, 2.0, 10.0 ] );
* // returns false
*/

/**
* Test if a value is an array-like object.
*
* @module @stdlib/assert/is-array-like-object
*
* @example
* var isArrayLikeObject = require( '@stdlib/assert/is-array-like-object' );
*
* var bool = isArrayLikeObject( [] );
* // returns true
*
* bool = isArrayLikeObject( { 'length':10 } );
* // returns true
*
* bool = isArrayLikeObject( 'beep' );
* // returns false
*/

/**
* Test if a value is an array.
*
* @module @stdlib/assert/is-array
*
* @example
* var isArray = require( '@stdlib/assert/is-array' );
*
* var bool = isArray( [] );
* // returns true
*
* bool = isArray( {} );
* // returns false
*/

/**
* Test if a value is an integer.
*
* @module @stdlib/assert/is-integer
*
* @example
* var isInteger = require( '@stdlib/assert/is-integer' );
*
* var bool = isInteger( 5.0 );
* // returns true
*
* bool = isInteger( new Number( 5.0 ) );
* // returns true
*
* bool = isInteger( -3.14 );
* // returns false
*
* bool = isInteger( null );
* // returns false
*
* @example
* // Use interface to check for integer primitives...
* var isInteger = require( '@stdlib/assert/is-integer' ).isPrimitive;
*
* var bool = isInteger( -3.0 );
* // returns true
*
* bool = isInteger( new Number( -3.0 ) );
* // returns false
*
* @example
* // Use interface to check for integer objects...
* var isInteger = require( '@stdlib/assert/is-integer' ).isObject;
*
* var bool = isInteger( 3.0 );
* // returns false
*
* bool = isInteger( new Number( 3.0 ) );
* // returns true
*/

/**
* Test if a value is an object.
*
* @module @stdlib/assert/is-object
*
* @example
* var isObject = require( '@stdlib/assert/is-object' );
*
* var bool = isObject( {} );
* // returns true
*
* bool = isObject( true );
* // returns false
*/

/**
* Test if a value is array-like.
*
* @module @stdlib/assert/is-array-like
*
* @example
* var isArrayLike = require( '@stdlib/assert/is-array-like' );
*
* var bool = isArrayLike( [] );
* // returns true
*
* bool = isArrayLike( { 'length': 10 } );
* // returns true
*
* bool = isArrayLike( 'beep' );
* // returns true
*/

/**
* Test if a value is ndarray-like.
*
* @module @stdlib/assert/is-ndarray-like
*
* @example
* var ctor = require( '@stdlib/ndarray/ctor' );
* var isndarrayLike = require( '@stdlib/assert/is-ndarray-like' );
*
* var ndarray = ctor( 'generic', 2 );
*
* var arr = ndarray( [ 0, 0, 0, 0 ], [ 2, 2 ], [ 2, 1 ], 0, 'row-major' );
*
* var bool = isndarrayLike( arr );
* // returns true
*
* bool = isndarrayLike( [] );
* // returns false
*/

/**
* Test if a value is object-like.
*
* @module @stdlib/assert/is-object-like
*
* @example
* var isObjectLike = require( '@stdlib/assert/is-object-like' );
*
* var bool = isObjectLike( {} );
* // returns true
*
* bool = isObjectLike( [] );
* // returns true
*
* bool = isObjectLike( null );
* // returns false
*
* @example
* var isObjectLike = require( '@stdlib/assert/is-object-like' ).isObjectLikeArray;
*
* var bool = isObjectLike( [ {}, [] ] );
* // returns true
*
* bool = isObjectLike( [ {}, '3.0' ] );
* // returns false
*/

/**
* Test if a value is typed-array-like.
*
* @module @stdlib/assert/is-typed-array-like
*
* @example
* var Int16Array = require( '@stdlib/array/int16' );
* var isTypedArrayLike = require( '@stdlib/assert/is-typed-array-like' );
*
* var bool = isTypedArrayLike( new Int16Array() );
* // returns true
*
* bool = isTypedArrayLike({
*	'length': 10,
*	'byteOffset': 0,
*	'byteLength': 10,
*	'BYTES_PER_ELEMENT': 4
* });
* // returns true
*/

/**
* Test if an array-like value contains another value.
*
* @module @stdlib/assert/contains
*
* @example
* var contains = require( '@stdlib/assert/contains' );
*
* var bool = contains( 'Hello World', 'World' );
* // returns true
*
* bool = contains( 'Hello World', 'world' );
* // returns false
*
* bool = contains( [ 1, 2, 3, 4 ], 2 );
* // returns true
*
* bool = contains( [ NaN, 2, 3, 4 ], NaN );
* // returns true
*/

/**
* Test whether a value has in its prototype chain a specified constructor as a prototype property.
*
* @module @stdlib/assert/instance-of
*
* @example
* var instanceOf = require( '@stdlib/assert/instance-of' );
*
* var bool = instanceOf( [], Array );
* // returns true
*
* bool = instanceOf( {}, Object ); // exception
* // returns true
*
* bool = instanceOf( 'beep', String );
* // returns false
*
* bool = instanceOf( null, Object );
* // returns false
*
* bool = instanceOf( 5, Object );
* // returns false
*/

/**
* Test whether an input value is a supported ndarray casting mode.
*
* @module @stdlib/ndarray/base/assert/is-casting-mode
*
* @example
* var isCastingMode = require( '@stdlib/ndarray/base/assert/is-casting-mode' );
*
* var bool = isCastingMode( 'none' );
* // returns true
*
* bool = isCastingMode( 'equiv' );
* // returns true
*
* bool = isCastingMode( 'safe' );
* // returns true
*
* bool = isCastingMode( 'same-kind' );
* // returns true
*
* bool = isCastingMode( 'unsafe' );
* // returns true
*
* bool = isCastingMode( 'foo' );
* // returns false
*/

/**
* Test whether an input value is a supported ndarray data type.
*
* @module @stdlib/ndarray/base/assert/is-data-type
*
* @example
* var isDataType = require( '@stdlib/ndarray/base/assert/is-data-type' );
*
* var bool = isDataType( 'binary' );
* // returns true
*
* bool = isDataType( 'float32' );
* // returns true
*
* bool = isDataType( 'float64' );
* // returns true
*
* bool = isDataType( 'generic' );
* // returns true
*
* bool = isDataType( 'int16' );
* // returns true
*
* bool = isDataType( 'int32' );
* // returns true
*
* bool = isDataType( 'int8' );
* // returns true
*
* bool = isDataType( 'uint16' );
* // returns true
*
* bool = isDataType( 'uint32' );
* // returns true
*
* bool = isDataType( 'uint8' );
* // returns true
*
* bool = isDataType( 'uint8c' );
* // returns true
*
* bool = isDataType( 'foo' );
* // returns false
*/

/**
* Test whether an input value is a supported ndarray index mode.
*
* @module @stdlib/ndarray/base/assert/is-index-mode
*
* @example
* var isIndexMode = require( '@stdlib/ndarray/base/assert/is-index-mode' );
*
* var bool = isIndexMode( 'wrap' );
* // returns true
*
* bool = isIndexMode( 'clamp' );
* // returns true
*
* bool = isIndexMode( 'throw' );
* // returns true
*
* bool = isIndexMode( 'foo' );
* // returns false
*/

/**
* Test whether an input value is an ndarray order.
*
* @module @stdlib/ndarray/base/assert/is-order
*
* @example
* var isOrder = require( '@stdlib/ndarray/base/assert/is-order' );
*
* var bool = isOrder( 'row-major' );
* // returns true
*
* bool = isOrder( 'column-major' );
* // returns true
*
* bool = isOrder( 'foo' );
* // returns false
*/

/**
* Test whether an object has a specified property, either own or inherited.
*
* @module @stdlib/assert/has-property
*
* @example
* var hasProp = require( '@stdlib/assert/has-property' );
*
* var beep = {
*     'boop': true
* };
*
* var bool = hasProp( beep, 'boop' );
* // returns true
*
* bool = hasProp( beep, 'bop' );
* // returns false
*/

/**
* Test whether an object has a specified property.
*
* @module @stdlib/assert/has-own-property
*
* @example
* var hasOwnProp = require( '@stdlib/assert/has-own-property' );
*
* var beep = {
*     'boop': true
* };
*
* var bool = hasOwnProp( beep, 'boop' );
* // returns true
*
* bool = hasOwnProp( beep, 'bop' );
* // returns false
*/

/**
* Test whether an object's own property is enumerable.
*
* @module @stdlib/assert/is-enumerable-property
*
* @example
* var isEnumerableProperty = require( '@stdlib/assert/is-enumerable-property' );
*
* var beep = {
*     'boop': true
* };
*
* var bool = isEnumerableProperty( beep, 'boop' );
* // returns true
*
* bool = isEnumerableProperty( beep, 'hasOwnProperty' );
* // returns false
*/

/**
* Tests (loosely) if an input value is an array-like object.
*
* @private
* @param {*} value - value to test
* @returns {boolean} boolean indicating if an input value is an array-like object
*
* @example
* var bool = isArrayLikeObject( [] );
* // returns true
*
* @example
* var bool = isArrayLikeObject( '' );
* // returns false
*/

/**
* Tests for `Object.defineProperty` support.
*
* @returns {boolean} boolean indicating if an environment has `Object.defineProperty` support
*
* @example
* var bool = hasDefinePropertySupport();
* // returns <boolean>
*/

/**
* Tests for native `Buffer` support.
*
* @returns {boolean} boolean indicating if an environment has `Buffer` support
*
* @example
* var bool = hasNodeBufferSupport();
* // returns <boolean>
*/

/**
* Tests for native `Float32Array` support.
*
* @returns {boolean} boolean indicating if an environment has `Float32Array` support
*
* @example
* var bool = hasFloat32ArraySupport();
* // returns <boolean>
*/

/**
* Tests for native `Float64Array` support.
*
* @returns {boolean} boolean indicating if an environment has `Float64Array` support
*
* @example
* var bool = hasFloat64ArraySupport();
* // returns <boolean>
*/

/**
* Tests for native `Int16Array` support.
*
* @returns {boolean} boolean indicating if an environment has `Int16Array` support
*
* @example
* var bool = hasInt16ArraySupport();
* // returns <boolean>
*/

/**
* Tests for native `Int32Array` support.
*
* @returns {boolean} boolean indicating if an environment has `Int32Array` support
*
* @example
* var bool = hasInt32ArraySupport();
* // returns <boolean>
*/

/**
* Tests for native `Int8Array` support.
*
* @returns {boolean} boolean indicating if an environment has `Int8Array` support
*
* @example
* var bool = hasInt8ArraySupport();
* // returns <boolean>
*/

/**
* Tests for native `Symbol` support.
*
* @returns {boolean} boolean indicating if an environment has `Symbol` support
*
* @example
* var bool = hasSymbolSupport();
* // returns <boolean>
*/

/**
* Tests for native `Uint16Array` support.
*
* @returns {boolean} boolean indicating if an environment has `Uint16Array` support
*
* @example
* var bool = hasUint16ArraySupport();
* // returns <boolean>
*/

/**
* Tests for native `Uint32Array` support.
*
* @returns {boolean} boolean indicating if an environment has `Uint32Array` support
*
* @example
* var bool = hasUint32ArraySupport();
* // returns <boolean>
*/

/**
* Tests for native `Uint8Array` support.
*
* @returns {boolean} boolean indicating if an environment has `Uint8Array` support
*
* @example
* var bool = hasUint8ArraySupport();
* // returns <boolean>
*/

/**
* Tests for native `Uint8ClampedArray` support.
*
* @returns {boolean} boolean indicating if an environment has `Uint8ClampedArray` support
*
* @example
* var bool = hasUint8ClampedArraySupport();
* // returns <boolean>
*/

/**
* Tests for native `toStringTag` support.
*
* @returns {boolean} boolean indicating if an environment has `toStringTag` support
*
* @example
* var bool = hasToStringTagSupport();
* // returns <boolean>
*/

/**
* Tests for native function `name` support.
*
* @returns {boolean} boolean indicating if an environment has function `name` support
*
* @example
* var bool = hasFunctionNameSupport();
* // returns <boolean>
*/

/**
* Tests if a finite double-precision floating-point number is an integer.
*
* @param {number} x - value to test
* @returns {boolean} boolean indicating whether the value is an integer
*
* @example
* var bool = isInteger( 1.0 );
* // returns true
*
* @example
* var bool = isInteger( 3.14 );
* // returns false
*/

/**
* Tests if a number primitive is an integer value.
*
* @private
* @param {*} value - value to test
* @returns {boolean} boolean indicating if a number primitive is an integer value
*/

/**
* Tests if a numeric value is `NaN`.
*
* @param {number} x - value to test
* @returns {boolean} boolean indicating whether the value is `NaN`
*
* @example
* var bool = isnan( NaN );
* // returns true
*
* @example
* var bool = isnan( 7.0 );
* // returns false
*/

/**
* Tests if a numeric value is infinite.
*
* @param {number} x - value to test
* @returns {boolean} boolean indicating whether the value is infinite
*
* @example
* var bool = isInfinite( Infinity );
* // returns true
*
* @example
* var bool = isInfinite( -Infinity );
* // returns true
*
* @example
* var bool = isInfinite( 5.0 );
* // returns false
*
* @example
* var bool = isInfinite( NaN );
* // returns false
*/

/**
* Tests if a numeric value is positive zero.
*
* @param {number} x - value to test
* @returns {boolean} boolean indicating whether the value is positive zero
*
* @example
* var bool = isPositiveZero( 0.0 );
* // returns true
*
* @example
* var bool = isPositiveZero( -0.0 );
* // returns false
*/

/**
* Tests if a value is `NaN`.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating whether value is `NaN`
*
* @example
* var bool = isnan( NaN );
* // returns true
*
* @example
* var bool = isnan( new Number( NaN ) );
* // returns true
*
* @example
* var bool = isnan( 3.14 );
* // returns false
*
* @example
* var bool = isnan( null );
* // returns false
*/

/**
* Tests if a value is a 1-dimensional ndarray-like object.
*
* @param {*} v - value to test
* @returns {boolean} boolean indicating if a value is a 1-dimensional ndarray-like object
*
* @example
* var ctor = require( '@stdlib/ndarray/ctor' );
*
* var ndarray = ctor( 'generic', 1 );
* var arr = ndarray( [ 0, 0, 0, 0 ], [ 4 ], [ 1 ], 0, 'row-major' );
*
* var bool = isVectorLike( arr );
* // returns true
*
* bool = isVectorLike( [] );
* // returns false
*/

/**
* Tests if a value is a 2-dimensional ndarray-like object.
*
* @param {*} v - value to test
* @returns {boolean} boolean indicating if a value is a 2-dimensional ndarray-like object
*
* @example
* var ctor = require( '@stdlib/ndarray/ctor' );
*
* var ndarray = ctor( 'generic', 2 );
* var arr = ndarray( [ 0, 0, 0, 0 ], [ 2, 2 ], [ 2, 1 ], 0, 'row-major' );
*
* var bool = isMatrixLike( arr );
* // returns true
*
* bool = isMatrixLike( [] );
* // returns false
*/

/**
* Tests if a value is a Buffer instance.
*
* @param {*} value - value to validate
* @returns {boolean} boolean indicating if a value is a Buffer instance
*
* @example
* var v = isBuffer( new Buffer( 'beep' ) );
* // returns true
*
* @example
* var v = isBuffer( new Buffer( [1,2,3,4] ) );
* // returns true
*
* @example
* var v = isBuffer( {} );
* // returns false
*
* @example
* var v = isBuffer( [] );
* // returns false
*/

/**
* Tests if a value is a Float32Array.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating whether value is a Float32Array
*
* @example
* var bool = isFloat32Array( new Float32Array( 10 ) );
* // returns true
*
* @example
* var bool = isFloat32Array( [] );
* // returns false
*/

/**
* Tests if a value is a Float64Array.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating whether value is a Float64Array
*
* @example
* var bool = isFloat64Array( new Float64Array( 10 ) );
* // returns true
*
* @example
* var bool = isFloat64Array( [] );
* // returns false
*/

/**
* Tests if a value is a Uint16Array.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating whether value is a Uint16Array
*
* @example
* var bool = isUint16Array( new Uint16Array( 10 ) );
* // returns true
*
* @example
* var bool = isUint16Array( [] );
* // returns false
*/

/**
* Tests if a value is a Uint32Array.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating whether value is a Uint32Array
*
* @example
* var bool = isUint32Array( new Uint32Array( 10 ) );
* // returns true
*
* @example
* var bool = isUint32Array( [] );
* // returns false
*/

/**
* Tests if a value is a Uint8Array.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating whether value is a Uint8Array
*
* @example
* var bool = isUint8Array( new Uint8Array( 10 ) );
* // returns true
*
* @example
* var bool = isUint8Array( [] );
* // returns false
*/

/**
* Tests if a value is a Uint8ClampedArray.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating whether value is a Uint8ClampedArray
*
* @example
* var bool = isUint8ClampedArray( new Uint8ClampedArray( 10 ) );
* // returns true
*
* @example
* var bool = isUint8ClampedArray( [] );
* // returns false
*/

/**
* Tests if a value is a `NaN` number primitive.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating if a value is a `NaN` number primitive
*
* @example
* var bool = isnan( NaN );
* // returns true
*
* @example
* var bool = isnan( 3.14 );
* // returns false
*
* @example
* var bool = isnan( new Number( NaN ) );
* // returns false
*/

/**
* Tests if a value is a boolean object.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating if a value is a boolean object
*
* @example
* var bool = isBoolean( true );
* // returns false
*
* @example
* var bool = isBoolean( new Boolean( false ) );
* // returns true
*/

/**
* Tests if a value is a boolean primitive.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating if a value is a boolean primitive
*
* @example
* var bool = isBoolean( true );
* // returns true
*
* @example
* var bool = isBoolean( false );
* // returns true
*
* @example
* var bool = isBoolean( new Boolean( true ) );
* // returns false
*/

/**
* Tests if a value is a boolean.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating whether value is a boolean
*
* @example
* var bool = isBoolean( false );
* // returns true
*
* @example
* var bool = isBoolean( true );
* // returns true
*
* @example
* var bool = isBoolean( new Boolean( false ) );
* // returns true
*
* @example
* var bool = isBoolean( new Boolean( true ) );
* // returns true
*/

/**
* Tests if a value is a collection.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating whether a value is a collection
*
* @example
* var bool = isCollection( [] );
* // returns true
*
* @example
* var bool = isCollection( {} );
* // returns false
*/

/**
* Tests if a value is a function.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating whether value is a function
*
* @example
* function beep() {
*     return 'beep';
* }
*
* var bool = isFunction( beep );
* // returns true
*/

/**
* Tests if a value is a nonnegative integer.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating whether value is a nonnegative integer
*
* @example
* var bool = isNonNegativeInteger( 5.0 );
* // returns true
*
* @example
* var bool = isNonNegativeInteger( new Number( 5.0 ) );
* // returns true
*
* @example
* var bool = isNonNegativeInteger( -5.0 );
* // returns false
*
* @example
* var bool = isNonNegativeInteger( 3.14 );
* // returns false
*
* @example
* var bool = isNonNegativeInteger( null );
* // returns false
*/

/**
* Tests if a value is a number object having a nonnegative integer value.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating if a value is a number object having a nonnegative integer value
*
* @example
* var bool = isNonNegativeInteger( 3.0 );
* // returns false
*
* @example
* var bool = isNonNegativeInteger( new Number( 3.0 ) );
* // returns true
*/

/**
* Tests if a value is a number object having a positive integer value.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating if a value is a number object having a positive integer value
*
* @example
* var bool = isPositiveInteger( 3.0 );
* // returns false
*
* @example
* var bool = isPositiveInteger( new Number( 3.0 ) );
* // returns true
*/

/**
* Tests if a value is a number object having a value of `NaN`.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating if a value is a number object having a value of `NaN`
*
* @example
* var bool = isnan( NaN );
* // returns false
*
* @example
* var bool = isnan( new Number( NaN ) );
* // returns true
*/

/**
* Tests if a value is a number object having an integer value.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating if a value is a number object having an integer value
*
* @example
* var bool = isInteger( 3.0 );
* // returns false
*
* @example
* var bool = isInteger( new Number( 3.0 ) );
* // returns true
*/

/**
* Tests if a value is a number object.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating if a value is a number object
*
* @example
* var bool = isNumber( 3.14 );
* // returns false
*
* @example
* var bool = isNumber( new Number( 3.14 ) );
* // returns true
*/

/**
* Tests if a value is a number primitive having a nonnegative integer value.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating if a value is a number primitive having a nonnegative integer value
*
* @example
* var bool = isNonNegativeInteger( 3.0 );
* // returns true
*
* @example
* var bool = isNonNegativeInteger( new Number( 3.0 ) );
* // returns false
*/

/**
* Tests if a value is a number primitive having a positive integer value.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating if a value is a number primitive having a positive integer value
*
* @example
* var bool = isPositiveInteger( 3.0 );
* // returns true
*
* @example
* var bool = isPositiveInteger( new Number( 3.0 ) );
* // returns false
*/

/**
* Tests if a value is a number primitive having an integer value.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating if a value is a number primitive having an integer value
*
* @example
* var bool = isInteger( -3.0 );
* // returns true
*
* @example
* var bool = isInteger( new Number( -3.0 ) );
* // returns false
*/

/**
* Tests if a value is a number primitive.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating if a value is a number primitive
*
* @example
* var bool = isNumber( 3.14 );
* // returns true
*
* @example
* var bool = isNumber( NaN );
* // returns true
*
* @example
* var bool = isNumber( new Number( 3.14 ) );
* // returns false
*/

/**
* Tests if a value is a number.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating whether value is a number
*
* @example
* var bool = isNumber( 3.14 );
* // returns true
*
* @example
* var bool = isNumber( new Number( 3.14 ) );
* // returns true
*
* @example
* var bool = isNumber( NaN );
* // returns true
*
* @example
* var bool = isNumber( null );
* // returns false
*/

/**
* Tests if a value is a plain object.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating whether value is a plain object
*
* @example
* var bool = isPlainObject( {} );
* // returns true
*
* @example
* var bool = isPlainObject( null );
* // returns false
*/

/**
* Tests if a value is a positive integer.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating whether value is a positive integer
*
* @example
* var bool = isPositiveInteger( 5.0 );
* // returns true
*
* @example
* var bool = isPositiveInteger( new Number( 5.0 ) );
* // returns true
*
* @example
* var bool = isPositiveInteger( 0.0 );
* // returns false
*
* @example
* var bool = isPositiveInteger( -5.0 );
* // returns false
*
* @example
* var bool = isPositiveInteger( 3.14 );
* // returns false
*
* @example
* var bool = isPositiveInteger( null );
* // returns false
*/

/**
* Tests if a value is a regular expression.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating whether value is a regular expression
*
* @example
* var bool = isRegExp( /\.+/ );
* // returns true
*
* @example
* var bool = isRegExp( {} );
* // returns false
*/

/**
* Tests if a value is a string having an uppercase first character.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating whether a value is a string with an uppercase first character
*
* @example
* var bool = isCapitalized( 'Hello' );
* // returns true
*
* @example
* var bool = isCapitalized( 'WORLD' );
* // returns true
*
* @example
* var bool = isCapitalized( '!' );
* // returns false
*
* @example
* var bool = isCapitalized( 'salt and light' );
* // returns false
*/

/**
* Tests if a value is a string object.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating if a value is a string object
*
* @example
* var bool = isString( new String( 'beep' ) );
* // returns true
*
* @example
* var bool = isString( 'beep' );
* // returns false
*/

/**
* Tests if a value is a string primitive.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating if a value is a string primitive
*
* @example
* var bool = isString( 'beep' );
* // returns true
*
* @example
* var bool = isString( new String( 'beep' ) );
* // returns false
*/

/**
* Tests if a value is a string.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating whether value is a string
*
* @example
* var bool = isString( new String( 'beep' ) );
* // returns true
*
* @example
* var bool = isString( 'beep' );
* // returns true
*/

/**
* Tests if a value is a typed array.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating if a value is a typed array
*
* @example
* var Int8Array = require( '@stdlib/array/int8' );
*
* var bool = isTypedArray( new Int8Array( 10 ) );
* // returns true
*/

/**
* Tests if a value is an Int16Array.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating whether value is an Int16Array
*
* @example
* var bool = isInt16Array( new Int16Array( 10 ) );
* // returns true
*
* @example
* var bool = isInt16Array( [] );
* // returns false
*/

/**
* Tests if a value is an Int32Array.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating whether value is an Int32Array
*
* @example
* var bool = isInt32Array( new Int32Array( 10 ) );
* // returns true
*
* @example
* var bool = isInt32Array( [] );
* // returns false
*/

/**
* Tests if a value is an Int8Array.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating whether value is an Int8Array
*
* @example
* var bool = isInt8Array( new Int8Array( 10 ) );
* // returns true
*
* @example
* var bool = isInt8Array( [] );
* // returns false
*/

/**
* Tests if a value is an `Error` object.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating whether a value is an `Error` object
*
* @example
* var bool = isError( new Error( 'beep' ) );
* // returns true
*
* @example
* var bool = isError( {} );
* // returns false
*/

/**
* Tests if a value is an array of probabilities that sum to one.
*
* @param {*} v - value to test
* @returns {boolean} boolean indicating if a value is a probability array
*
* @example
* var bool = isUnityProbabilityArray( [ 0.25, 0.5, 0.25 ] );
* // returns true
*
* @example
* var bool = isUnityProbabilityArray( new Uint8Array( [ 0, 1 ] ) );
* // returns true
*
* @example
* var bool = isUnityProbabilityArray( [ 0.4, 0.4, 0.4 ] );
* // returns false
*
* @example
* var bool = isUnityProbabilityArray( [ 3.14, 0.0 ] );
* // returns false
*/

/**
* Tests if a value is an array-like object.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating if a value is an array-like object
*
* @example
* var bool = isArrayLikeObject( [] );
* // returns true
*
* @example
* var bool = isArrayLikeObject( { 'length':10 } );
* // returns true
*
* @example
* var bool = isArrayLikeObject( 'beep' );
* // returns false
*/

/**
* Tests if a value is an array.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating whether value is an array
*
* @example
* var bool = isArray( [] );
* // returns true
*
* @example
* var bool = isArray( {} );
* // returns false
*/

/**
* Tests if a value is an integer.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating whether value is an integer
*
* @example
* var bool = isInteger( 5.0 );
* // returns true
*
* @example
* var bool = isInteger( new Number( 5.0 ) );
* // returns true
*
* @example
* var bool = isInteger( -3.14 );
* // returns false
*
* @example
* var bool = isInteger( null );
* // returns false
*/

/**
* Tests if a value is an object; e.g., `{}`.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating whether value is an object
*
* @example
* var bool = isObject( {} );
* // returns true
*
* @example
* var bool = isObject( null );
* // returns false
*/

/**
* Tests if a value is array-like.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating if a value is array-like
*
* @example
* var bool = isArrayLike( [] );
* // returns true
*
* @example
* var bool = isArrayLike( {'length':10} );
* // returns true
*/

/**
* Tests if a value is ndarray-like.
*
* @param {*} v - value to test
* @returns {boolean} boolean indicating if a value is ndarray-like
*
* @example
* var ctor = require( '@stdlib/ndarray/ctor' );
*
* var ndarray = ctor( 'generic', 2 );
* var arr = ndarray( [ 0, 0, 0, 0 ], [ 2, 2 ], [ 2, 1 ], 0, 'row-major' );
*
* var bool = isndarrayLike( arr );
* // returns true
*
* bool = isndarrayLike( [] );
* // returns false
*/

/**
* Tests if a value is object-like.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating whether a value is object-like
*
* @example
* var bool = isObjectLike( {} );
* // returns true
*
* @example
* var bool = isObjectLike( [] );
* // returns true
*
* @example
* var bool = isObjectLike( null );
* // returns false
*/

/**
* Tests if a value is typed-array-like.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating if a value is typed-array-like
*
* @example
* var arr = {
*	'BYTES_PER_ELEMENT': 8,
*	'length': 10,
*	'byteOffset': 0,
*	'byteLength': 10
* };
* var val = isTypedArrayLike( arr );
* // returns true
*
* @example
* var Int8Array = require( '@stdlib/array/int8' );
*
* var val = isTypedArrayLike( new Int8Array( 4 ) );
* // returns true
*
* @example
* var val = isTypedArrayLike( [] );
* // returns false
*
* @example
* var val = isTypedArrayLike( {} );
* // returns false
*
* @example
* var val = isTypedArrayLike( null );
* // returns false
*
* @example
* var val = isTypedArrayLike( 'beep' );
* // returns false
*/

/**
* Tests if an array-like value contains a search value.
*
* @param {(Collection|string)} val - input value
* @param {*} searchValue - search value
* @param {integer} [position=0] - position at which to start searching for `searchValue`
* @throws {TypeError} first argument must be array-like
* @throws {Error} must provide a search value
* @throws {TypeError} second argument must be a primitive string primitive when the first argument is a string
* @throws {TypeError} third argument must be an integer
* @returns {boolean} boolean indicating whether one value contains another
*
* @example
* var bool = contains( 'last man standing', 'stand' );
* // returns true
*
* @example
* var bool = contains( [ 1, 2, 3, 4 ], 2 );
* // returns true
*
* @example
* var bool = contains( 'presidential election', 'president' );
* // returns true
*
* @example
* var bool = contains( [ NaN, 2, 3, 4 ], NaN );
* // returns true
*
* @example
* var bool = contains( 'javaScript', 'js' );
* // returns false
*
* @example
* var bool = contains( [ 1, 2, 3, {} ], {} );
* // returns false
*
* @example
* var bool = contains( 'Hidden Treasures', '' );
* // returns true
*/

/**
* Tests if an object has a specified property, either own or inherited.
*
* @param {*} value - value to test
* @param {*} property - property to test
* @returns {boolean} boolean indicating if an object has a specified property
*
* @example
* var beep = {
*     'boop': true
* };
*
* var bool = hasProp( beep, 'boop' );
* // returns true
*
* @example
* var beep = {
*     'boop': true
* };
*
* var bool = hasProp( beep, 'bap' );
* // returns false
*/

/**
* Tests if an object has a specified property.
*
* @param {*} value - value to test
* @param {*} property - property to test
* @returns {boolean} boolean indicating if an object has a specified property
*
* @example
* var beep = {
*     'boop': true
* };
*
* var bool = hasOwnProp( beep, 'boop' );
* // returns true
*
* @example
* var beep = {
*     'boop': true
* };
*
* var bool = hasOwnProp( beep, 'bap' );
* // returns false
*/

/**
* Tests if an object's own property is enumerable.
*
* @param {*} value - value to test
* @param {*} property - property to test
* @returns {boolean} boolean indicating if an object property is enumerable
*
* @example
* var beep = {
*     'boop': true
* };
*
* var bool = isEnumerableProperty( beep, 'boop' );
* // returns true
*
* @example
* var beep = {
*     'boop': true
* };
*
* var bool = isEnumerableProperty( beep, 'hasOwnProperty' );
* // returns false
*/

/**
* Tests if an object's own property is enumerable.
*
* @private
* @name isEnumerableProperty
* @type {Function}
* @param {*} value - value to test
* @param {*} property - property to test
* @returns {boolean} boolean indicating if an object property is enumerable
*
* @example
* var beep = {
*     'boop': true
* };
*
* var bool = isEnumerableProperty( beep, 'boop' );
* // returns true
*
* @example
* var beep = {
*     'boop': true
* };
*
* var bool = isEnumerableProperty( beep, 'hasOwnProperty' );
* // returns false
*/

/**
* Tests that a value is a valid constructor.
*
* @private
* @param {*} value - value to test
* @returns {(Error|null)} error object or null
*
* @example
* var ctor = function ctor() {};
*
* var err = validate( ctor );
* // returns null
*
* err = validate( null );
* // returns <TypeError>
*/

/**
* Tests that an object only has own properties.
*
* @private
* @param {Object} obj - value to test
* @returns {boolean} boolean indicating if an object only has own properties
*/

/**
* Tests the built-in `Object.keys()` implementation when provided `arguments`.
*
* @private
* @returns {boolean} boolean indicating whether the built-in implementation returns the expected number of keys
*/

/**
* Tests whether a value equals the prototype of its constructor.
*
* @private
* @param {*} value - value to test
* @returns {boolean} boolean indicating whether a value equals the prototype of its constructor
*/

/**
* Tests whether a value has in its prototype chain a specified constructor as a prototype property.
*
* @param {*} value - value to test
* @param {Function} constructor - constructor to test against
* @throws {TypeError} constructor must be callable
* @returns {boolean} boolean indicating whether a value is an instance of a provided constructor
*
* @example
* var bool = instanceOf( [], Array );
* // returns true
*
* @example
* var bool = instanceOf( {}, Object ); // exception
* // returns true
*
* @example
* var bool = instanceOf( 'beep', String );
* // returns false
*
* @example
* var bool = instanceOf( null, Object );
* // returns false
*
* @example
* var bool = instanceOf( 5, Object );
* // returns false
*/

/**
* Tests whether a value is an `arguments` object.
*
* @private
* @param {*} value - value to test
* @returns {boolean} boolean indicating whether a value is an `arguments` object
*
* @example
* function foo() {
*     return arguments;
* }
*
* var bool = isArguments( foo() );
* // returns true
*
* @example
* var bool = isArguments( [] );
* // returns false
*/

/**
* Tests whether an input value is a supported ndarray casting mode.
*
* @param {*} v - value to test
* @returns {boolean} boolean indicating whether an input value is a supported ndarray casting mode
*
* @example
* var bool = isCastingMode( 'none' );
* // returns true
*
* bool = isCastingMode( 'equiv' );
* // returns true
*
* bool = isCastingMode( 'safe' );
* // returns true
*
* bool = isCastingMode( 'same-kind' );
* // returns true
*
* bool = isCastingMode( 'unsafe' );
* // returns true
*
* bool = isCastingMode( 'foo' );
* // returns false
*/

/**
* Tests whether an input value is a supported ndarray data type.
*
* @param {*} v - value to test
* @returns {boolean} boolean indicating whether an input value is a supported ndarray data type
*
* @example
* var bool = isDataType( 'binary' );
* // returns true
*
* bool = isDataType( 'float32' );
* // returns true
*
* bool = isDataType( 'float64' );
* // returns true
*
* bool = isDataType( 'generic' );
* // returns true
*
* bool = isDataType( 'int16' );
* // returns true
*
* bool = isDataType( 'int32' );
* // returns true
*
* bool = isDataType( 'int8' );
* // returns true
*
* bool = isDataType( 'uint16' );
* // returns true
*
* bool = isDataType( 'uint32' );
* // returns true
*
* bool = isDataType( 'uint8' );
* // returns true
*
* bool = isDataType( 'uint8c' );
* // returns true
*
* bool = isDataType( 'foo' );
* // returns false
*/

/**
* Tests whether an input value is a supported ndarray index mode.
*
* @param {*} v - value to test
* @returns {boolean} boolean indicating whether an input value is a supported ndarray index mode
*
* @example
* var bool = isIndexMode( 'wrap' );
* // returns true
*
* bool = isIndexMode( 'clamp' );
* // returns true
*
* bool = isIndexMode( 'throw' );
* // returns true
*
* bool = isIndexMode( 'foo' );
* // returns false
*/

/**
* Tests whether an input value is an ndarray order.
*
* @param {*} v - value to test
* @returns {boolean} boolean indicating whether an input value is an ndarray order
*
* @example
* var bool = isOrder( 'row-major' );
* // returns true
*
* bool = isOrder( 'column-major' );
* // returns true
*
* bool = isOrder( 'foo' );
* // returns false
*/

/**
* Tests whether the built-in `Object.keys()` implementation supports providing `arguments` as an input value.
*
* ## Notes
*
* -   Safari 5.0 does **not** support `arguments` as an input value.
*
* @private
* @returns {boolean} boolean indicating whether a built-in implementation supports `arguments`
*/

/**
* The bias of a double-precision floating-point number's exponent.
*
* @module @stdlib/constants/math/float64-exponent-bias
* @type {integer32}
*
* @example
* var FLOAT64_EXPONENT_BIAS = require( '@stdlib/constants/math/float64-exponent-bias' );
* // returns 1023
*/

/**
* Tokenize a string.
*
* @module @stdlib/nlp/tokenize
*
* @example
* var tokenize = require( '@stdlib/nlp/tokenize' );
*
* var str = 'Hello Mrs. Maple, could you call me back?';
* var out = tokenize( str );
* // returns [ 'Hello', 'Mrs.', 'Maple', ',', 'could', 'you', 'call', 'me', 'back', '?' ]
*
* str = 'Hello World!';
* out = tokenize( str );
* // returns [ 'Hello', 'World', '!' ]
*/

/**
* Tokenize a string.
*
* @param {string} str - input string
* @param {boolean} [keepWhitespace=false] - boolean indicating whether whitespace characters should be returned as part of the token array
* @throws {TypeError} first argument must be a string primitive
* @throws {TypeError} second argument must be a boolean primitive
* @returns {Array} array of tokens
*
* @example
* var str = 'Hello World!';
* var out = tokenize( str );
* // returns [ 'Hello', 'World', '!' ]
*
* @example
* var str = '';
* var out = tokenize( str );
* // returns []
*
* @example
* var str = 'Hello Mrs. Maple, could you call me back?';
* var out = tokenize( str );
* // returns [ 'Hello', 'Mrs.', 'Maple', ',', 'could', 'you', 'call', 'me', 'back', '?' ]
*/

/**
* Tokenizes a substring.
*
* @private
* @param {string} substr - input string
* @returns {Array} token array
*
* @example
* var str = '(never)';
* var out = tokenizeSubstring( str );
* // returns [ '(', 'never', ')' ]
*/

/**
* Trim whitespace characters from beginning and end of a string.
*
* @param {string} str - input string
* @throws {TypeError} must provide a string primitive
* @returns {string} trimmed string
*
* @example
* var out = trim( '   Whitespace   ' );
* // returns 'Whitespace'
*
* @example
* var out = trim( '\t\t\tTabs\t\t\t' );
* // returns 'Tabs'
*
* @example
* var out = trim( '\n\n\nNew Lines\n\n\n' );
* // returns 'New Lines'
*/

/**
* Trim whitespace characters from the beginning and end of a string.
*
* @module @stdlib/string/trim
*
* @example
* var trim = require( '@stdlib/string/trim' );
*
* var out = trim( '   Whitespace   ' );
* // returns 'Whitespace'
*
* out = trim( '\t\t\tTabs\t\t\t' );
* // returns 'Tabs'
*
* out = trim( '\n\n\nNew Lines\n\n\n' );
* // returns 'New Lines'
*/

/**
* Typed array constructor which returns a typed array representing an array of 16-bit unsigned integers in the platform byte order.
*
* @module @stdlib/array/uint16
*
* @example
* var ctor = require( '@stdlib/array/uint16' );
*
* var arr = new ctor( 10 );
* // returns <Uint16Array>
*/

/**
* Typed array constructor which returns a typed array representing an array of 32-bit unsigned integers in the platform byte order.
*
* @module @stdlib/array/uint32
*
* @example
* var ctor = require( '@stdlib/array/uint32' );
*
* var arr = new ctor( 10 );
* // returns <Uint32Array>
*/

/**
* Typed array constructor which returns a typed array representing an array of 8-bit unsigned integers in the platform byte order clamped to 0-255.
*
* @module @stdlib/array/uint8c
*
* @example
* var ctor = require( '@stdlib/array/uint8c' );
*
* var arr = new ctor( 10 );
* // returns <Uint8ClampedArray>
*/

/**
* Typed array constructor which returns a typed array representing an array of 8-bit unsigned integers in the platform byte order.
*
* @module @stdlib/array/uint8
*
* @example
* var ctor = require( '@stdlib/array/uint8' );
*
* var arr = new ctor( 10 );
* // returns <Uint8Array>
*/

/**
* Typed array constructor which returns a typed array representing an array of double-precision floating-point numbers in the platform byte order.
*
* @module @stdlib/array/float64
*
* @example
* var ctor = require( '@stdlib/array/float64' );
*
* var arr = new ctor( 10 );
* // returns <Float64Array>
*/

/**
* Typed array constructor which returns a typed array representing an array of single-precision floating-point numbers in the platform byte order.
*
* @module @stdlib/array/float32
*
* @example
* var ctor = require( '@stdlib/array/float32' );
*
* var arr = new ctor( 10 );
* // returns <Float32Array>
*/

/**
* Typed array constructor which returns a typed array representing an array of twos-complement 16-bit signed integers in the platform byte order.
*
* @module @stdlib/array/int16
*
* @example
* var ctor = require( '@stdlib/array/int16' );
*
* var arr = new ctor( 10 );
* // returns <Int16Array>
*/

/**
* Typed array constructor which returns a typed array representing an array of twos-complement 32-bit signed integers in the platform byte order.
*
* @module @stdlib/array/int32
*
* @example
* var ctor = require( '@stdlib/array/int32' );
*
* var arr = new ctor( 10 );
* // returns <Int32Array>
*/

/**
* Typed array constructor which returns a typed array representing an array of twos-complement 8-bit signed integers in the platform byte order.
*
* @module @stdlib/array/int8
*
* @example
* var ctor = require( '@stdlib/array/int8' );
*
* var arr = new ctor( 10 );
* // returns <Int8Array>
*/

/**
* Typed array which represents an array of 16-bit unsigned integers in the platform byte order.
*
* @throws {Error} not implemented
*/

/**
* Typed array which represents an array of 32-bit unsigned integers in the platform byte order.
*
* @throws {Error} not implemented
*/

/**
* Typed array which represents an array of 8-bit unsigned integers in the platform byte order clamped to 0-255.
*
* @throws {Error} not implemented
*/

/**
* Typed array which represents an array of 8-bit unsigned integers in the platform byte order.
*
* @throws {Error} not implemented
*/

/**
* Typed array which represents an array of double-precision floating-point numbers in the platform byte order.
*
* @throws {Error} not implemented
*/

/**
* Typed array which represents an array of single-precision floating-point numbers in the platform byte order.
*
* @throws {Error} not implemented
*/

/**
* Typed array which represents an array of twos-complement 16-bit signed integers in the platform byte order.
*
* @throws {Error} not implemented
*/

/**
* Typed array which represents an array of twos-complement 32-bit signed integers in the platform byte order.
*
* @throws {Error} not implemented
*/

/**
* Typed array which represents an array of twos-complement 8-bit signed integers in the platform byte order.
*
* @throws {Error} not implemented
*/

/**
* Uncapitalize the first character of a string.
*
* @module @stdlib/string/uncapitalize
*
* @example
* var uncapitalize = require( '@stdlib/string/uncapitalize' );
*
* var out = uncapitalize( 'Last man standing' );
* // returns 'last man standing'
*
* out = uncapitalize( 'Hidden Treasures' );
* // returns 'hidden Treasures';
*/

/**
* Uncapitalizes the first character of a string.
*
* @param {string} str - input string
* @throws {TypeError} must provide a string primitive
* @returns {string} input string with first character converted to lowercase
*
* @example
* var out = uncapitalize( 'Last man standing' );
* // returns 'last man standing'
*
* @example
* var out = uncapitalize( 'Presidential election' );
* // returns 'presidential election'
*
* @example
* var out = uncapitalize( 'JavaScript' );
* // returns 'javaScript'
*
* @example
* var out = uncapitalize( 'Hidden Treasures' );
* // returns 'hidden Treasures'
*/

/**
* Updates a PRNG's internal state by generating the next `N` words.
*
* @private
* @param {Uint32Array} state - state array
* @returns {Uint32Array} state array
*/

/**
* Updates a centroid.
*
* ## Notes
*
* -   Uses Welford's algorithm for updating an arithmetic mean.
*
* @private
* @param {PositiveInteger} ndims - number of dimensions
* @param {PositiveInteger} N - number of data points in a cluster
* @param {NumericArray} C - strided array containing centroids
* @param {PositiveInteger} strideC - centroid column stride
* @param {NonNegativeInteger} offsetC - centroid index offset
* @param {NumericArray} V - strided array containing a data point
* @param {integer} strideV - vector stride
* @param {NonNegativeInteger} offsetV - vector index offset
* @returns {NumericArray} strided array containing centroids
*/

/**
* Validates function options.
*
* @private
* @param {Object} opts - destination for function options
* @param {Options} options - function options
* @param {NonNegativeInteger} [options.depth] - depth to flatten
* @param {boolean} [options.copy] - boolean indicating whether to deep copy array elements
* @returns {(Error|null)} error or null
*
* @example
* var opts = {};
* var options = {
*     'depth': 10,
*     'copy': false
* };
* var err = validate( opts, options );
* if ( err ) {
*     throw err;
* }
*/

/**
* Validates function options.
*
* @private
* @param {Object} opts - destination for validated options
* @param {Options} options - function options
* @param {NonNegativeInteger} [options.size] - sample size
* @param {ProbabilityArray} [options.probs] - element probabilities
* @param {boolean} [options.replace] - boolean indicating whether to sample with replacement
* @param {boolean} [options.mutate] - boolean indicating whether to mutate the `pool` when sampling without replacement
* @returns {(null|Error)} null or an error
*
* @example
* var opts = {};
* var options = {
*     'size': 10,
*     'replace': false,
*     'mutate': true,
*     'probs': [ 0.7, 0.3 ]
* };
* var err = validate( opts, options );
* if ( err ) {
*     throw err;
* }
*/

/**
* Validates function options.
*
* @private
* @param {Object} opts - destination object
* @param {Options} options - function options
* @param {boolean} [options.codegen] - boolean indicating whether to use code generation
* @param {string} [options.mode] - specifies how to handle indices which exceed array dimensions
* @param {string} [options.submode] - specifies how to handle subscripts which exceed array dimensions
* @returns {(Error|null)} null or an error object
*
* @example
* var opts = {};
* var options = {
*     'mode': 'clamp',
*     'submode': [ 'throw', 'wrap', 'clamp' ],
*     'codegen': false
* };
* var err = validate( opts, options );
* if ( err ) {
*     throw err;
* }
*/

/**
* Validates function options.
*
* @private
* @param {Object} opts - destination object
* @param {Options} options - function options
* @param {string} [options.metric] - distance metric
* @param {ArrayLikeObject} [options.init] - method for determining initial centroids
* @param {boolean} [options.normalize] - boolean indicating whether to normalize incoming data
* @param {boolean} [options.copy] - boolean indicating whether to copy incoming data to prevent mutation during normalization
* @param {*} [options.seed] - PRNG seed
* @returns {(Error|null)} null or an error object
*
* @example
* var opts = {};
* var options = {
*     'metric': 'euclidean',
*     'init': [ 'kmeans++', 1, 1 ]
* };
* var err = validate( opts, options );
* if ( err ) {
*     throw err;
* }
*/

/**
* Validates values provided for minimum and maximum support.
*
* @private
* @param {integer} a - minimum support
* @param {integer} b - maximum support
* @returns {(Error|null)} error or null
*
* @example
* var err = validate( 1, 20 );
* if ( err ) {
*     throw err;
* }
*/

/**
* Verifies state array integrity.
*
* @private
* @param {Int32Array} state - state array
* @param {boolean} FLG - flag indicating whether the state array was provided as an option (true) or an argument (false)
* @returns {(Error|null)} an error or `null`
*/

/**
* Verifies state array integrity.
*
* @private
* @param {Uint32Array} state - state array
* @param {boolean} FLG - flag indicating whether the state array was provided as an option (true) or an argument (false)
* @returns {(Error|null)} an error or `null`
*/

/**
* Wrap an index on the interval `[0,max]`.
*
* @module @stdlib/ndarray/base/wrap-index
*
* @example
* var wrapIndex = require( '@stdlib/ndarray/base/wrap-index' );
*
* var idx = wrapIndex( -1, 10 );
* // returns 10
*
* idx = wrapIndex( 14, 10 );
* // returns 3
*
* idx = wrapIndex( 6, 10 );
* // returns 6
*/

/**
* Wraps an index on the interval `[0,max]`.
*
* @param {integer} idx - index
* @param {NonNegativeInteger} max - maximum index
* @returns {NonNegativeInteger} index
*
* @example
* var idx = wrapIndex( -1, 10 );
* // returns 10
*
* idx = wrapIndex( 13, 10 );
* // returns 2
*
* idx = wrapIndex( 6, 10 );
* // returns 6
*/

/**
* Wraps the test for constructor prototype equality to accommodate buggy environments (e.g., environments which throw when testing equality).
*
* @private
* @param {*} value - value to test
* @returns {boolean} boolean indicating whether a value equals the prototype of its constructor
*/

/**
* ndarray data buffer constructors.
*
* @module @stdlib/ndarray/base/buffer-ctors
*
* @example
* var ctors = require( '@stdlib/ndarray/base/buffer-ctors' );
*
* var ctor = ctors( 'float64' );
* // returns <Function>
*
* ctor = ctors( 'int' );
* // returns null
*/

/************************************************************************/

/******/

/***/

//

//    buffer.fill(buffer[, offset[, end]])

//    buffer.fill(number[, offset[, end]])

//    buffer.fill(string[, offset[, end]][, encoding])

// "Casting" to the same data type is always allowed, regardless of the casting mode...

// "warm-up" the PRNG...

// 'abxxcd' will be treated as 'ab')

// (`[0, h[0] >>> 1]` is a 33 bit unsigned right shift. This is the

// (the user may have provided their own)

// - buffer - a Buffer to search

// - byteOffset - an index into `buffer`; will be clamped to an int32

// - dir - true for indexOf, false for lastIndexOf

// - encoding - an optional encoding, relevant is val is a string

// - val - a string, Buffer, or number

// ----------------

// -----------------

// 1 (version) + 1 (num_sections) + 1 (state_length) + N (state) + 1 (other_length) + 1 (state_index) + 1 (seed_length)

// 1. Select a data point at random for the first centroid...

// 2 leads in a row

// 2-5. For each data point, compute the distances to each centroid, find the closest centroid, and, based on the distance to the closest centroid, assign a probability to the data point to be chosen as centroid `c_j`...

// 32bit int.

// 6. Set centroid data...

// ================

// Account for augmented dimensions (note: expanding the strides array to account for prepended singleton dimensions does **not** affect the index offset):

// Account for environments which do not treat string character indices as "own" properties...

// Account for environments which treat `arguments` differently...

// Add a source directive for debugging:

// Add bigrams:

// Add the value argument...

// Address `typeof null` => `object` (see http://wiki.ecmascript.org/doku.php?id=harmony:typeof_null):

// Adjust the array shape to satisfy the minimum number of dimensions...

// All elements equally likely...

// Any enumerable properties...

// Anything else let's inspect with %O

// Anything goes for "unsafe" casting...

// Append `e`.

// Apply any `formatters` transformations

// Apply dynamic padding.

// Apply env-specific formatting (colors, etc.)

// Are we oob?

// Arguments:

// Array shape:

// Arrays and plain objects...

// Attach properties and methods to the accumulator:

// Attempt to override the `toStringTag` property. For built-ins having a `Symbol.toStringTag` property (e.g., `JSON`, `Math`, etc), the `Symbol.toStringTag` property is read-only (e.g., , so we need to wrap in a `try/catch`.

// Avoid overflow...

// Based Arthur's and Vassilvitskii's paper "kmeans++: The Advantages of Careful Seeding" (see conclusion), randomly select candidate centroids and pick the candidate which minimizes the total squared distance...

// Based on http://stackoverflow.com/a/22747272/680742, the browser with

// Buffer already qualifies as a "random" sample:

// Buffer instances.

// Buffer offset:

// Buffer#write(string)

// Build an object containing all ndarray properties needed to revive a serialized ndarray...

// Cache references to the parent constructor and parent constructor methods:

// Call the parent constructor:

// Cannot have own `constructor` property:

// Capture the regular expression pattern and any flags:

// Case: -2**-20 <= f < 2**-20

// Case: 0 < x < 2**-1022

// Case: Node.js

// Case: RANGE > range

// Case: browsers

// Case: browsers and web workers

// Case: case-sensitive

// Case: row-major

// Case: unknown

// Cast data to generic array...

// Check for `Error` objects from the same realm (same Node.js `vm` or same `Window` object)...

// Check for `NaN`...

// Check for the abstract class...

// Check for typed array objects from the same realm (same Node.js `vm` or same `Window` object)...

// Check if module is in cache

// Check if the string starts with a forward slash...

// Check if we are still building our cache of data vectors...

// Check if we can reuse allocated memory...

// Check if we have yet to compute initial centroids...

// Check if we need to compute initial centroids...

// Check if we need to update the data point mean vector...

// Check that all array element dimensions are consistent:

// Chrome 1-12 returns 'function' for regular expression instances (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof):

// Circular reference...

// Class instances...

// Cloning requires ES5 or higher...

// Close the IIFE:

// Close the function call:

// Close the function:

// Closing braces...

// Code generation. Start with function definition...

// Code generation. Start with the function definition...

// Code generation. Start with the function definition:

// Coerce to Number.

// Common case.

// Compute initial centroids...

// Compute initial clusters:

// Compute the accumulator index offset:

// Compute the centroids buffer index offset to point to the closest centroid:

// Compute the cumulative probabilities...

// Compute the data point buffer index offset to point to the next data point:

// Compute the number of bytes...

// Compute the number of elements...

// Compute the sum of squared distances were we to include the candidate centroid...

// Compute the vector magnitude...

// Copy 0 bytes; we're done

// Copy `shape` and `strides` to prevent external mutation:

// Copy data into the buffer (why? because (1) we have no guarantee that program execution is synchronous, and, thus, we have no guarantee that data vectors will not have been mutated before sampling, and (2) we can freely mutate buffer data, as may be needed during normalization):

// Copy the provided seed array to prevent external mutation, as mutation would lead to an inability to reproduce PRNG values according to the PRNG's stated seed:

// Copy the values from the 2D array

// Create a local object that'll be exported or referenced globally.

// Create a lower-level base constructor:

// Create a new error...

// Create a new module (and put it into the cache)

// Create a new regular expression:

// Create a new seed "view":

// Create a new state "view":

// Create a new state (table) "view":

// Create a prototype which inherits from the parent prototype:

// Create a scratch array for storing cumulative probabilities:

// Create a scratch array for storing squared distances:

// Create a seed "view":

// Create a single linear array in which to store accumulated statistics:

// Create a state "view":

// Create a state (table) "view":

// Create a strided array for storing closest centroid results:

// Create accumulator for partitioning data into clusters:

// Create an array for storing second moments:

// Create an empty matrix

// Create and return sparse word vector...

// Create seeded PRNGs:

// Create the code which accesses the nested array values and pushes them onto the flattened array.

// Create the function body...

// Create the function in the current scope to allow access to required modules:

// Create the function in the global scope:

// Create the nested for loops...

// Create the variables...

// Crop output to the desired size (undo dynamic padding).

// Custom probabilities...

// Data buffer parameter...

// De-reference `init` so that it and its internal variables can be garbage collected:

// Debug.formatArgs = formatArgs;

// Decode in chunks to avoid "call stack size exceeded".

// Define a mask for the least significant 16 bits (low word): 65535 => 0x0000ffff => 00000000000000001111111111111111

// Define the array buffer stride (in bytes):

// Define the number of computed statistics:

// Delete property as existing getters/setters prevent assigning value to specified property:

// Detect initial `y`, make sure it never matches.

// Determine if the array can be stored contiguously:

// Determine if the candidate is the best candidate we have seen thus far...

// Determine the distance functions...

// Determine the minimum and maximum linear indices which are accessible by the array view:

// Determine whether we need to update the PRNG state:

// Disabled?

// Double check webkit in userAgent just in case we are in a worker

// EXPORTS //

// Eagerly determine array dimensions:

// Empty buffer means no match

// Empty function...

// Empty...

// Ensure a non-zero initial state array:

// Ensure abstract typed array class has expected name:

// Ensure that each array element is an array of the same size:

// Ensure that the array is compatible with a single memory segment:

// Equivalent to (mult * (RANGE+1)) == range+1, but avoids overflow...

// Execute the module function

// Exit early.

// FUNCTIONS //

// Fall through...

// Fallback: Return an object instance of the Buffer class

// Fatal error conditions

// Finally, search either indexOf (if dir is true) or lastIndexOf

// Find the closest centroid by computing the distance from the provided data point to each centroid:

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,

// First three values...

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97

// Flag the module as loaded

// Flip the signs of negative strides:

// For each data point, find the closest centroid...

// For every power of `(RANGE+1)`, we determine a random factor:

// For small matrices, resort to naive multiplication.

// For the trivial case of one centroid, we are done which means we can skip to setting the output centroid data...

// Force coersion to uint32. This will also coerce falsey/NaN values to 0.

// Function to invoke to create an ndarray:

// Generate a random cluster index:

// Generate an array of data vector indices...

// Generate an integer index on the interval: [0,i]

// Get the next word of "raw"/untempered state:

// Get the size of the current dimension:

// Given a 32bit int and an int representing a number of bit positions,

// Given a 64bit int (as an array of two 32bit ints) and an int

// Given a block, returns murmurHash3's final x64 mix of that block.

// Given a block, returns murmurHash3's final x86 mix of that block.

// Given a string and an optional seed as an int, returns a 128 bit

// Given a string and an optional seed as an int, returns a 32 bit hash

// Given two 32bit ints, returns the two multiplied together as a

// Given two 64bit ints (as an array of two 32bit ints) returns the two

// HELPER FUNCTIONS

// Handle string cases:

// If `check()` returns a value less than `ndims`, trim off the inconsistent dimensions:

// If a `stack` property is present, copy it over...

// If an array does not contain any elements, then no data to store, and, if the array is unordered, adjacent array elements are not guaranteed to be stored next to each other.

// If debug isn't set in LS, and we're in Electron, try to load $DEBUG

// If not provided a data buffer, create it; otherwise, see if we need to cast a provided data buffer to another data type or perform a copy...

// If not provided a shape, infer from a provided data source...

// If provided a PRNG state, we ignore the `seed` option...

// If provided an `Object`, return an equivalent primitive!

// If required by the metric, normalize the data vector...

// If required by the metric, normalize the data vectors along the dimensions...

// If the `typeof` operator returned something other than `object`, we are done. Otherwise, we need to check for an internal class name or search for a constructor.

// If the above failed, fall back to a more robust (and significantly slower) means for resolving underlying data types:

// If the array element is not an array or is not the same size, we have found an inconsistent dimension:

// If the constructor has not already been created, create it; otherwise, return a memoized constructor...

// If the indices are "inbounds", then the buffer length is compatible:

// If the ndarray can be considered both "row-major" and "column-major", then use the default order; otherwise, use the ndarray's stated layout order...

// If the previous statement did not throw an error, we can cache the constructor...

// If the user indicated that "any" order suffices (meaning the user does not care about ndarray order), then we use the default order, unless the input ndarray is either unequivocally "row-major" or "column-major" or configured as such....

// If this is the first data vector, we need to begin caching data vectors for future centroid initialization...

// If we are provided an "external" PRNG, we don't support getting or setting PRNG state, as we'd need to check for compatible state value types, etc, entailing considerable complexity.

// If we didn't find any constructors, this could be due to 1) we have yet to create the constructor or 2) we have been provided invalid options. Either way, let's attempt to create an ndarray constructor...

// If we encounter an escaped % then don't increase the array index

// If we have a remainder, run a clean-up loop...

// If we have yet to determine array strides, we assume that we can compute the strides, along with the index offset, for a **contiguous** data source based solely on the array shape and specified memory layout order...

// If we searched the string to no avail or if the first letter is not `/`, assume that the string is not of the form `/[...]/[guimy]`:

// In "safe" casting mode, only casts which preserve values are allowed...

// In order to ensure consistent ES5/ES6 behavior, cast input value to an object (strings, numbers, booleans); ES5 `Object.getPrototypeOf` throws when provided primitives and ES6 `Object.getPrototypeOf` casts:

// Increment the data buffer index offset to point to the next data point:

// Increment the data vector counter:

// Infer the array "order" from the stride array (this is supplementary to the `order` parameter):

// Inherit from the parent constructor:

// Initialize a PRNG for randomly assigning data points to clusters:

// Initialize a results object:

// Initialize a scratch vector for copying input vectors:

// Initialize a strided (MxN) array for storing accumulated centroids...

// Initialize accumulators which will write to sections of the linear array:

// Initialize an accumulator for computing initial centroids:

// Initialize an accumulator for computing the mean vector and associated standard deviation along each dimension:

// Initialize an internal cluster statistics accumulator:

// Initialize an internal matrix for storing centroids:

// Initialize an internal matrix for tabulating cluster statistics:

// Initialize metric-related variables...

// Initialize sections:

// Initialize the internal PRNG state:

// Initialize the remaining state array elements:

// Initialize the shape/dimensions array:

// Initialize the shuffle table...

// Initialize token array:

// Internet Explorer and Edge do not support colors.

// Invalid ranges are not set to a default, so can range check early.

// Is firebug? http://stackoverflow.com/a/398120/376773

// Is firefox >= v31?

// Is webkit? http://stackoverflow.com/a/16459606/376773

// Isolate the least significant 16-bits:

// Last three values...

// Lazily generate table...

// Load entry module and return exports

// Loop invariants: result < mult && mult <= range

// MAIN //

// METHODS //

// MODULES //

// MSB (most significant bit) is 1

// Magic number `0` for offset as we know that the matrix view begins at the first buffer element

// Magic number `1` as we know that the matrix is row-major single-segment contiguous

// Magic number `1` as we know that these matrices are row-major single-segment contiguous

// Magic number `1` for stride as matrix is row-major single-segment contiguous

// Magic number `1` for stride is based on knowing that the matrix is row-major single-segment contiguous

// Magic numbers arise from knowing that matrices are row-major single-segment contiguous

// Magic numbers come from knowing that `sbuf` is an interleaved strided array...

// Magic numbers come from knowing that the `stats` array is interleaved

// Make sure both matrices are the same size.

// Mapping from data types to underlying buffer constructors...

// Mapping from ndarray data buffer constructors to data types...

// NB: In an Electron preload script, document will be defined but not fully

// NOTE: possibility of perf boost if key enumeration order is known (see http://stackoverflow.com/questions/18531624/isplainobject-thing).

// NOTES //

// No casts between different data types are allowed in "none" or "equiv" casting modes...

// No need to verify that "this.length <= MAX_UINT32" since it's a read-only

// No-op...

// Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

// Node converts strings with length < 2 to ''

// Node strips out invalid characters like \n and \t from the string, base64-js does not

// Node's code seems to be doing this and not & 0x7F..

// Node.js specific (system errors)...

// Normalize `x` or `x/2`...

// Normalize a matrix row:

// Normalize byteOffset

// Normalize byteOffset: negative offsets start from the end of the buffer

// Normalize the vector...

// Normalize val

// Note that, since the stride is negative, this operation increments, not decrements, the offset...

// Note: `r` exists on the interval `[0,1)`

// Note: cannot use `length < kMaxLength()` here because that fails when

// Note: cannot use `typeof` directly, as various browser engines incorrectly return `'function'` when operating on non-function objects, such as regular expressions and NodeLists.

// Note: from Arthur's and Vassilvitskii's paper "kmeans++: The Advantages of Careful Seeding" (see conclusion)

// Note: instead of repeatedly computing centroid distances for each data point, we only need to compute the distances for the most recent centroid and to maintain a hash of closest distance results...

// Note: order should match `ctors` order

// Note: property order matters in order to maintain consistency of PRNG "shape" (hidden classes).

// Note: see first and second post-conditions.

// Note: see third post-condition.

// Note: the following is likely to be an "out-of-order" copy...

// Note: the following should never choose an already chosen centroid (why? because a centroid's minimum squared distance is `0`, which means it will either correspond to a cumulative probability of `0` or will correspond to a cumulative probability equal to the previous cumulative probability, thus leading to the equivalent of a no-op iteration)

// Note: this default applies to all initialization methods

// Note: we assume that an option value can be uniquely serialized to a `string` via `JSON.stringify()`...

// Note: we assume that an option value can be uniquely serialized to a `string` via `toString()`...

// Note: we ignore whether `options` has a `buffer` property

// Note: we only check for indices, as properties attached to a `String` object are properly detected as enumerable above.

// Note: we skip the first element, as no further swaps are possible given that all other indices are excluded from swapping...

// Note: we use an array to avoid unordered key look-up

// Note: yes, we are precluding the `arguments` array-like object from having other enumerable properties; however, this should (1) be very rare and (2) not be encouraged (e.g., doing something like `arguments.a = 'b'`; in certain engines directly manipulating the `arguments` value results in automatic de-optimization).

// Now we need to remove `args[index]` since it's inlined in the `format`

// OR the last index of `val` in `buffer` at offset <= `byteOffset`.

// Object.prototype.hasOwnProperty.call

// Objects with no prototype (e.g., `Object.create( null )`) are plain...

// Objects...

// Only escape the characters between the `/`:

// Only randomly sample from the data buffer if the number of centroids is not equal to the number of data vectors...

// Order:

// Our recursive multiplication function.

// Override `__proto__` to avoid touching inherited accessors:

// PRIVATE FUNCTIONS

// PUBLIC FUNCTIONS

// PhantomJS 1.9 returns 'function' for `NodeList` instances (underscore #2236):

// Plain array or object...

// Prevent the above loop from being discarded by the compiler...

// Primitive, Buffer, special class instance...

// Primitives and functions...

// Propagate the number of consistent dimensions up the recursion chain...

// Prototype `constructor` property must be a function (see also https://bugs.jquery.com/ticket/9897 and http://stackoverflow.com/questions/18531624/isplainobject-thing):

// Pull a state from the table:

// Push the "best" candidate to our list of centroids:

// Put a matrix into the top left of a matrix of zeros.

// Randomly assign each data point to a cluster and update the respective cluster's centroid...

// Reassemble:

// Recompute the distance based on the updated centroid position:

// Recursively examine nested elements:

// Remove last character.

// Remove last two characters.

// Remove suffixing `y` and append `i`.

// Remove the sample observations:

// Replace the pulled state:

// Restore original prototype:

// Retrieve the current state index:

// Return an augmented `Uint8Array` instance, for best performance

// Return early if start > this.length. Done here to prevent potential uint32

// Return the exports of the module

// Return the instance:

// Return the ndarray instance:

// Safari 8 returns 'object' for typed array and weak map constructors (underscore #1929):

// Screen for obvious non-objects...

// Search for a byte value [0-255]

// Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

// See: https://en.wikipedia.org/wiki/Base64#URL_applications

// See: https://github.com/beatgammit/base64-js/issues/42

// Set `diff` timestamp

// Set private properties...

// Set the constructor to refer to the child constructor:

// Set the first element of the state array to the provided seed:

// Set the value:

// Set up cache to hold tokens for substring matches:

// Some versions of I.E. have different rules for clearTimeout vs setTimeout

// Special case: looking for empty string/buffer always fails

// Split on whitespace:

// Standard suffix manipulations.

// Stem `value`.

// Step 1a.

// Step 1b.

// Step 1c.

// Step 2.

// Step 3.

// Step 4.

// Step 5.

// Stride array...

// Subnormal number, scale up `x`:

// Support decoding URL-safe base64 strings, as Node.js does.

// Swallow

// Swap elements:

// Synonyms

// TODO: Legacy, not needed anymore. Remove in next major version.

// TODO: add support for generator functions?

// TODO: consider moving to an "extended" BLAS package

// TODO: eventually remove this function once project has implemented comparable functionality as a standalone package

// TODO: eventually remove this function once project has implemented comparable functionality as a standalone package (e.g., BLAS, which may avoid the naive approach susceptible to overflow/overflow due to summing squares and computing the square root)

// TODO: implementation (?)

// TODO: once an ndarray engine is written, determine whether this function can be replaced by a standalone package

// TODO: remove and use BLAS implementation

// TODO: replace with `isCallable` check

// TODO: replace with `stdlib` pkg

// TODO: reserved for future use

// TODO: validate that minimum number of dimensions does not exceed the maximum number of possible dimensions (in theory, infinite; in practice, determined by max array length; see https://github.com/stdlib-js/stdlib/blob/ac350059877c036640775d6b30d0e98e840d07cf/lib/node_modules/%40stdlib/ndarray/ctor/lib/main.js#L57)

// TODO: write (browser) polyfill

// TODO: write polyfill

// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context

// Tempering transform to compensate for the reduced dimensionality of equidistribution:

// Test basic support...

// Test for object-specific method:

// Test if the prototype matches the global `Object` prototype (same realm):

// Test that all properties are own properties (cross-realm; *most* likely a plain object):

// The Browser also has localStorage in the global context.

// The approach which follows is to resolve a view index to its subscripts and then plug the subscripts into the standard formula for computing the linear index in the underlying data buffer...

// The destination range is an integer power of the generator's range...

// The final "%c" is somewhat tricky, because there could be other

// The final `>>>0` converts the intermediate sum to an unsigned integer (possible integer overflow during sum):

// The first element of the state array must equal the supported state array schema version...

// The length of the "other" section must equal `1`...

// The length of the "seed" section much match the empirical length...

// The length of the "state" section must equal `2`...

// The length of the "state" section must equal `N`...

// The length of the "table" section must equal `TABLE_LENGTH`...

// The module cache

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect

// The require function

// The second element of the state array must contain the number of sections...

// The state array must have a minimum length...

// This behaves neither like String nor Uint8Array in that we set start/end

// This hackery is required for IE8/9, where

// This is exclusively for simplicity:

// This works if eval is allowed (see CSP)

// This works if the window reference is available

// This works in non-strict mode

// Tokenize document after pre-processing...

// Trim off extra bytes after placeholder bytes are found

// Trivial case where we have all negative strides...

// Trivial case where we have all positive strides...

// Turn initial `Y` back to `y`.

// Update cluster results to include the initial centroids (why? so that, even if no data is provided, the `results` object contains the provided centroids):

// Update cluster statistics:

// Update number of data points belonging to a cluster:

// Update the PRNG state:

// Update the centroids...

// Update the closest centroid:

// Update the cluster's squared distance mean and standard deviation (using Welford's algorithm):

// Update the data point index offset:

// Update the index offset to point to the next row:

// Update the output matrix...

// Update the output vector:

// Update the respective cluster centroid:

// Update the results object:

// Update the state index:

// Update the total sum of squared distances within a cluster:

// Usage:

// Use a for loop to avoid recursion

// Use a heuristic to avoid memoization of highly-specialized ndarray constructors, thus effectively introducing "fast" and "slow" ndarray construction paths...

// Use rejection sampling to handle edge case where the total cumulative probability does not equal unity due to accumulated floating-point errors and is less than `r` (*very* rarely should this require more than one iteration)...

// Use unrolled loops if both strides are equal to `1`...

// User provided a covariance matrix instead of dataset.

// User provided a dataset but wants us to compute and use the covariance matrix.

// VARIABLES //

// Validate some options before others...

// Validate the remaining options...

// WARNING: `typeof` is not a foolproof check, as certain envs consider RegExp and NodeList instances to be functions

// WARNING: in C, this is not thread safe

// WARNING: in C, this would not be thread safe

// Walk the prototype tree until we find an object having a desired class...

// Walk the prototype tree until we find an object having a desired native class...

// Walk the prototype tree until we find an object having the desired native class...

// Warning: maxLength not taken into account in base64Write

// We consider `result` as expressed base `(RANGE+1)`:

// We go 1 magnitude less, for safety

// We need to de-construct the string...

// We only are interested in the *last* %c

// We return undefined, instead of nothing here, so it's

// When determining the bucket size, avoid overflow...

// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally

// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally

// Why the magic number `1`? Because we know that the centroids matrix should be row-major single-segment contiguous.

// Why? Because we cannot guarantee someone hasn't mutated the output array

// Why? We mention `arguments` in the function and perform a subsequent reassignment.

// Writing a hex string, for example, that contains invalid characters will

// XXX (@Qix-) should we be logging these?

// [ n_obs, sum_squared_dist, mean_squared_dist, stdev_squared_dist ]

// __webpack_public_path__

// `d` is one more than the index of the last consistent dimension and thus equal to the number of consistent dimensions:

// `rows` and `cols` are the dimensions of the output matrix.

// a is equivalent to this

// added together as a 64bit int (as an array of two 32bit ints).

// arguments passed either before or after the %c, so we need to

// array of indices

// array of two 32bit ints) rotated left by that number of positions.

// array of two 32bit ints) shifted left by that number of positions.

// ascending copy from start

// asm type annotation

// asm type annotation; possible integer overflow

// assume utf8

// at `j` is the size of the first non-prepended dimension

// avoid extra slice()

// base64 is 4/3 + up to two characters of the original data

// best candidate

// best sum

// byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer

// cached from whatever global is present so that test runners that stub it

// cause everything after the first invalid character to be ignored. (e.g.

// chrome 9-10 lack `subarray`

// clamped

// coercion fail below.

// column-major

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)

// create a fake namespace object

// debug.rawLog = rawLog;

// define __esModule on exports

// define getter function for harmony exports

// descending copy from end

// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632

// don't break things.  But we need to wrap it in a try catch in case it is

// e.g., 5%(2+1) == 2

// easier to handle this case. if(!global) { ...}

// empty string to avoid regexp issues

// encode to utf16 (surrogate pair dance)

// encode utf8

// env-specific initialization logic for debug instances

// equivalent to `s & 0xffffffffUL` in original C implementation

// eslint-disable-line eqeqeq

// eslint-disable-line guard-for-in

// eslint-disable-line id-length

// eslint-disable-line max-len

// eslint-disable-line no-buffer-constructor

// eslint-disable-line no-empty-function

// eslint-disable-line no-eval

// eslint-disable-line no-new-func

// eslint-disable-line no-underscore-dangle

// eslint-disable-line no-unused-vars

// eslint-disable-line no-useless-escape

// eslint-disable-line stdlib/no-builtin-math

// eslint-disable-line stdlib/no-redeclare

// eslint-disable-line stdlib/require-globals

// eslint-disable-next-line complexity

// eslint-disable-next-line no-console

// eslint-disable-next-line no-proto

// eslint-disable-next-line no-underscore-dangle

// eslint-disable-next-line stdlib/no-redeclare

// explicitly

// expose the module cache

// expose the modules object (__webpack_modules__)

// figure out the correct index to insert the CSS into

// for envs missing Object.prototype.constructor (e.g., Safari 5-7)

// function because try/catches deoptimize in certain engines.

// g can still be undefined, but nothing to do about it...

// getDefaultExport function for compatibility with non-harmony modules

// go through the array every three bytes, we'll deal with trailing stuff later

// hash using the x64 flavor of MurmurHash3, as an unsigned hex.

// hash using the x86 flavor of MurmurHash3, as an unsigned hex.

// high-level

// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages

// identity bit shift to ensure integer

// ie10 has broken `subarray`

// if clearTimeout wasn't available but was latter defined

// if setTimeout wasn't available but was latter defined

// in JavaScript, we only explicitly have doubles

// index of the closest centroid

// initialized. Since we know we're in Chrome, we'll just detect this case

// is surrogate component

// last char was a lead

// length is NaN (which is otherwise coerced to zero.)

// low-level

// mode & 1: value is a module id, require it

// mode & 2: merge all properties of value into the ns

// mode & 4: return value when already ns object

// mode & 8|1: behave like require

// multiplied together as a 64bit int (as an array of two 32bit ints).

// must be an even number of digits

// must be multiple of 3

// no default

// no lead yet

// non-generic

// not used by this implementation

// only place where we need to right shift 64bit ints.)

// pad the end with zeros, but make sure to not forget the extra bytes

// point to new shared state

// property of a typed array.

// range/mult < RANGE+1 (no endless loop)

// replacement char (U+FFFD) and advance only 1 byte

// representing a number of bit positions, returns the 64bit int (as an

// returns the 32bit int rotated left by that number of positions.

// round to nearest

// row-major

// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error

// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.

// shim for using process in browser

// slight optimization to avoid modulo arithmetic when max+1 < idx <= 2*(max+1)

// slight optimization to avoid modulo arithmetic when |idx| <= max+1

// squared distance

// state index

// the `console.log` function doesn't have 'apply'

// the lowest limit is Chrome, with 0x10000 args.

// this algorithm can be implemented with matrices of different sizes.

// this throws if `array` is not a valid ArrayBuffer

// to their upper/lower bounds if the value passed is out of range.

// total cumulative distance

// truncation

// truncation and wrap around

// typed array instances can be augmented

// undefined is handled specially as per ECMA-262 6th Edition,

// unexpected trail

// unpaired lead

// using the x86 flavor of MurmurHash3, as an unsigned int.

// v8 likes predictible objects

// valid lead

// valid surrogate pair

// we did not generate a valid codePoint so insert a

// weak test

// webpackBootstrap

// when when somebody has screwed with setTimeout but no I.E. maddness

// wrap around

// wrapped in strict mode code which doesn't define any globals.  It's inside a

// xored together as a 64bit int (as an array of two 32bit ints).

//normal enviroments in sane situations
